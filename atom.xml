<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知与行</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-28T02:39:38.212Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>QiYan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux计划任务和日志</title>
    <link href="http://example.com/2022/11/27/Linux-crond/"/>
    <id>http://example.com/2022/11/27/Linux-crond/</id>
    <published>2022-11-28T02:39:38.213Z</published>
    <updated>2022-11-28T02:39:38.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h2><p>1、在未来的某个时间点执行一次某任务；</p><pre><code>atbatchat 时间at&gt; COMMANDat&gt; Ctrl+d指定时间：    绝对时间：HH:MM， DD.MM.YY  MM/DD/YY    相对时间：now+#        单位：minutes, hours, days, weeks    模糊时间：noon, midnight, teatime命令的执行结果：将以邮件的形式发送给安排任务的用户at -l = atq：查看at -d AT_JOB_ID = atrm  AT_JOB_ID：删除某个计划任务</code></pre><p>2、周期性地执行某任务</p><pre><code>cron：自身是一个不间断运行的服务anacron: cron的补充，能够实现让cron因为各种原因在过去的时间该执行而未执行的任务在恢复正常执行一次；cron:     系统cron任务：        /etc/crontab            分钟  小时  天  月  周  用户  任务    用户cron任务:        /var/spool/cron/USERNAME            分钟  小时  天  月  周  任务            时间的有效取值：        分钟：0-59        小时：0-23        天：1-31        月：1-12        周：0-7，0和7都表示周日            时间通配表示：        *: 对应时间的所有有效取值            3 * * * *             3 * * * 7            13 12 6 7 *        ,: 离散时间点：             10,40 02 * * 2,5         -：连续时间点：            10 02 * * 1-5        /#: 对应取值范围内每多久一次            */3 * * * *                每两小时执行一次：        08 */2 * * *    每两天执行一次：        10 04 */2 * *执行结果将以邮件形式发送给管理员：    */3 * * * * /bin/cat /etc/fstab &amp;&gt; /dev/nullcron的环境变量：cron执行所有命令都去PATH环境变量指定的路径下去找    PATH  /bin:/sbin:/usr/bin:/usr/sbin用户任务的管理：    crontab        -l: 列出当前用户的所有cron任务        -e: 编辑         -r: 移除所有任务        -u USERNAME: 管理其用户的cron任务</code></pre><h2 id="Linux上的日志系统"><a href="#Linux上的日志系统" class="headerlink" title="Linux上的日志系统"></a>Linux上的日志系统</h2><blockquote><p>CentOS 6之前只有rsyslogd 的年代中，由于 rsyslogd 必须要开机完成并且执行了 rsyslogd 这个daemon 之后，日志文件才会开始记录。所以，核心还得要自己产生一个 klogd 的服务，才能将系统在开机过程、启动服务过程中的信息记录下来。然后等 rsyslogd 启动后才传送给它来处理。 现在有了systemd 之后，由于这玩意儿是核心唤醒的，然后又是第一支执行的软件，它可以主动调用 systemd-journald 来协助记载登录文件。因此在开机过程中的所有信息，包括启动服务与服务若启动失败的情况等等，都可以直接被记录到systemd-journald 里头去！</p></blockquote><p>syslog服务：  </p><ul><li>syslogd: 系统，非内核产生的信息  </li><li>klogd：内核，专门负责记录内核产生的日志信息</li></ul><blockquote><p>CentOS 7.x 使用systemd 提供的 journalctl 日志管理<br>           rsyslog.service：主要记录系统与网络等服务的讯息<br>           logrotate：主要在进行登录文件的轮替功能。</p><p>系统由systemd 所管理，那所有经由 systemd 启动的服务，如果再启动或结束的过程中发生一些问题或者是正常的讯息, 就会将该讯息由 systemd-journald.service 以二进制的方式记录下来，之后再将这个讯息发送给rsyslog.service 作进一步的记载。 systemd-journald.service 的记录主要都放置于内存中，因此在存取方面性能比较好。我们也能够通过journalctl 以及 systemctl status unit.service 来查看各个不同服务的登录文件！这有个好处，就是日志文件可以随着个别服务让你查阅，在单一服务的处理上面，要比跑到 &#x2F;var&#x2F;log&#x2F;messages 去大海捞针来的简易很多！</p></blockquote><p>kernel –&gt; 物理终端(&#x2F;dev&#x2F;console) –&gt; &#x2F;var&#x2F;log&#x2F;dmesg（系统启动日志）</p><pre><code># dmesg# cat /var/log/dmesg</code></pre><p>日志需要滚动(日志切割)：</p><pre><code>messages messages.1 messages.2 messages.3</code></pre><p>常见日志文件：</p><pre><code>/var/log/boot.log： 开机的时候系统核心会去侦测与启动硬件，接下来开始各种核心支持的功能启动等。这些流程都会记录在 /var/log/boot.log 里面哩！ 不过这个文件只会存在这次开机启动的信息，前次开机的信息并不会被保留下来！/var/log/cron： crontab 调度有没有实际被进行？ 进行过程有没有发生错误？你的 /etc/crontab 是否撰写正确？在这个登录文件内查询看看。/var/log/dmesg： 记录系统在开机的时候核心侦测过程所产生的各项信息。由于 CentOS 默认将开机时核心的硬件侦测过程取消显示， 因此额外将数据记录一份在这个文件中；/var/log/lastlog： 可以记录系统上面所有的帐号最近一次登陆系统时的相关信息。/var/log/maillog 或 /var/log/mail/*： 记录邮件的往来信息，其实主要是记录 postfix （SMTP 协定提供者） 与 dovecot （POP3 协定提供者） 所产生的讯息啦。 SMTP 是发 信所使用的通讯协定， POP3 则是收信使用的通讯协定。 postfix 与 dovecot 则分别是两 套达成通讯协定的软件/var/log/messages： 这个文件相当的重要，几乎系统发生的错误讯息 （或者是重要的信 息） 都会记录在这个文件中； 如果系统发生莫名的错误时，这个文件是一定要查阅的登 录文件之一。/var/log/secure： 基本上，只要牵涉到“需要输入帐号密码”的软件，那么当登陆时 （不管 登陆正确或错误） 都会被记录在此文件中。 包括系统的 login 程序、图形接口登陆所使 用的 gdm 程序、 su, sudo 等程序、还有网络连线的 ssh, telnet 等程序， 登陆信息都会 被记载在这里；/var/log/wtmp, /var/log/faillog： 这两个文件可以记录正确登陆系统者的帐号信息 （wtmp） 与错误登陆时所使用的帐号信息 （faillog） ！/var/log/httpd/, /var/log/samba/： 不同的网络服务会使用它们自己的登录文件来记载它们 自己产生的各项讯息！上述的目录内则是个别服务所制订的登录文件。</code></pre><p>配置文件：&#x2F;etc&#x2F;syslog.conf</p><pre><code>配置文件定义格式为: facility.priority        action  facility,可以理解为日志的来源或设备目前常用的facility有以下几种：     auth      # 认证相关的     authpriv  # 权限,授权相关的     cron      # 任务计划相关的     daemon    # 守护进程相关的     kern      # 内核相关的     lpr       # 打印相关的     mail      # 邮件相关的     mark      # 标记相关的     news      # 新闻相关的     security # 安全相关的,与auth 类似      syslog   # syslog自己的     user     # 用户相关的     uucp     # unix to unix cp 相关的     local0 到 local7 # 用户自定义使用     *        # *表示所有的facility   priority(log level)日志的级别,一般有以下几种级别(从低到高)     debug           # 程序或系统的调试信息     info            # 一般信息    notice          # 不影响正常功能,需要注意的消息     warning/warn    # 可能影响系统功能,需要提醒用户的重要事件     err/error       # 错误信息     crit            # 比较严重的     alert           # 必须马上处理的     emerg/panic     # 会导致系统不可用的     *               # 表示所有的日志级别     none            # 跟* 相反,表示啥也没有       action(动作)日志记录的位置     系统上的绝对路径    # 普通文件 如： /var/log/xxx     |                   # 管道  通过管道送给其他的命令处理     终端              # 终端   如：/dev/console     @HOST               # 远程主机 如： @10.0.0.1          用户              # 系统用户 如： root     *                   # 登录到系统上的所有用户，一般emerg级别的日志是这样定义的 定义格式例子： mail.info   /var/log/mail.log # 表示将mail相关的,级别为info及                               # info以上级别的信息记录到/var/log/mail.log文件中 auth.=info  @10.0.0.1         # 表示将auth相关的,基本为info的信息记录到10.0.0.1主机上去                               # 前提是10.0.0.1要能接收其他主机发来的日志信息 user.!=error                  # 表示记录user相关的,不包括error级别的信息 user.!error                   # 与user.error相反 *.info                        # 表示记录所有的日志信息的info级别 mail.*                        # 表示记录mail相关的所有级别的信息 *.*                           # 你懂的. cron.info;mail.info           # 多个日志来源可以用&quot;;&quot; 隔开 cron,mail.info                # 与cron.info;mail.info 是一个意思 mail.*;mail.!=info            # 表示记录mail相关的所有级别的信息,但是不包括info级别的 </code></pre><blockquote><p>centos 7 配置文件：rsyslog.conf</p></blockquote><p>日志轮替：</p><pre><code>[root@study ~]# vim /etc/logrotate.conf # 下面的设置是 &quot;logrotate 的默认设置值&quot; ，如果个别的文件设置了其他的参数， # 则将以个别的文件设置为主，若该文件没有设置到的参数则以这个文件的内容为默认值！ weekly &amp;lt;==默认每个礼拜对登录文件进行一次 rotate 的工作 rotate 4 &amp;lt;==保留几个登录文件呢？默认是保留四个！ create &amp;lt;==由于登录文件被更名，因此创建一个新的来继续储存之意！ dateext &amp;lt;==就是这个设置值！可以让被轮替的文件名称加上日期作为文件名喔！ #compress &amp;lt;==被更动的登录文件是否需要压缩？如果登录文件太大则可考虑此参数启动 include /etc/logrotate.d # 将 /etc/logrotate.d/ 这个目录中的所有文件都读进来执行 rotate 的工作！ /var/log/wtmp &#123; &amp;lt;==仅针对 /var/log/wtmp 所设置的参数 monthly &amp;lt;==每个月一次，取代每周！     create 0664 root utmp &amp;lt;==指定新建文件的权限与所属帐号/群组     minsize 1M &amp;lt;==文件大小一定要超过 1M 后才进行rotate （略过时间参数）     rotate 1 &amp;lt;==仅保留一个，亦即仅有 wtmp.1 保留而已。 &#125;# 这个 wtmp 可记录登陆者与系统重新开机时的时间与来源主机及登陆期间的时间。 # 由于具有 minsize 的参数，因此不见得每个月一定会进行一次喔！要看文件大小。 # 由于仅保留一个登录文件而已，不满意的话可以将他改成 rotate 5 吧！[root@study ~]# logrotate [-vf] logfile 选项与参数： -v ：启动显示模式，会显示 logrotate 运行的过程喔！ -f ：不论是否符合配置文件的数据，强制每个登录文件都进行 rotate 的动作！</code></pre><p>观察日志信息（centos7）</p><pre><code>[root@study ~]# journalctl [-nrpf] [--since TIME] [--until TIME] _optional 选项与参数： 默认会输出全部的 log 内容，从旧的输出到最新的讯息     -n ：秀出最近的几行的意思～找最新的信息相当有用     -r ：反向输出，从最新的输出到最旧的数据     -p ：根据后面所接的讯息重要性排序！    -f ：类似 tail -f 的功能，持续显示 journal 日志的内容（实时监测时相当有帮助！）     --since --until：设置开始与结束的时间，让在该期间的数据输出而已     _SYSTEMD_UNIT=unit.service ：只输出 unit.service 的信息而已     _COMM=bash ：只输出与 bash 有关的信息     _PID=pid ：只输出 PID 号码的信息     _UID=uid ：只输出 UID 为 uid 的信息     SYSLOG_FACILITY=[0-23] ：使用 syslog.h 规范的服务相对序号来调用出正确的数据！         范例一：秀出目前系统中所有的 journal 日志数据     [root@study ~]# journalctl     -- Logs begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 00:01:01 CST.--     Aug 17 18:37:52 study.centos.vbird systemd-journal[105]: Runtime journal is using 8.0M （max 142.4M, leaving 213.6M of free 1.3G, current limit 142.4M）.     Aug 17 18:37:52 study.centos.vbird systemd-journal[105]: Runtime journal is using 8.0M （max 142.4M, leaving 213.6M of free 1.3G, current limit 142.4M）.     Aug 17 18:37:52 study.centos.vbird kernel: Initializing cgroup subsys cpuset     Aug 17 18:37:52 study.centos.vbird kernel: Initializing cgroup subsys cpu     .....（中间省略）.....     Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19268]: finished 0anacron Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19270]: starting 0yum-hourly.cron Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19274]: finished 0yum-hourly.cron     # 从这次开机以来的所有数据都会显示出来！通过 less 一页页翻动给管理员查阅！数据量相当大！     范例二：    （1）仅显示出 2015/08/18 整天以及    （2）仅今天及    （3）仅昨天的日志数据内容     [root@study ~]# journalctl --since &quot;2015-08-18 00:00:00&quot; --until &quot;2015-08-19 00:00:00&quot;     [root@study ~]# journalctl --since today     [root@study ~]# journalctl --since yesterday --until today     范例三：只找出 crond.service 的数据，同时只列出最新的 10 笔即可         [root@study ~]# journalctl _SYSTEMD_UNIT=crond.service -n 10     范例四：找出 su, login 执行的登录文件，同时只列出最新的 10 笔即可         [root@study ~]# journalctl _COMM=su _COMM=login -n 10     范例五：找出讯息严重等级为错误 （error） 的讯息！     [root@study ~]# journalctl -p err     范例六：找出跟登录服务 （auth, authpriv） 有关的登录文件讯息     [root@study ~]# journalctl SYSLOG_FACILITY=4 SYSLOG_FACILITY=10 # 更多关于 syslog_facility 的数据</code></pre><p>手动发送日志</p><pre><code>[root@study ~]# logger [-p 服务名称.等级] &quot;讯息&quot; 选项与参数： 服务名称.等级 ：范例一：指定一下，让 dmtsai 使用 logger 来传送数据到登录文件内 [root@study ~]# logger -p user.info &quot;I will check logger command&quot; [root@study ~]# journalctl SYSLOG_FACILITY=1 -n 3 -- Logs begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 18:03:17 CST. --Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29710]: starting 0yum-hourly.cron Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29714]: finished 0yum-hourly.cron Aug 19 18:03:17 study.centos.vbird dmtsai[29753]: I will check logger command</code></pre><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 鸟哥Linux私房菜-基础版</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;任务计划&quot;&gt;&lt;a href=&quot;#任务计划&quot; class=&quot;headerlink&quot; title=&quot;任务计划&quot;&gt;&lt;/a&gt;任务计划&lt;/h2&gt;&lt;p&gt;1、在未来的某个时间点执行一次某任务；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;at
batch

at 时间
at&amp;gt; COMM</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="LOG" scheme="http://example.com/tags/LOG/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="http://example.com/2022/11/27/Linux-shell/"/>
    <id>http://example.com/2022/11/27/Linux-shell/</id>
    <published>2022-11-27T14:05:00.135Z</published>
    <updated>2022-11-27T14:05:00.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程语言分类"><a href="#编程语言分类" class="headerlink" title="编程语言分类"></a>编程语言分类</h2><blockquote><p>编程语言可以分为机器语言、汇编语言、高级语言三种，其中高级语言还可以分为静态语言和动态语言。静态语言也称为编译型语言，即事先通过编译器转换成可执行格式，该语言变量一般是强类型。动态语言则称为解释性语言，即执行时通过解释器边解释边执行，该语言变量一般是弱类型。SHELL则是动态语言的一种，同时它也是一门面向过程的语言。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一段命名的内存空间，我们可以通过变量去操纵变量所对应的内存空间。变量的存储内容可以分为如下几种：</p><ul><li>字符</li><li>数值</li><li>整型</li><li>浮点型: 11.23， 1.123<em>10^1, 0.1123</em>10^2  </li><li>bool型（真、假）</li></ul><p>变量赋值：VAR_NAME&#x3D;VALUE  </p><p>bash变量类型：</p><pre><code>环境变量：作用域为当前shell进程及其子进程；    定义方式一：        export VARNAME=VALUE    定义方式二：        VARNAME=VALUE        export VARNAME    查看当前shell中的环境变量：        printenv        env        export本地变量(局部变量)：    本地变量：set VARNAME=VALUE: 作用域为整个bash进程；        撤消变量：unset VARNAME        查看当shell中变量：set    局部变量：local VARNAME=VALUE：作用域为当前代码段；位置变量：    $1, $2, ...：脚本的第几个参数    shift：脚本的参数前移。第二个参数变为第一个...    ./filetest.sh /etc/fstab /etc/inittab        $1: /etc/fstab        $2: /etc/inittab特殊变量：    $?: 上一个命令的执行状态返回值；    $#：参数的个数    $*: 参数列表    $@：参数列表    </code></pre><p>引用变量：${VARNAME}, 括号有时可省略。如：$<strong>VARNAME</strong>OTHER这种变量后面直接跟其它字符的括号不能省略。</p><p>变量名称：</p><ul><li>只能包含字母、数字和下划线，并且不能数字开头；</li><li>不应该跟系统中已有的环境变量重名；</li><li>最好做到见名知义；</li></ul><p>程序执行，可能有两类返回值：</p><ul><li>程序执行结果（程序输出结果）</li><li>程序状态返回代码（0-255）<ul><li>0: 正确执行</li><li>1-255：错误执行。其中：1，2，127系统预留；</li></ul></li></ul><p>&#x2F;dev&#x2F;null: 软件设备， bit bucket，数据黑洞。在命令执行中，如果我们不想显示命令的执行结果，可以将命令输出重定向到数据黑洞。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>脚本：命令的堆砌，按实际需要，结合命令流程控制机制实现的源程序</p><p>脚本在执行时会启动一个子shell进程；命令行中启动的脚本会继承当前shell环境变量；系统自动执行的脚本(非命令行启动)就需要自我定义需要的各环境变量；</p><p>在脚本的第一行必须添加shebang（魔数），如下</p><pre><code> #!/bin/bash # 其它行中#代表注释行，不执行</code></pre><p>提示：</p><pre><code>“引用”一个命令的执行结果，要使用命令引用；比如: RESAULTS=`wc -l /etc/passwd | cut -d: -f1`；使用一个命令的执行状态结果，要直接执行此命令，一定不能引用；比如: if id user1一句中的id命令就一定不能加引号；如果想把一个命令的执行结果赋值给某变量，要使用命令引用，比如USERID=`id -u user1`;如果想把一个命令的执行状态结果保存下来，并作为命令执行成功与否的判断条件，则需要先执行此命令，而后引用其状态结果，如    id -u user1    RETVAL=$?    此句绝对不可以写为RETVAL=`id -u user1`；</code></pre><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>  与：两边都为真结果为真<br>  或：只要有一个为真结果就为真<br>  非：结果取反<br>  异或：两边结果不同真  </p><p>命令间的逻辑关系：</p><pre><code>逻辑与： &amp;&amp;    第一个条件为假时，第二条件不用再判断，最终结果已经有；    第一个条件为真时，第二条件必须得判断；逻辑或： ||    第一个条件为直时，第二条件不用再判断，最终结果已经有；    第一个条件为假时，第二条件必须得判断；</code></pre><p>如果用户user6不存在，就添加用户user6</p><pre><code>! id user6 &amp;&amp; useradd user6id user6 || useradd user6</code></pre><p>如果用户存在，就显示用户已存在；否则，就添加此用户；</p><pre><code>id user1 &amp;&amp; echo &quot;user1 exists.&quot; || useradd user1</code></pre><p>如果用户不存在，就添加；否则，显示其已经存在；</p><pre><code>! id user1 &amp;&amp; useradd user1 || echo &quot;user1 exists.&quot;</code></pre><p>如果用户不存在，添加并且给密码；否则，显示其已经存在；</p><pre><code>! id user1 &amp;&amp; useradd user1 &amp;&amp; echo &quot;user1&quot; | passwd --stdin user1|| echo &quot;user1 exists.&quot;id user7 &amp;&amp; echo &quot;user exists&quot; || useradd user7 || echo &quot;user7&quot;|passwd --stdin user7</code></pre><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><pre><code>如果用户不存在    添加用户，给密码并显示添加成功；否则    显示如果已经没在，没有添加；</code></pre><p>bash中的条件测试类型：  </p><ul><li><p>整数测试</p><p>  -eq: 测试两个整数是否相等；比如 $A -eq $B<br>  -ne: 测试两个整数是否不等；不等，为真；相等，为假；<br>  -gt: 测试一个数是否大于另一个数；大于，为真；否则，为假；<br>  -lt: 测试一个数是否小于另一个数；小于，为真；否则，为假；<br>  -ge: 大于或等于<br>  -le：小于或等于</p></li><li><p>字符测试</p><p>  &#x3D;&#x3D; ：测试是否相等，相等为真，不等为假<br>  !&#x3D; : 测试是否不等，不等为真，等为假<br>  &gt;： 测试两个字符串大小<br>  &lt;： 测试两个字符串大小<br>  -n string: 测试指定字符串是否为空，空则真，不空则假<br>  -z string: 测试指定字符串是否不空，不空为真，空则为假</p></li><li><p>文件测试</p><p>  -e FILE: 测试文件是否存在<br>  -f FILE: 测试文件是否为普通文件<br>  -d FILE: 测试指定路径是否为目录<br>  -r FILE: 测试当前用户对指定文件是否有读取权限；<br>  -w FILE: 测试当前用户对指定文件是否有写入权限；<br>  -x FILE: 测试当前用户对指定文件是否有执行权限；</p></li></ul><p>条件测试的表达式：  </p><pre><code>[ expression ]  [[ expression ]]  test expression注：&#39;[&#39;和&#39;]&#39; 内部要有一个空格，否则报错。INT1=63INT2=77[ $INT1 -eq $INI2 ][[ $INT1 -eq $INT2 ]]test $INT1 -eq $INT2   [ -e /etc/inittab ][ -x /etc/rc.d/rc.sysinit ] </code></pre><p>如果&#x2F;etc&#x2F;inittab文件的行数大于100，就显示好大的文件；</p><pre><code>[ `wc -l /etc/inittab | cut -d&#39; &#39; -f1` -gt 100 ] &amp;&amp; echo &quot;Large file.&quot;</code></pre><blockquote><p>注：Linux的Shell中0为真，其它整数为假。  </p></blockquote><p>条件判断，控制结构：</p><pre><code>单分支if语句if 判断条件; then  statement1  statement2  ...fi双分支的if语句：if 判断条件; then    statement1    statement2    ...else    statement3    statement4    ...fi多分支的if语句：if 判断条件1; then  statement1  ...elif 判断条件2; then  statement2  ...elif 判断条件3; then  statement3  ...else  statement4  ...ficase语句：选择结构case SWITCH in value1)  statement  ...  ;;value2)  statement  ...  ;;*)  statement  ...  ;;esaca-zA-Z0-9[abc]</code></pre><p>shell处理参数：</p><pre><code>#!/bin/bash#DEBUG=0ADD=0DEL=0for I in `seq 0 $#`; do  if [ $# -gt 0 ]; then      case $1 in      -v|--verbose)        DEBUG=1        shift ;;      -h|--help)        echo &quot;Usage: `basename $0` --add USER_LIST --del USER_LIST -v|--verbose -h|--help&quot;        exit 0        ;;      --add)        ADD=1        ADDUSERS=$2        shift 2        ;;      --del)        DEL=1        DELUSERS=$2        shift 2        ;;      *)        echo &quot;Usage: `basename $0` --add USER_LIST --del USER_LIST -v|--verbose -h|--help&quot;        exit 7        ;;    esac  fidoneif [ $ADD -eq 1 ]; then  for USER in `echo $ADDUSERS | sed &#39;s@,@ @g&#39;`; do    if id $USER &amp;&gt; /dev/null; then      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;$USER exists.&quot;    else      useradd $USER      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;Add user $USER finished.&quot;    fi  donefiif [ $DEL -eq 1 ]; then  for USER in `echo $DELUSERS | sed &#39;s@,@ @g&#39;`; do    if id $USER &amp;&gt; /dev/null; then      userdel -r $USER      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;Delete $USER finished.&quot;    else      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;$USER not exist.&quot;    fi  donefi</code></pre><p>组合测试条件</p><pre><code>-a: 与关系-o: 或关系!： 非关系if [ $# -gt 1 -a $# -le 3 ]if [ $# -gt 1 ] &amp;&amp; [ $# -le 3 ]注：取反要注意,比如！（A -a B） = ！A -o ！B</code></pre><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><pre><code>A=3B=61、let 算术运算表达式    let C=$A+$B2、$[算术运算表达式]    C=$[$A+$B]3、$((算术运算表达式))    C=$(($A+$B))4、expr 算术运算表达式，表达式中各操作数及运算符之间要有空格，而且要使用命令引用    C=`expr $A + $B`</code></pre><h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><pre><code>exit: 退出脚本exit #如果脚本没有明确定义退出状态码，那么，最后执行的一条命令的退出码即为脚本的退出状态码；</code></pre><h2 id="检查语法错误"><a href="#检查语法错误" class="headerlink" title="检查语法错误"></a>检查语法错误</h2><pre><code>bash -n 脚本：检查脚本，结果只供参考bash -x 脚本：单步执行</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>shell循环有三种语法结构： </p><ul><li><p>for</p><pre><code>  for 变量 in 列表; do    循环体  done  for I in 1 2 3 4 5 6 7 8 9 10; do    加法运算  done  如何生成列表：      &#123;1..100&#125;      `seq [起始数 [步进长度]] 结束数`  for (( expr1 ; expr2 ; expr3 )); do     循环体  done</code></pre></li><li><p>while</p><pre><code>  进入循环：条件满足  退出循环：条件不满足  while CONDITION; do    statment  done</code></pre></li><li><p>until</p><pre><code>  进入循环：条件不满足  退出循环：条件满足  until CONDITION; do    statement    ...  done</code></pre></li></ul><p>循环体内中断循环语句：</p><pre><code>break: 提前退出循环  continue：提前结束本轮循环，而进入下一轮循环；</code></pre><p>while特殊用法：</p><pre><code>while的特殊用法一（死循环）：while :;do  donewhile的特殊用法二（读取/PATH/TO/SOMEFILE，将每一行内容赋值给LINE变量）：while read LINE; dodone &lt; /PATH/TO/SOMEFILE</code></pre><h2 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a>declare命令</h2><pre><code>declare -i SUM=0declare [+/-][选项] 变量名    - ：给变量赋予类型属性    + ：取消变量的类型属性    -a：将变量声明为数组型    -i：将变量声明为整型    -x：将变量声明为环境变量    -r：将变量声明为只读变量    -p：查看变量的被声明的类型</code></pre><h2 id="shell选项"><a href="#shell选项" class="headerlink" title="shell选项"></a>shell选项</h2><p>写一个脚本，显示当前系统上shell为-s指定类型的用户，并统计其用户总数。-s选项后面跟的参数必须是&#x2F;etc&#x2F;shells文件中存在的shell类型，否则不执行此脚本。另外，此脚本还可以接受–help选项，以显示帮助信息。</p><pre><code>脚本执行形如：./showshells.sh -s bash显示结果形如：BASH，3users，they are:root,redhat,gentoo#!/bin/bash#if [ $1 == &#39;-s&#39; ]; then  ! grep &quot;$&#123;2&#125;$&quot; /etc/shells &amp;&gt; /dev/null &amp;&amp; echo &quot;Invalid shell.&quot; &amp;&amp; exit 7elif [ $1 == &#39;--help&#39; ];then  echo &quot;Usage: showshells.sh -s SHELL | --help&quot;  exit 0else  echo &quot;Unknown Options.&quot;  exit 8fiNUMOFUSER=`grep &quot;$&#123;2&#125;$&quot; /etc/passwd | wc -l`SHELLUSERS=`grep &quot;$&#123;2&#125;$&quot; /etc/passwd | cut -d: -f1`SHELLUSERS=`echo $SHELLUSERS | sed &#39;s@[[:space:]]@,@g&#39;`echo -e &quot;$2, $NUMOFUSER users, they are: \n$SHELLUSERS&quot;</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数定义：</p><pre><code>function FUNCNAME &#123;  command&#125;FUNCNAME() &#123;  command&#125;</code></pre><p>自定义执行状态返回值：</p><pre><code>return #0-255</code></pre><p>函数的参数:</p><pre><code>在脚本中传递参数方式：./a.sh m n $1: m$2: n在函数中传递参数方式和上面类似：funcion_name 5 6$1: 5$2: 6</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>1、变量中字符的长度：</p><pre><code>$&#123;\#VARNAME&#125;</code></pre><p>2、变量赋值等：</p><pre><code>$&#123;parameter:-word&#125;：如果parameter为空或未定义，则变量展开为“word”；否则，展开为parameter的值；$&#123;parameter:+word&#125;：如果parameter为空或未定义，不做任何操作；否则，则展开为“word”值；$&#123;parameter:=word&#125;：如果parameter为空或未定义，则变量展开为“word”，并将展开后的值赋值给parameter；$&#123;parameter:offset&#125;：取子串，从offset处的后一个字符开始$&#123;parameter:offset:length&#125;：取子串，从offset处的后一个字符开始，取lenth长的子串；  </code></pre><p>4、局部变量</p><pre><code>定义：local VAR_NAME=a=1test() &#123;  a=$[3+4]&#125;testfor I in `seq $a 10`; do  echo $Idone  </code></pre><p>5、命令mktemp</p><pre><code>创建临时文件或目录mktemp /tmp/file.XX    -d: 创建为目录</code></pre><p>6、信号</p><pre><code>kill -SIGNAL PID    1: HUP    2: INT    9: KILL    15: TERM    脚本中，能实现信号捕捉，但9和15无法捕捉Ctrl+c: SIGINTtrap命令：在脚本中捕获相应信号，执行信号对应的命令    trap &#39;COMMAND&#39; 信号列表注：信号0是Exit信号，这是Bash脚本特有信号，不管什么情况，只要退出脚本就会执行。</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>写一个脚本，完成以下任务<br>1、添加5个用户, user1,…, user5<br>2、每个用户的密码同用户名，而且要求，添加密码完成后不显示passwd命令的执行结果信息；<br>3、每个用户添加完成后，都要显示用户某某已经成功添加；  </p><pre><code>useradd user1echo &quot;user1&quot; | passwd --stdin user1 &amp;&gt; /dev/nullecho &quot;Add user1 successfully.&quot;</code></pre><p>写一个脚本，完成以下要求：<br>1、添加3个用户user1, user2, user3；但要先判断用户是否存在，不存在而后再添加；<br>2、添加完成后，显示一共添加了几个用户；当然，不能包括因为事先存在而没有添加的；<br>3、最后显示当前系统上共有多少个用户；</p><p>写一个脚本，完成以下要求：<br>给定一个用户：<br>1、如果其UID为0，就显示此为管理员；<br>2、否则，就显示其为普通用户；  </p><pre><code>NAME=user16USERID=`id -u $NAME`if [ $USERID -eq 0 ]; then  echo &quot;Admin&quot;else  echo &quot;common user.&quot;fiNAME=user16if [ `id -u $NAME` -eq 0 ]; then  echo &quot;Admin&quot;else  echo &quot;common user.&quot;fi</code></pre><p>写一个脚本<br>判断当前系统上是否有用户的默认shell为bash；<br>   如果有，就显示有多少个这类用户；否则，就显示没有这类用户；</p><pre><code>grep &quot;bash$&quot; /etc/passwd &amp;&gt; /dev/nullRETVAL=$?if [ $RETVAL -eq 0 ]; then   ...注：grep 匹配上命令执行结果返回0，否则返回1</code></pre><p>写一个脚本<br>判断当前系统上是否有用户的默认shell为bash；<br>   如果有，就显示其中一个的用户名；否则，就显示没有这类用户；  </p><p>写一个脚本<br>给定一个文件，比如&#x2F;etc&#x2F;inittab<br>判断这个文件中是否有空白行；<br>如果有，则显示其空白行数；否则，显示没有空白行。</p><pre><code>#!/bin/bashA=`grep &#39;^$&#39; /etc/inittab | wc -l`if [ $A -gt 0 ]; then echo &quot;$A&quot;else echo &quot;meiyoukongbaihang&quot;fi                 —— by 张帅                 #!/bin/bashFILE=/etc/inittabif [ ! -e $FILE ]; then  echo &quot;No $FILE.&quot;  exit 8fiif grep &quot;^$&quot; $FILE &amp;&gt; /dev/null; then  echo &quot;Total blank lines: `grep &quot;^$&quot; $FILE | wc -l`.&quot;else  echo &quot;No blank line.&quot;fi</code></pre><p>写一个脚本<br>给定一个用户，判断其UID与GID是否一样<br>如果一样，就显示此用户为“good guy”；否则，就显示此用户为“bad  guy”。 </p><pre><code>#!/bin/bashUSERNAME=user1USERID=`id -u $USERNAME`GROUPID=`id -g $USERNAME`if [ $USERID -eq $GROUPID ]; then  echo &quot;Good guy.&quot;else  echo &quot;Bad guy.&quot;fi进一步要求：不使用id命令获得其id号；#!/bin/bash#USERNAME=user1if ! grep &quot;^$USERNAME\&gt;&quot; /etc/passwd &amp;&gt; /dev/null; then  echo &quot;No such user: $USERNAME.&quot;  exit 1fiUSERID=`grep &quot;^$USERNAME\&gt;&quot; /etc/passwd | cut -d: -f3`GROUPID=`grep &quot;^$USERNAME\&gt;&quot; /etc/passwd | cut -d: -f4`if [ $USERID -eq $GROUPID ]; then  echo &quot;Good guy.&quot;else  echo &quot;Bad guy.&quot;fi</code></pre><p>写一个脚本<br>给定一个用户，获取其密码警告期限；<br>而后判断用户密码使用期限是否已经小于警告期限； </p><pre><code>提示：计算方法，最长使用期限减去已经使用的天数即为剩余使用期限；如果小于，则显示“Warning”；否则，就显示“OK”。圆整：丢弃小数点后的所有内容注：密码文件有些用户的密码修改时间为空，没有处理#!/bin/bashW=`grep &quot;student&quot; /etc/shadow | cut -d: -f6`S=`date +%s`T=`expr $S/86400`L=`grep &quot;^student&quot; /etc/shadow | cut -d: -f5`N=`grep &quot;^student&quot; /etc/shadow | cut -d: -f3`SY=$[$L-$[$T-$N]]if [ $SY -lt $W ]; then  echo &#39;Warning&#39;else  echo &#39;OK&#39;fi                    —— by 董利东</code></pre><p>写一个脚本<br>给定一个文件：<br>如果是一个普通文件，就显示之；<br>如果是一个目录，亦显示之；<br>否则，此为无法识别之文件；</p><p>写一脚本<br>能接受一个参数(文件路径)<br>判定：此参数如果是一个存在的文件，就显示“OK.”；否则就显示”No such file.”</p><p>写一个脚本<br>给脚本传递两个参数(整数)；<br>显示此两者之和，之乘积；  </p><pre><code>#!/bin/bash#if [ $# -lt 2 ]; then  echo &quot;Usage: cacl.sh ARG1 ARG2&quot;  exit 8fiecho &quot;The sum is: $[$1+$2].&quot;echo &quot;The prod is: $[$1*$2].&quot;</code></pre><p>写一个脚本，完成以下任务<br>1、使用一个变量保存一个用户名；<br>2、删除此变量中的用户，且一并删除其家目录；<br>3、显示“用户删除完成”类的信息；  </p><p>写一个脚本<br>传递一个参数(单字符就行)给脚本，如参数为q，就退出脚本；否则，就显示用户的参数；  </p><p>写一个脚本<br>传递一个参数(单字符就行)给脚本，如参数为q、Q、quit或Quit，就退出脚本；否则，就显示用户的参数；  </p><pre><code>#!/bin/bash#if [ $1 = &#39;q&#39; ];then  echo &quot;Quiting...&quot;  exit 1elif [ $1 = &#39;Q&#39; ];then  echo &quot;Quiting...&quot;  exit 2  elif [ $1 = &#39;quit&#39; ];then  echo &quot;Quiting...&quot;  exit 3 elif [ $1 = &#39;Quit&#39; ];then  echo &quot;Quiting...&quot;  exit 4  else  echo $1fi</code></pre><p>传递三个参数给脚本，第一个为整数，第二个为算术运算符，第三个为整数，将计算结果显示出来，要求保留两位精度。形如：  </p><pre><code>./calc.sh 5 / 2Linux中计算可以使用bc计算器[root@localhost shells]# echo &quot;scale=2;5/2&quot;|bc2.50</code></pre><p>传递3个参数给脚本，参数均为用户名。将此些用户的帐号信息提取出来后放置于&#x2F;tmp&#x2F;testusers.txt文件中，并要求每一行行首有行号。  </p><p>写一个脚本：<br>判断当前主机的CPU生产商，其信息在&#x2F;proc&#x2F;cpuinfo文件中vendor id一行中。 </p><pre><code>如果其生产商为AuthenticAMD，就显示其为AMD公司；如果其生产商为GenuineIntel，就显示其为Intel公司；否则，就说其为非主流公司；</code></pre><p>写一个脚本：<br>给脚本传递三个整数，判断其中的最大数和最小数，并显示出来。</p><pre><code>MAX=0MAX -eq $1MAX=$1MAX -lt $2MAX=$2</code></pre><p>写一个脚本：<br>1、设定变量FILE的值为&#x2F;etc&#x2F;passwd<br>2、依次向&#x2F;etc&#x2F;passwd中的每个用户问好，并显示对方的shell，形如：    </p><pre><code>Hello, root, your shell: /bin/bash</code></pre><p>3、统计一共有多少个用户  </p><pre><code>for I in `seq 1 $LINES`; do echo &quot;Hello, `head -n $I /etc/passwd | tail -1 | cut -d: -f1`&quot;; done</code></pre><p>只向默认shell为bash的用户问声好</p><p>写一个脚本：<br>1、添加10个用户user1到user10，密码同用户名；但要求只有用户不存在的情况下才能添加；  </p><pre><code>扩展：接受一个参数：add: 添加用户user1..user10del: 删除用户user1..user10其它：退出adminusers user1,user2,user3,hello,hi</code></pre><p>写一个脚本：<br>计算100以内所有能被3整除的正整数的和；</p><pre><code>取模，取余:%3%2=1100%55=45</code></pre><p>写一个脚本：<br>计算100以内所有奇数的和以及所有偶数的和；分别显示之；  </p><pre><code>let I=$[$I+1]SUM=$[$SUM+$I]let SUM+=$Ilet I+=1 相当于 let I++let I-=1 相当于 let I--    ++I, --I*=、/=、%=</code></pre><p>写一个脚本<br>分别显示当前系统上所有默认shell为bash的用户和默认shell为&#x2F;sbin&#x2F;nologin的用户，并统计各类shell下的用户总数。显示结果形如：  </p><pre><code>BASH，3users，they are:root,redhat,gentooNOLOGIN, 2users, they are:bin,ftp#!/bin/bash#NUMBASH=`grep &quot;bash$&quot; /etc/passwd | wc -l`BASHUSERS=`grep &quot;bash$&quot; /etc/passwd | cut -d: -f1`BASHUSERS=`echo $BASHUSERS | sed &#39;s@[[:space:]]@,@g&#39;`echo &quot;BASH, $NUMBASH users, they are:&quot;echo &quot;$BASHUSERS</code></pre><p>写一个脚本，利用RANDOM生成10个随机数，并找出其中的最大值，和最小值；</p><pre><code>#!/bin/bash#declare -i MAX=0declare -i MIN=0for I in &#123;1..10&#125;; do  MYRAND=$RANDOM  [ $I -eq 1 ] &amp;&amp; MIN=$MYRAND  if [ $I -le 9 ]; then    echo -n &quot;$MYRAND,&quot;  else    echo &quot;$MYRAND&quot;  fi  [ $MYRAND -gt $MAX ] &amp;&amp; MAX=$MYRAND  [ $MYRAND -lt $MIN ] &amp;&amp; MIN=$MYRANDdoneecho $MAX, $MIN</code></pre><p>写一个脚本<br>通过命令行传递一个文件路径参数给脚本：  </p><pre><code>如果参数多了或少了，报错；如果参数指定的路径对应的是目录而不是文件，报错；</code></pre><p>而后，检查路径指定的文件是否为空或不存在，如果是，则新建此文件，并在文件中生成如下内容</p><pre><code>#!/bin/bash# </code></pre><p>而后，使用vim编辑器打开此文件，并让光标处于这个文件的最后一行；</p><p>写个脚本，按如下方式执行：  </p><pre><code>mkscript.sh -v|--version VERSION -a|--author AUTHOR -t|--time DATETIME -d|--description DESCRIPTION -f|--file /PATH/TO/FILE -h|--help </code></pre><p>1、此脚本能创建或打开-f选项指向的文件&#x2F;PATH&#x2F;TO&#x2F;FILE；如果其为空文件，能自动为其生成第一行；如果文件不空，且第一行不是#!&#x2F;bin&#x2F;bash，则中止此脚本，并报错“The file is not a bash script.”；否则，则直接使用vim 打开此文件；<br>提示：&#x2F;PATH&#x2F;TO&#x2F;FILE，要判断其目录是否存在；如果不存在，则报错；</p><p>2、如果为空文件，自动生成的第一行内容为：</p><pre><code>#!/bin/bash</code></pre><p>3、如果为空文件，且使用了-a选项，则在文件中添加“# Author: -a选项的参数”，比如：</p><pre><code># Author: Jerry</code></pre><p>4、如果为空文件，且使用了-t选项，则在文件中添加“# Date: 脚本执行-t选项后指定的时间”，比如：</p><pre><code># Date: 2013-03-08 18:05</code></pre><p>5、如果为空文件，且使用了-d选项，则在文件中添加“# Description: -d选项的内容”，比如：</p><pre><code># Description: Create a bash script file head.</code></pre><p>6、如果为空文件，且使用了-v选项，则在文件添加“# Version: -v后跟的参数”，比如:<br>    # Version: 0.1<br>6、-h选项只能单独使用，用于显示使用帮助；<br>7、其它选项，显示帮助信息；  </p><p>说明：<br>这是一个用于创建脚本的脚本，它可以自动帮助创建一个bash脚本的文件头，这样，以后使用此脚本来创建其它脚本将变得比较高效。比如：</p><pre><code>#!/bin/bash# Author: Jerry(jerry@magedu.com)# Date: 2013-03-08 18:05# Description: Create a bash script file head.# Version: 0.1</code></pre><p>计算100以内所有正整数的和</p><pre><code>#!/bin/bashdeclare -i I=1declare -i SUM=0while [ $I -le 100 ]; do  let SUM+=$I  let I++doneecho $SUM</code></pre><p>练习：转换用户输入的字符为大写，除了quit:</p><pre><code>#!/bin/bash#read -p &quot;Input something: &quot; STRINGwhile [ $STRING != &#39;quit&#39; ]; do  echo $STRING | tr &#39;a-z&#39; &#39;A-Z&#39;  read -p &quot;Input something: &quot; STRINGdone</code></pre><p>每隔5秒查看hadoop用户是否登录，如果登录，显示其登录并退出；否则，显示当前时间，并说明hadoop尚未登录：</p><pre><code>#!/bin/bash#who | grep &quot;hadoop&quot; &amp;&gt; /dev/nullRETVAL=$?while [ $RETVAL -ne 0 ]; do  echo &quot;`date`, hadoop is not log.&quot;   sleep 5  who | grep &quot;hadoop&quot; &amp;&gt; /dev/null  RETVAL=$?doneecho &quot;hadoop is logged in.&quot;</code></pre><p>写一个脚本：  </p><ol><li><p>显示一个菜单给用户：  </p><p> d|D) show disk usages.<br> m|M) show memory usages.<br> s|S) show swap usages.<br> *) quit.</p></li><li><p>当用户给定选项后显示相应的内容；</p></li></ol><p>扩展：<br>    当用户选择完成，显示相应信息后，不退出；而让用户再一次选择，再次显示相应内容；除了用户使用quit；</p><pre><code>#!/bin/bash#cat &lt;&lt; EOFd|D) show disk usages.m|M) show memory usages.s|S) show swap usages.*) quit.EOFread -p &quot;Your choice: &quot; CHOICEwhile [ $CHOICE != &#39;quit&#39; ];do  case $CHOICE in  d|D)    echo &quot;Disk usage: &quot;    df -Ph ;;  m|M)    echo &quot;Memory usage: &quot;    free -m | grep &quot;Mem&quot; ;;  s|S)    echo &quot;Swap usage: &quot;    free -m | grep &quot;Swap&quot; ;;  *)    echo &quot;Unknown..&quot; ;;  esacread -p &quot;Again, your choice: &quot; CHOICEdone</code></pre><p>写一个脚本：  </p><p>1、通过ping命令测试192.168.0.151到192.168.0.254之间的所有主机是否在线，</p><pre><code>如果在线，就显示&quot;ip is up.&quot;，其中的IP要换为真正的IP地址，且以绿色显示；如果不在线，就显示&quot;ip is down.&quot;，其中的IP要换为真正的IP地址，且以红色显示；echo -e &quot;\033[33;44mhello wrold\033[0m&quot;echo -e &quot;\033[33;44;1mhello wrold\033[0m&quot;    -e:开启转义字符    \033[： 后面跟着具体设置    1m：高亮显示    4m：下划线    30-37；前景色    40-47：后景色    5m：闪烁    7m：反显    8m：消隐    9m：斜线awk &#39;PATTERN&#123;ACTION&#125;&#39; file[root@localhost /]# awk -F : &#39;&#123;print $1,$3&#125;&#39; /etc/passwdroot 0bin 1daemon 2注：-F指定分隔符，$#代表分割后的第几列</code></pre><p>要求：分别使用while，until和for(两种形式)循环实现。<br>ping -c -W</p><p>写一个脚本，完成如下功能：<br>说明：此脚本能够为指定网卡创建别名，则指定地址；使用格式如：</p><pre><code>mkethalias.sh -v|--verbose -i ethX  </code></pre><p>1、-i选项用于指定网卡；指定完成后，要判断其是否存在，如果不存在，就退出；<br>2、如果用户指定的网卡存在，则让用户为其指定一个别名，此别名可以为空；如果不空，请确保其事先不存在，否则，要报错，并让用户重新输入；<br>3、在用户输入了一个正确的别名后，请用户输入地址和掩码；并将其配置在指定的别名上；<br>4、如果用户使用了-v选项，则在配置完成后，显示其配置结果信息；否则，将不显示；</p><p>写一个脚本，完成以下功能：  </p><pre><code>1、提示用户输入一个用户名；2、显示一个菜单给用户，形如：U|u  show UIDG|g  show GIDS|s  show SHELLQ|q  quit3、提醒用户选择一个选项，并显示其所选择的内容；</code></pre><p>如果用户给的是一个非上述所提示的选项，则提醒用户给出的选项错误，并请其重新选择后执行；</p><p>写一个脚本：<br>1、判断一个指定的bash脚本是否有语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出，其它任何键可以通过vim打开这个指定的脚本；<br>2、如果用户通过vim打开编辑后保存退出时仍然有错误，则重复第1步中的内容；否则，就正常关闭退出。  </p><pre><code>./syntax.sh a.shuntil bash -n $1 &amp;&gt; /dev/null; do    read -p &quot;Syntax error, [Qq] to quit, others for editing: &quot;  CHOICE    case $CHOICE in    q|Q)        echo &quot;Something wrong, quiting.&quot;        exit 5        ;;    *)        vim + $1        ;;    esacdoneecho &quot;0K&quot;</code></pre><p>练习：写一个脚本，判定192.168.0.200-192.168.0.254之间的主机哪些在线。要求：<br>1、使用函数来实现一台主机的判定过程；<br>2、在主程序中来调用此函数判定指定范围内的所有主机的在线情况。</p><pre><code>#!/bin/bash#PING() &#123;  for I in &#123;200..254&#125;;do    if ping -c 1 -W 1 192.168.0.$I &amp;&gt; /dev/null; then      echo &quot;192.168.0.$I is up.&quot;    else      echo &quot;192.168.0.$I is down.&quot;    fi  done&#125;PING#!/bin/bash#PING() &#123;    if ping -c 1 -W 1 $1 &amp;&gt; /dev/null; then      echo &quot;$1 is up.&quot;    else      echo &quot;$1 is down.&quot;    fi&#125;for I in &#123;200..254&#125;; do  PING 192.168.0.$Idone#!/bin/bash#PING() &#123;    if ping -c 1 -W 1 $1 &amp;&gt; /dev/null; then      return 0    else      return 1    fi&#125;for I in &#123;200..254&#125;; do  PING 192.168.0.$I  if [ $? -eq 0 ]; then    echo &quot;192.168.0.$I is up.&quot;  else    echo &quot;192.168.0.$I is down.&quot;  fidone</code></pre><p>写一个脚本：使用函数完成<br>1、函数能够接受一个参数，参数为用户名； </p><ul><li>判断一个用户是否存在  </li><li>如果存在，就返回此用户的shell和UID；并返回正常状态值；  </li><li>如果不存在，就说此用户不存在；并返回错误状态值；</li></ul><p>2、在主程序中调用函数；  </p><ul><li><p>扩展1：在主程序中，让用户自己输入用户名后，传递给函数来进行判断；</p></li><li><p>扩展2：在主程序中，输入用户名判断后不退出脚本，而是提示用户继续输入下一个用户名；如果用户输入的用户不存在，请用户重新输入；但如果用户输入的是q或Q就退出；</p><pre><code>  #!/bin/bash  #  user () &#123;  if id $1 &amp;&gt; /dev/null ;then  echo &quot;`grep ^$1  /etc/passwd | cut -d: -f3,7`&quot;     return 0  else     echo &quot;no $1&quot;      return 1  fi  &#125;  read -p &quot;please input username:&quot; username  until [ $username == q -o $username == Q ]; do      user $username      if [ $? == 0 ];then          read -p &quot;please input again:&quot; username      else          read -p &quot;no $username,please input again:&quot; username      fi  done</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;编程语言分类&quot;&gt;&lt;a href=&quot;#编程语言分类&quot; class=&quot;headerlink&quot; title=&quot;编程语言分类&quot;&gt;&lt;/a&gt;编程语言分类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编程语言可以分为机器语言、汇编语言、高级语言三种，其中高级语言还可以分为静态语言和</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://example.com/2022/11/27/Linux-program/"/>
    <id>http://example.com/2022/11/27/Linux-program/</id>
    <published>2022-11-27T13:35:48.747Z</published>
    <updated>2022-11-27T13:35:48.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h2><blockquote><p>进程也被叫做运行中的程序。当我们安装完软件之后，只是将软件文件保存在了硬盘中。我们运行软件，则会生成进程。计算机可以运行多个进程，但我们的内存只有一个。因此多个进程要对内存进行管理，这时我们采用虚拟地址空间避免进程去操作不属于自己的内存。在运行过程中所有进程需要的内存可能大于物理内存，这时我们需要使用虚拟内存和页面置换技术。计算机的多进程同时依赖于CPU（单核）的时间分片，因此在运行过程中我们需要进行进程切换。</p></blockquote><p><a href="https://blog.csdn.net/u014379540/article/details/52263114">https://blog.csdn.net/u014379540/article/details/52263114</a></p><h2 id="Linux查看进程命令"><a href="#Linux查看进程命令" class="headerlink" title="Linux查看进程命令"></a>Linux查看进程命令</h2><p>ps: Process State 查看进程状态</p><pre><code>BSD风格:a: 所有与终端有关的进程 u: 显示更详细信息x: 所有与终端无关的进程[demo@localhost ~]$ ps -auxUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot          1  0.2  0.5 194160  5088 ?        Ss   09:15   0:04 /usr/lib/systemd/systemd --switched-root --system --deseriroot          2  0.0  0.0      0     0 ?        S    09:15   0:00 [kthreadd]root          4  0.0  0.0      0     0 ?        S&lt;   09:15   0:00 [kworker/0:0H]root          5  0.0  0.0      0     0 ?        S    09:15   0:01 [kworker/u256:0]demo      19682  0.0  0.2 157456  2228 pts/0    R+   09:41   0:00 ps -aux字段含义：    USER：进程拥有者    PID ：进程ID    %CPU：占用的CPU使用率，它是使用的CPU时间除以进程已运行的时间（cputime/realtime比率），以百分比表示。除非你运气好，否则加起来不会达到100%    %MEM：进程占用的内存使用率    VSZ ：进程虚拟内存大小，一个进程使用的物理空间外加其所有共享库的空间。即进程可能使用的最大内存量。    RSS ：驻留集大小，进程中不能被交换出去部分（分页）的物理内存（指令和变量）。    TTY ：登入者的终端位置,?表示与终端无关    STAT：进程状态    START：进程的启动时间    TIME：进程已执行的时间    COMMAND：所执行的指令，加中括号表示是内核线程。进程状态：    D：不可中断的睡眠（比如磁盘IO，如果该进程所属条件（将文件读入内存中）没有完成不能结束中断）    R：运行或就绪    S：可中断的睡眠（比如网卡，当有数据到来之后可以立即结束中断）    T：停止    Z：僵死（运行结束，但是没有释放资源）        &lt;：高优先级进程    N： 低优先级进程    +：前台进程组（一个bash下可以运行很多进程，这些进程属于同一个进程组）中的进程    l: 多线程进程    s: 会话进程首进程（用户建立的连接。比如ssh，下面会有很多子进程。如果该进程结束，它下面的进程都会被结束）SysV风格：-ps    -elF    -ef    -eF    -e：显示所有进程ps -o PROPERTY1,PROPERTY2ps -o pid,comm,ni ：指定命令输出字段[demo@localhost ~]$ ps -axo pid,comm,ni   PID COMMAND          NI 10056 bash              0 10473 ps                0[demo@localhost ~]$ ps -elFF S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD4 S root          1      0  0  80   0 - 48542 ep_pol  5056   0 08:55 ?        00:00:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 221 S root          2      0  0  80   0 -     0 kthrea     0   0 08:55 ?        00:00:00 [kthreadd]1 S root          4      2  0  60 -20 -     0 worker     0   0 08:55 ?        00:00:00 [kworker/0:0H]1 S root          5      2  0  80   0 -     0 worker     0   0 08:55 ?        00:00:00 [kworker/u256:0]注：PRI：优先级、NI：nice值、PSR：运行在哪个cpu上、PPID：父进程ID[demo@localhost ~]$ ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 08:55 ?        00:00:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root          2      0  0 08:55 ?        00:00:00 [kthreadd][demo@localhost ~]$ ps -eFUID         PID   PPID  C    SZ   RSS PSR STIME TTY          TIME CMDroot          1      0  0 48542  5056   0 08:55 ?        00:00:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root          2      0  0     0     0   0 08:55 ?        00:00:00 [kthreadd]注：init或systemd: 进程号为1，是操作系统启动后的第一个进程，也是所有进程的父进程。</code></pre><p>pstree: 显示当前系统上的进程</p><p>pgrep：匹配进程名对应的pid</p><pre><code>[demo@localhost ~]$ pgrep systemd1506544115220169</code></pre><p>pidof: 根据程序名称，查找其相关进程的ID号</p><pre><code>[demo@localhost ~]$ pidof systemd1</code></pre><p>top：展示Linux进程信息</p><pre><code> -d: 指定延迟时长，单位是秒-b: 批模式-n #：在批模式下，共显示多少批top命令：https://www.cnblogs.com/niuben/p/12017242.html    常用命令：    M: 根据驻留内存大小进行排序    P：根据CPU使用百分比进行排序    T: 根据累计时间进行排序        l: 是否显示平均负载和启动时间    t: 是否显示进程和CPU状态相关信息    m: 是否显示内存相关信息        c: 是否显示完整的命令行信息    q: 退出top    k: 终止某个进程</code></pre><p>vmstat:系统状态查看命令</p><pre><code>vmstat n m：该命令是每n秒统计一次系统资源，共统计m次</code></pre><p><a href="https://www.linuxprobe.com/linux-vmstat-explain.html">https://www.linuxprobe.com/linux-vmstat-explain.html</a></p><h2 id="Linux进程间通信"><a href="#Linux进程间通信" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h2><p>通信方式：</p><ul><li>共享内存</li><li>信号: Signal</li><li>Semaphore</li></ul><p>kill命令：向进程发送信号  </p><p>重要的信号：</p><ul><li>1：SIGHUP: 让一个进程不用重启，就可以重读其配置文件，并让新的配置信息生效；</li><li>2: SIGINT：Ctrl+c: 中断一个进程</li><li>9: SIGKILL：杀死一个进程</li><li>15: SIGTERM：终止一个进程, 默认信号.中断进程时首先用-15，以便于其能够预先清理临时文件和释放资源。-9作为最后手段，应对哪些失控的进程</li></ul><p>kill使用：</p><pre><code>使用信号号码：kill -1 pid使用信号名称：kill -SIGKILL pid使用信号名称简写：kill -KILL pid</code></pre><p>killall COMMAND：杀死指定名字的所有进程</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>调整nice值：</p><pre><code>调整已经启动的进程的nice值：renice NI PID在启动时指定nice值：nice -n NI COMMAND</code></pre><p>前台作业：占据了命令提示符<br>后台作业：启动之后，释放命令提示符，后续的操作在后台完成  </p><p>前台–&gt;后台：</p><pre><code>Ctrl+z: 把正在前台的作业送往后台（调往后台的进程会中断并停止运行）COMMAND &amp;：让命令在后台执行（调往后台的进程会继续执行）</code></pre><p>jobs: 查看后台的所有作业</p><pre><code>作业号，不同于进程号    +：命令将默认操作的作业    -：命令将第二个默认操作的作业[demo@localhost ~]$ jobs[1]+  Stopped                 tar -zcvf etc.tar.gz /etc/*</code></pre><p>bg: 让后台的停止作业继续运行（我在CentOS7中使用该命令和感觉有问题）  </p><pre><code>bg [[%]JOBID]</code></pre><p>fg: 将后台的作业调回前台</p><pre><code>fg [[%]JOBID]</code></pre><p>kill %JOBID: 终止某作业</p><p>&#x2F;proc目录下的每个数字文件夹都代表着相应的进程<br>&#x2F;proc&#x2F;meminfo文件中是内存的相应信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程基础&quot;&gt;&lt;a href=&quot;#进程基础&quot; class=&quot;headerlink&quot; title=&quot;进程基础&quot;&gt;&lt;/a&gt;进程基础&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;进程也被叫做运行中的程序。当我们安装完软件之后，只是将软件文件保存在了硬盘中。我们运行软件，则会生</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="http://example.com/2022/11/27/combute-basic/"/>
    <id>http://example.com/2022/11/27/combute-basic/</id>
    <published>2022-11-27T13:25:06.024Z</published>
    <updated>2022-11-27T13:25:06.024Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。</p></div><h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p>一台计算机由硬件、操作系统、程序组成。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9a0b832f9f9e5a95d12a836ab6d53630?method=download&shareKey=c00765b3eaaae0cc10aa16760a4ea955" alt="image"></p><p>硬件是计算机的基础，计算机的硬件组成可以分为运算器、控制器、存储器、输入&#x2F;输出设备。其中运算器和控制器是构成CPU的主要部分。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB760447eef5a97f121df438b75fc68075?method=download&shareKey=52b7a07d9bf375629854264a447c7701" alt="image"> </p><p>各元件之间的逻辑连接关系如下图所示。各元件之间通过地址线、数据线和控制信号线组成的本地总线链接。目前采用总线复用技术让地址、数据和控制信号使用同一条线路。早期的32位CPU中，其地址线和数据线分别都是32位，因此地址寻址空间范围为2的32次方字节，即从0到4G。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe1436f00078189da4932a78923a7936d?method=download&shareKey=e149a2a88f09bcd5958ce514327a5d64" alt="image"></p><p>早期系统通过两个芯片组进行各元件的连接，分别是： </p><ul><li>北桥：负责链接CPU、内存、显卡等高速设备  </li><li>南桥：负责链接硬盘、网卡、USB等低速设备</li></ul><p>目前北桥已经被整合到了CPU里面，下图为PRO-SW-W480-ACE主板说明图</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB09bda74bccf0f8982f80819324ce11e4?method=download&shareKey=300ea9f175b5eced9beef2872360c0d4" alt="image"></p><h2 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU由数十亿个微型晶体管构成。它的工作可以分为三个关键阶段：CPU从系统的主存中提取指令、然后解码该指令的实际内容、然后再由CPU的相关部分执行该指令。CPU内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连接。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5eeafe804430692ad0e9eead5a1a983?method=download&shareKey=687699edd636019aa7f7d2be4f2605db" alt="image">  </p><ul><li><strong>时    钟</strong>：负责发出CPU开始计时的时钟信号。</li><li><strong>运算器</strong>：负责运算从内存中读入寄存器的数据。 </li><li><strong>寄存器</strong>：可以看作内存的一种，用来暂存指令、数据和地址。  </li><li><strong>控制器</strong>：负责把内存上的指令，数据读入寄存器，并根据指令的结果控制计算机。</li></ul><p>根据功能的不同，可以将寄存器划分为下面这几类。 </p><table><thead><tr><th align="center">种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">累加寄存器</td><td align="center">存储运行的数据和运算后的数据</td></tr><tr><td align="center">标志寄存器</td><td align="center">用于反映处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td align="center">程序计数器</td><td align="center">用于存放下一条指令所在单元的地址的地方</td></tr><tr><td align="center">基址寄存器</td><td align="center">存储数据内存的起始位置</td></tr><tr><td align="center">变址寄存器</td><td align="center">存储基址寄存器的相对位置</td></tr><tr><td align="center">通用寄存器</td><td align="center">存储任意数据</td></tr><tr><td align="center">指令寄存器</td><td align="center">储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td align="center">栈寄存器</td><td align="center">存储栈区域的起始位置</td></tr></tbody></table><p>其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其它寄存器一般有多个。在内存中的存储通过地址编号来表示，而寄存器的种类则通过名字来区分。</p><p>至于CPU的指令集，那就是Intel的架构师们的工作。总之，CPU认识这些指令，并且能执行运算。这些指令我们称之为机器代码。机器代码由二进制的01字符串构成不利于人们阅读，因此人们在机器代码的基础上开发了一套汇编代码。汇编代码只有转换为本地代码才能运行。  </p><p>CPU 采用了一系列的措施加快指令的执行过程：</p><blockquote><p>流水线：有电子厂打工经历的读者肯定很熟悉这个流水线模式。CPU的流水线工作方式和工业生产上的流水线概念一样。就是将一个指令的执行过程也分解为多个步骤，CPU中的每个电路只执行其中一个步骤，这样前赴后继加快执行速度。CPU中多个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成几个步骤后再由这些电路单元分别执行。在执行过程中，指令源源不断的送往CPU。让每个电路单元都不闲着，这样就大大的加快了执行速度。  </p></blockquote><blockquote><p>超线程：CPU在进行线程切换的时候，要执行 切换各种寄存器状态等一些操作。把第一个线程的各种寄存器状态写回缓存中保存，然后把第二个线程的相关内容送到各种寄存器上。该过程必不可少，否则待会再将第一个线程切换回来时，不知道该线程的各个状态， 那还怎么接着继续执行呢？也正因为如此，所以这个过程比较慢，大概需要几万个时钟周期。所以后来做了这样的设计，把每个寄存器等都多做一个，就是多做一组寄存器(也包括一些其他相关电路等),CPU在执行A线程时，使用的第一组寄存器，切换到B线程，直接使用第二组寄存器，然后再切换A线程时，再使用第一组寄存器。，CPU就不用再傻傻的等着寄存器值的切换，线程切换只需要几个时钟周期就够了。对于普通的执行多任务的计算机，CPU线程切换是个非常频繁的操作，所以使用该技术就会节省大量的时钟周期。也就是相当于加快了CPU的执行速度。这就是CPU宣传参数中所谓的四核八线程的由来，其实就是超线程技术。(每个核多做一组寄存器等电路固然会占用宝贵的空间，但是它带来的优点远远大于缺点)。 </p></blockquote><blockquote><p>超标量技术: CPU可以在每个时钟周期内执行多个操作,可以实行指令的并行运算。在下面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出来并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。  </p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEBca6d3f2ca384de5d257b260ead71d115?method=download&shareKey=a7e4eea3d1346b04d1eada1e71e3b1bf" alt="image">  </p><blockquote><p>乱序执行: 我们认为程序都是顺序执行的。但是在CPU层面上，指令的执行顺序并不一定与它们在机器级程序(汇编)中的顺序一样。比如 a &#x3D; b+c; d++;这两个语句 不按照顺序执行也不会影响最终结果。当然这只是在CPU执行指令的层面，在程序员们看来，依旧认为程序是顺序执行的。</p></blockquote><blockquote><p>多核芯片：在芯片上有效地承载了四个微型芯片，每个微型芯片都有自己独立的CPU。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0b07646c4ecb73a0add4e1b5a2a9dfff?method=download&shareKey=7f5a08db7f8b74d0587553a87fafcb62" alt="image">  </p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是一种随机存储器（RAM），表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3eba4f99e53218fdec72fec4e08d9090?method=download&shareKey=f3f97c1a5885c0788caa1c94c0379427" alt="image">  </p><p>内存是编址的，编址的单位是字节（不是比特）。为了便于理解，我们把内存模型映射成为我们现实世界的模型。在现实世界中，内存的模型很像我们生活中的楼房。在这个楼房中，1层可以存储一个字节的数据，楼层号就是地址。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8993750ef7e3c66bac2868347fa8c680?method=download&shareKey=818ed6e9b52b16bec7a2247ba9780d24" alt="image">  </p><p>内存的内部是由各种IC电路（集成电路）组成的。内存IC是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的IC引脚来进行数据的读写。下面是一个虚拟的IC引脚示意图。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e9c34cbbec8776b666c35b72bb3b0bc?method=download&shareKey=c943f31ea062208c46c05dd12b6979de" alt="image">  </p><p>图中VCC和GND表示电源，A0-A9是地址信号的引脚，D0-D7表示的是数据信号、RD和WR都是控制信号。将电源链接到VCC和GND后，就可以对其它引脚传递0和1的信号，大多数情况下，+5V表示1,0V表示0。</p><p>我们都知道内存是用来存储数据，那么这个内存IC中能存储多少数据呢？D0-D7表示的是数据信号，也就是说，一次可以输入输出8bit &#x3D; 1byte的数据。A0~A9是地址信号共十个，表示可以指定00000 00000 - 11111 11111共2的10次方&#x3D;1024个地址。每个地址都会存放1byte的数据，因此我们可以得出内存IC的容量就是1KB。 </p><p>如果我们使用的是512MB的内存，这就相当于是512000（512*1000）个内存IC。当然，一台计算机不太可能有这么多个内存IC，然而，通常情况下，一个内存IC会有更多的引脚，也就能存储更多的数据。</p><p>内存IC读写过程如下：  </p><ul><li>写入数据：首先给VCC接通+5V的电源，给GND接通0V的电源，使用A0-A9来指定数据的存储场所，然后再把数据的值输入给D0-D7的数据信号，并把WR（write）的值置为1，执行完这些操作后，即可以向内存IC写入数据。</li><li>读入数据：只需要通过A0-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB81497d419eab65105d73ab9cd72f29b2?method=download&shareKey=86c4562d73c7ae4724b901546c120882" alt="image">  </p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘和内存都具有存储功能，它们都是存储设备。内存是一种高速、造价昂贵的存储设备，通过电流来实现存储。而磁盘则是速度较慢、造价低廉的存储设备，通过磁记录技术实现存储。磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，他们以5400rpm、7200rpm、10800rpm或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片33转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂的位置上的所有磁道合并起来，组成了一个柱面。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1ce7db34d73ec40ecb6ea85135bc6f18?method=download&shareKey=24f1372be02346ec060fc1de5f77a9e5" alt="image">  </p><blockquote><p>注意：固态硬盘不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中。与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p></blockquote><h3 id="输入-x2F-输出设备和设备驱动程序"><a href="#输入-x2F-输出设备和设备驱动程序" class="headerlink" title="输入&#x2F;输出设备和设备驱动程序"></a>输入&#x2F;输出设备和设备驱动程序</h3><p>I&#x2F;O设备一般包括两个部分：设备控制器和设备本身。任何一个硬件设备内部的电路可能跟CPU内部的电路都不一致。因此控制器负责将外部设备的信号转换成CPU总线上能理解的信号以及控制外部设备的传输速率、校验等功能。即I&#x2F;O控制器能够接受操作系统的指令，控制设备。I&#x2F;O控制器中也有用于临时保存输入输出数据的内存，这个内存我们称之为I&#x2F;O内存。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb7382c303e9917c95e83b6edbe2cdd4d?method=download&shareKey=dc3a6ac1c609075617bffd1cc30123a6" alt="image">  </p><h2 id="计算机概念"><a href="#计算机概念" class="headerlink" title="计算机概念"></a>计算机概念</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>计算机的运行离不开程序，程序由指令和数据两部分组成。计算机运行过程中CPU所使用的指令和数据都是来自于主内存。不论是软件程序还是数据，都必须要读入主内存后CPU才能利用。由于CPU的计算速度远大于从内存操作数据的速度，直观表现就是程序的性能在极大程度上受到内存访问次数的影响，内存访问次数越多，性能越差，所以才引入缓存从而减少cpu访问内存的次数。CPU中的缓存分为三层。一二级缓存私有，三级缓存共享。一级缓存分为数据缓存和指令缓存。缓存之所以可以减少CPU访问内存的次数是由于程序的局部性原理：</p><ul><li><p>时间局部性：被引用过一次的存储器位置中的内容在未来会被多次引用  </p></li><li><p>空间局部性：如果一个存储器位置的内容被引用，那么它附近的位置也很大概率被引用。</p></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbe7ae989c55df12e9e5c9016b7414bd6?method=download&shareKey=c3a7b4196623b3fed8259fab738a9928" alt="image"></p><h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>计算机接了这么多的外部设备，CPU如何区分不同的I&#x2F;O设备呢？类比计算机区分和互联网通信的各个进程的方法，计算机区分不同的和外部通信的进程靠的是套接字，也就是ip地址+端口号。这里cpu区分不同I&#x2F;O设备靠的也是端口号，称为I&#x2F;O端口，在一台计算机上I&#x2F;O端口的数目也是65535个。任何一个硬件设备通过IO总线接入计算机的时，它必须一开机就申请注册一批连续的I&#x2F;O端口。</p><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>为了更充分的使用CPU的运算能力，计算机引入了多任务的概念。多任务的实现依赖于CPU的时间切片以及虚拟内存地址两项技术。CPU的时间切片可以理解为一项任务运行5ms之后切换其它任务执行，即通过时间片轮转的方法使不同的程序并发执行。虚拟内存地址：由进程的虚地址构成的地址空间。我的理解是CPU中每一个进程的内存地址都是0-某个值（比如1024），根据不同的进程映射到不同的内存地址中。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>当计算机上运行多个任务，这时从键盘上输入数据或者移动鼠标时计算机是如何快速响应的？这就依赖于中断机制。程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断;</p><p>I&#x2F;O设备和CPU之间的信息交流通过中断机制来实现。中断是用来暂停当前正在运行的程序，然后跳转到其他程序运行的必要机制。  </p><p>每个设备发送信号通知CPU来查看，CPU怎么得知是哪个设备的信号呢？可能你会想到通过I&#x2F;O端口来识别，但I&#x2F;O端口是实现数据交互而不是识别信号交互的。中断控制器就登场了。</p><p>中断控制器（Interrupt Controller）：CPU外置芯片，接收中断信号。当某个外部设备（例如网卡卡）传来信号，CPU中断当前操作，将此信号接收至内存中。中断控制器上连接着中断线，每根线代表一个设备（不是固定的设备），用来区分外部设备，线路是可以复用的。</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>直接存储器访问（DMA）: 它可以控制内存和某些控制器之间的数据传输，而无需CPU的干预。比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B不经过CPU的处理。由CPU在内存中划好某次传输数据所需空间，并授权某根线路给DMA使用。否则，CPU 需要从来源把每一片段的数据复制到暂存器，之后把它们再次写回到新的进程空间。在这个时间中，CPU 对于其他的工作来说就无法使用。</p><p>DMA依赖于CPU外置的DMA控制器芯片。在实现DMA传输时，是由DMA控制器直接掌管总线。因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器。而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程必须经过DMA请求、DMA响应、DMA传输、DMA结束4个步骤。</p><p>在物理内存当中，最低地址段中的空间就预留给了DMA。一般大小为16M。在DMA最前面还有1M使用的空间是留给BIOS。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB672d57b20ba18a9f89a4467c41770579?method=download&shareKey=8b548b2cebd4abe92784a69245f7a0ad" alt="image">  </p><h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><p>现在CPU都是多核的，而在服务器领域使用多颗CPU是正常的。在SMP（对称多处理器：一块主板上有多个CPU插槽）多CPU架构中，每个插槽称为一个socket。当多个CPU访问同一个内存，传统上多CPU对于内存的访问是总线方式。总线方式就会存在资源争用和临界区问题，而且如果不断的增加CPU数量，内存的争用会愈演愈烈。这就体现在4核CPU的跑分性能达不到2核CPU的2倍，甚至1.5倍都没有。理论上来说这种方式实现12core以上的CPU已经没有太大的意义。</p><p>为了防止多颗CPU访问内存出现资源争用，可以为每个CPU分配一个专用内存并且配有专用控制器。由于内存属于系统级别，内核加载时有可能把数据加载到不同CPU的专用内存上。同时每个CPU都有自己的进程队列，这些队列会不断被内核进行平衡（rebalancing），确保资源平均利用。这样就有可能会导致1号CPU需要到2号CPU的专用内存上读写数据，这种现象称为非一致性内存访问（NUMA）。如下图，CPU 0-3访问自己的内存需要1、2、3步骤（3个时钟周期），而访问CPU 4-7的内存需要1、1a、2、3步骤，其中1a就需要消耗3个时钟周期。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe521c3b43a42aca7e0cc418a043987de?method=download&shareKey=9162438460f30dcd3d07f9640f50dd5c" alt="image"></p><p>在企业中，NUMA问题是很常见的。为了避免内存间交叉访问导致性能下降，可以禁止内核进行平衡。对于比较繁忙的、需要经常执行的批处理服务进程可以采取CPU绑定策略。</p><p>Intel的NUMA解决方案：放弃总线的访问方式，将CPU划分到多个Node中。每个node有自己独立的内存空间。各个node之间通过高速互联通讯，通讯通道被称为QuickPath Interconnect即QPI。</p><h3 id="多信道设计"><a href="#多信道设计" class="headerlink" title="多信道设计"></a>多信道设计</h3><p>由于所有的数据都必须要存放在主内存，所以主内存的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达64比特。为了加大这个宽度，芯片组厂商就将两个主内存汇整在一起。如果一支内存可达64比特，两支内存就可以达到128比特了。这就是双信道的设计理念。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>操作系统是硬件层上的一层软件，它提供系统调用并屏蔽了硬件层面上的差异。操作系统负责整个计算机的内存管理、硬件管理、文件管理以及应用管理。</p><p>有时我们将操作系统也称为虚拟机。因为我们只有一块cpu芯片(可能是多核心的)，只有一块内存，只有一个鼠标，只有一个键盘……。每个进程都想独占这一整套资源。cpu可以通过时间片轮转的方式将一个cpu芯片虚拟成多个cpu运行。内存的虚拟通过分页机制和虚拟地址空间。现在已经把计算机系统中最重要的两个部件CPU和内存虚拟出来了。剩下的那些I&#x2F;O设备如何虚拟呢？其实IO虚拟不需要专门去做，因为当前哪个进程获得了系统使用权，I&#x2F;O设备就交给该进程。</p><h3 id="CPU指令模式"><a href="#CPU指令模式" class="headerlink" title="CPU指令模式"></a>CPU指令模式</h3><p>有了操作系统之后。在某一时刻，要么是内核进程（操作系统核心）在上面运行，要么是用户空间进程在上面运行。内核在cpu上运行时称为内核模式，进程在cpu上运行时称为用户模式。在内存中内核占据的那段内存空间称为内核空间，用户进程占据的空间叫用户空间。用户模式时，进程是不能直接控制硬件的。这是因为在cpu内部，cpu制造商将cpu能运行的指令划分为４层(仅对x86架构而言)，ring0，ring1，ring2，ring3。由于历史原因，ring1和ring2并没有使用，linux只用了ring0和ring3。ring0称为内核模式，也称为特权指令模式，可以直接操控硬件。ring3是用户模式，可以执行一般指令。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>内存是易失性存储，即断电之后所有数据都会被清空。CPU运行所需的指令和数据都要从内存中获取。那么计算机是如何启动的呢？</p><p>在计算机主板上有一个ROM芯片（非易失性存储），该芯片存储了BIOS程序。在按下电源键之后系统会自动将BIOS程序加载到内存中然后执行。BIOS程序主要负责确定硬件是否正常，没有异常的话会根据配置文件（存储在CMOS）中的设备启动顺序查找MBR（主引导记录）。</p><p>MBR会查找活动分区，加载活动分区中的内核代码。然后将控制权转移给内核。接下来就进入操作系统的启动流程。</p><p>目前最新的是UEFI+GPT方式。UEFI可以认为是BIOS的升级版。GPT是MBR的升级版，2T以上的硬盘需要使用gpt。</p><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>设备驱动程序是I&#x2F;O系统的高层与设备控制器之间的通信程序，工作在内核模式。其主要任务：</p><ul><li>再把它转化为具体要求，发送给设备控制器，启动设备去执行。</li><li>反方向，它也将由设备控制器发来的信号，传送给上层软件。</li><li>接收上层软件发来的抽象I&#x2F;O要求（Linux中一切皆文件），如read、write等命令；</li></ul><h3 id="固件和驱动"><a href="#固件和驱动" class="headerlink" title="固件和驱动"></a>固件和驱动</h3><p>固件是直接写入ROM中的程序，比如BIOS。它直接和硬件打交道，指导硬件怎么干活。驱动负责操作系统和设备控制器之间的通信，告诉硬件要干什么。驱动一般运行在操作系统上，由操作系统进行管理。而固件往往直接”固定”在硬件上，直接控制硬件；</p><ul><li><p>eg1：利用打印机打印东西时：</p><ul><li>驱动的作用就是告诉打印机，要打印什么。</li><li>固件则告诉打印机，要怎么执行操作(把纸弄上打印区，然后喷墨，从哪里出纸等)。</li></ul></li><li><p>eg2. BIOS即为主板上的固件，功能 ：上电 - 进入BIOS - 自检(检查设备是否正常等) - 初始化各个模块(内存以及加载其他必要的固件等) - 转移控制到系统启动程序。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>本文简单介绍了计算机组成、硬件组成（CPU、内存、硬盘、IO设备）、连接方式、计算机基础概念（IO端口、中断、DMA、SMP、多通道）、计算机如何启动、驱动和固件等相关内容。在写作本文的过程中发现我脑子里有东西，但是什么都写不出来。上次面试时面试官问我计算机的组成？我只答出CPU、内存、硬盘、IO设备，CPU从内存中获取指令和数据。好尴尬！！！！真的只能说是一听就会，一说就废。</p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 简单介绍一下计算机的组成、计算机硬件的连接方式、多任务、计算机如何区分IO设备、CPU如何和IO设备之间交互、DMA机制、SMP架构、多通道、驱动的概念？</p><p>3. 计算机如何启动?</p><p>4. 驱动和固件的区别？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. B站马哥Linux运维课程中的操作系统基础  </p> <p>2. 内存--通俗理解：<https://blog.csdn.net/youhuakongzhi/article/details/109039652>  </p> <p>3. 程序员必知的硬核知识大全  </p> <p>4. 认识操作系统</p> <p>5. 图解操作系统</p> <p>6. Linux内核完全注释</p> <p>5. 固件和驱动区别 [https://blog.csdn.net/qq_36779888/article/details/108681805](https://blog.csdn.net/qq_36779888/article/details/108681805)</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;计算机组成&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="硬件" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络基础</title>
    <link href="http://example.com/2022/11/27/Linux-network/"/>
    <id>http://example.com/2022/11/27/Linux-network/</id>
    <published>2022-11-27T13:24:30.781Z</published>
    <updated>2022-11-27T13:24:30.781Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>网络功能是计算机之间通信的基础，也是一个操作系统的重要组成部分。本文主要介绍Linux网络相关配置。</P>  </div><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>计算机网络实现了计算机之间的通信，我们可以通过两个层面来了解计算机网络。第一层面是物理层面，即计算机之间的连接线和设备；第二层面是计算机通信所采用的协议。我们首先了解一下计算机网络的物理层面。为了实现计算机之间的通信，我们首先通过线缆将各个计算机连接起来。为了在网络中识别各个计算机，我们给每个计算机分配一个MAC地址（位于网卡上）用于标识该计算机。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9f8be84ece7c84b15d27b8403b926f7?method=download&shareKey=cc97eec71b385792e190e815117b6031" alt="image"></p><p>由于一根线上在某一时刻只能传输某一个计算机的信息，否则会造成信号相互冲突。为了避免以上情况，引入了载波监听多路访问&#x2F;冲突检测机制。该机制是当计算机发送信息前，先监听线路中是否正在发送信息，如果没有则发送，否则等待。同时，在计算机发送信号之后，仍需继续侦听信道，当检测到冲突后马上迅速取消信息的传输并等待。</p><p>随着一根线上接入的计算机越来越多，发送信息时计算机冲突等待的时间也就越来越长。为此，我们可以将一个网络分成多个网络，网络之间使用网桥连接。网桥是一个智能设备，内部维护了一张MAC地址表。当A向D发送信息时，网桥左面的接口接收到信息查看MAC表显示D在来源接口所在的网络，网桥则会忽略该信息。网桥内部的MAC表可以人为指定，也可以自己学习。自己学习是根据接受信息的来源地址进行学习，如果在MAC表中查找目标地址不存在则会向网桥所有端口转发。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1bd50147127bd04dc2814f97780144be?method=download&shareKey=3bf691f9fc190026d0cc77e3f52d6926" alt="image"></p><p>随着不断发展，交换机取代了网桥。目前，我们将计算机直接连接到交换机的端口上，交换机内部也有一个MAC地址表。而且目前的网线一般都是全双工的（即内部包含两条线，一条发送信息，一条接受信息）。在计算机进行通信时，计算机一般会发送广播询问目标的地址。但是交换机并不能隔离广播，路由器的作用便是隔离广播。路由器的存在虽然隔离了广播，但是也造成我们无法确定目标主机是否存在。为了解决该问题，我们引入了IPV4地址。在通信时，计算机根据IPV4地址判断目标主机是否和自己在同一网段，如果在同一网段则可以通过交换机直接通信。如果不在同一网段，计算机则将信息发送给路由器，路由器根据路由配置进行转发。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.51wendang.com%2Fpic%2Fc1074616c12f52cc16eef53f%2F5-492-png_6_0_0_162_448_622_372_892.979_1262.879-823-0-0-823.jpg&refer=http%3A%2F%2Fwww.51wendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643791840&t=5377c338817383119402d7b2035b5756" alt="image"></p><p>以上的物理层面保证了计算机可以相互之间发送和接受信息，而协议层面则规定了计算机发送信息的格式。目前的协议层面我们常用的是TCP&#x2F;IP协议。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf00acbc1e730228b2a39f1a697f02ef3?method=download&shareKey=754667e281d8fa53a84cb867ca131c95" alt="image"></p><p>在这些层中，IP层是实现点到点的通信。而传输层是实现进程到进程的通信。</p><p>具体网络协议基础可以查看：<a href="https://www.cnblogs.com/imyalost/p/6086808.html">https://www.cnblogs.com/imyalost/p/6086808.html</a></p><h2 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h2><p>   ethX：代表的是以太网。IP地址虽然配置在网卡上，但是IP地址是属于内核的，即数据可以通过一个网卡采用其它网卡的IP访问计算机。</p><p>   网卡名称定义地址：</p><pre><code>RHEL5: /etc/modprobe.conf          alias RHEL6: /etc/udev/rules.d/70-persistent-net.rules（配置网卡名称和MAC地址）[root@Worker11 ~]# cat /etc/udev/rules.d/70-persistent-net.rules # This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.        # PCI device 0x8086:0x100f (e1000)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:8f:62:94&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot; </code></pre><h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><pre><code>ifconfig [ethX]     -a: 显示所有接口的配置信息    [root@Worker11 ~]# ifconfig    eth0      Link encap:Ethernet  HWaddr 00:0C:29:8F:62:94（物理地址）                inet addr:192.168.25.11（IP地址）  Bcast:192.168.25.255（广播地址）  Mask:255.255.255.0（子网掩码）              inet6 addr: fe80::20c:29ff:fe8f:6294/64 Scope:Link              UP（启用） BROADCAST（广播地址有效） RUNNING（动作） MULTICAST（多播地址有效）  MTU:1500  Metric:1              RX packets:464 errors:0 dropped:0 overruns:0 frame:0（接受数据）              TX packets:106 errors:0 dropped:0 overruns:0 carrier:0（发送数据）              collisions:0 txqueuelen:1000               RX bytes:36689 (35.8 KiB)  TX bytes:13139 (12.8 KiB)        lo        Link encap:Local Loopback                inet addr:127.0.0.1  Mask:255.0.0.0              inet6 addr: ::1/128 Scope:Host              UP LOOPBACK RUNNING  MTU:65536  Metric:1              RX packets:0 errors:0 dropped:0 overruns:0 frame:0              TX packets:0 errors:0 dropped:0 overruns:0 carrier:0              collisions:0 txqueuelen:0               RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)ifconfig ethX IP/MASK [up|down]     配置的地址立即生效，但重启网络服务或主机，都会失效；    ifconfig eth0 192.168.20.12/24 修改网卡地址，即时生效    ifconfig eth0 down：关闭eth0网卡    ifconfig eth0 up：开启eth0网卡    </code></pre><h3 id="重启网络服务："><a href="#重启网络服务：" class="headerlink" title="重启网络服务："></a>重启网络服务：</h3><p>RHEL5:&#x2F;etc&#x2F;init.d&#x2F;network {start|stop|restart|status}</p><p>RHEL6:  &#x2F;etc&#x2F;init.d&#x2F;NetworkManager {start|stop|restart|status}<br>        service network {start|stop|restart|status}（我一般使用这个）</p><p>RHEL7:  systemctl {start|stop|restart|status} network</p><h3 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h3><p>查看：  </p><pre><code>route -n: 以数字方式显示各主机或端口等相关信息，否则可能会显示对应IP的主机名[demo@localhost rules.d]$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0</code></pre><p>网关：   </p><pre><code>route     add: 添加        -host: 主机路由        -net：网络路由        -net 0.0.0.0    route add -net|-host DEST gw NEXTHOP    route add default gw NEXTHOP    route add -net 10.0.1.0/24 gw 192.168.100.6    [root@localhost ~]# route add -net 192.168.20.0/24 gw 192.168.122.254    del：删除        -host        -net                 route del -net 10.0.0.0/8         route del -net 0.0.0.0        route del default所做出的改动重启网络服务或主机后失效；</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>网络接口配置文件：  </p><p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-INTERFACE_NAME</p><pre><code>DEVICE=: 关联的设备名称，要与文件名的后半部“INTERFACE_NAME”保持一致; BOOTPROTO=&#123;static|none|dhcp|bootp&#125;: 引导协议；要使用静态地址，使用static或none；dhcp表示使用DHCP服务器获取地址；IPADDR=: IP地址NETMASK=：子网掩码GATEWAY=：设定默认网关；ONBOOT=：开机时是否自动激活此网络接口；HWADDR=： 硬件地址，要与硬件中的地址保持一致；可省；USERCTL=&#123;yes|no&#125;: 是否允许普通用户控制此接口；PEERDNS=&#123;yes|no&#125;: 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址；不会立即生效，但重启网络服务或主机都会生效；</code></pre><p>路由：</p><p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;route-ethX</p><pre><code>添加格式一：DESTvia NEXTHOP192.168.20.0/24 via 192.168.20.254添加格式二：ADDRESS0=NETMASK0=GATEWAY0=</code></pre><p>DNS服务器指定方法只有一种：</p><pre><code>/etc/resolv.confnameserver DNS_IP_1nameserver DNS_IP_2</code></pre><p>指定本地解析：</p><pre><code>/etc/hosts主机IP            主机名      主机别名172.16.0.1www.magedu.comwwwDNS--&gt;/etc/hosts--&gt;DNS</code></pre><p>配置主机名：</p><pre><code>hostname HOSTNAME # 立即生效，但不是永久有效；hostnamectl set-hostname hostname # CentOS 7，同时会修改/etc/hosts# 配置文件（CentOS 6修改，CentOS7及其以上方式已被弃用）/etc/sysconfig/networkHOSTNAME=# 配置文件（CentOS 7修改）/etc/hosts</code></pre><p>RHEL5：（图形化界面设置）</p><pre><code>setup: system-config-network-tuisystem-config-network-gui</code></pre><h3 id="IP管理新命令"><a href="#IP管理新命令" class="headerlink" title="IP管理新命令"></a>IP管理新命令</h3><p>iproute2</p><pre><code>ip    link: 网络接口属性    addr: 协议地址    route: 路由link    show        ip -s link show    set        ip link set DEV &#123;up|down&#125;        addr    add        ip addr add ADDRESS dev DEV    del        ip addr del ADDRESS dev DEV    show        ip addr show dev DEV to PREFIX（显示指定范围内的网卡信息）    flush        ip addr flush dev DEV to PREFIX（配置网卡地址删除）route:     ip route add to 10.0.1.0/24 dev eth1 via 192.168.100.6        add, change, show, flush, replace            显示网卡属性[root@localhost network-scripts]# ip -s link show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    RX: bytes  packets  errors  dropped overrun mcast       107024     1248     0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns     107024     1248     0       0       0       0       2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    RX: bytes  packets  errors  dropped overrun mcast       0          0        0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns     23168      144      0       0       0       0   关闭网卡[root@localhost network-scripts]# ip link set ens33 down查看网卡地址[root@localhost network-scripts]# ip -s addr show dev ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever    RX: bytes  packets  errors  dropped overrun mcast       0          0        0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns     49909      306      0       0       0       0       显示指定IP地址范围内的网卡信息[root@localhost network-scripts]# ip addr show dev ens33  to 10/8[root@localhost network-scripts]# ip addr show dev ens33  to 192.168.120.0/242: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever删除指定范围内的网卡地址[root@localhost network-scripts]# ip addr show dev ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever    inet 192.168.121.11/24 scope global ens33:1       valid_lft forever preferred_lft forever[root@localhost network-scripts]# ip addr flush dev ens33 to 192.168.121.11/24[root@localhost network-scripts]# ip addr show dev ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever添加路由[root@localhost network-scripts]# ip route add to 10.0.1.0/24 dev ens33 via 192.168.120.6[root@localhost network-scripts]# ip route show10.0.1.0/24 via 192.168.120.6 dev ens33 192.168.20.0/24 via 192.168.122.254 dev virbr0 192.168.120.0/24 dev ens33 proto kernel scope link src 192.168.120.12 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 </code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>一块网卡可以使用多个地址：<br>网络设备可以起别名：</p><p>eth0</p><pre><code>ethX:X, eth0:0, eth0:1, ...    </code></pre><p>配置方法：</p><pre><code>第一种方法：ifconfig ethX:X IP/NETMASKifconfig eth0:0 172.16.200.33/16第二种方法：ip    eth1, 添加个地址192.168.100.1    ip addr add 192.168.100.1/24 dev eth1 label eth1:0第三种方法,上面的方法主机重启会消失/etc/sysconfig/network-scripts/ifcfg-ethX:XDEVICE=ethX:X非主要地址不能使用DHCP动态获取; </code></pre><p>监听端口：  </p><p>netstat命令：</p><pre><code>-r: 显示路由表-n: 以数字方式显示-a：显示所有的网络连接和监听接口-t: 建立的tcp连接-u: 显示udp连接-l: 显示监听状态的连接-p: 显示监听指定的套接字的进程的进程号及进程名[root@localhost html]# netstat -anptlActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1175/cupsd          tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1382/master         tcp        0      0 127.0.0.1:44321         0.0.0.0:*               LISTEN      19272/pmcd          tcp        0      0 127.0.0.1:4330          0.0.0.0:*               LISTEN      34102/pmlogger  </code></pre><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 马哥Linux运维课程</p> </div>    ]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;网络功能是计算机之间通信的基础，也是一个操作系统的重要组成部分。本文主要介绍Linux网络相关配置。&lt;/P&gt;  
&lt;/div&gt;


&lt;h2 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="network" scheme="http://example.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Linux软件包管理</title>
    <link href="http://example.com/2022/11/27/Linux-software/"/>
    <id>http://example.com/2022/11/27/Linux-software/</id>
    <published>2022-11-27T13:23:18.034Z</published>
    <updated>2022-11-27T13:23:18.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序介绍"><a href="#程序介绍" class="headerlink" title="程序介绍"></a>程序介绍</h2><blockquote><p>我们将语言分为两种。一种是编译器语言，另一种是解释性语言。编译语言以C语言为例，需要将源代码–&gt;（编译）二进制格式才能在机器上运行。编译的过程大致如下：源代码–&gt;编译–&gt;链接–&gt;运行。其中链接分为两种：一种是静态链接，另一种是动态链接。静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。动态链接则是在第一次访问库时将库加载到内存中，之后所有的程序在需要时都可以直接访问该库。解释性语言是边读取边翻译的过程，脚本便是一种解释性语言。  </p></blockquote><p>程序：指令+数据</p><pre><code>指令：芯片    CPU: 普通指令，特权指令    指令集注：不同CPU的指令集是不相同的，所以在一些机器上编译的程序不能在另一些机器上直接使用。</code></pre><p>程序的组成：</p><ul><li>二进制程序</li><li>库</li><li>配置文件</li><li>帮助文件</li></ul><h2 id="程序介绍-1"><a href="#程序介绍-1" class="headerlink" title="程序介绍"></a>程序介绍</h2><p>linux文件夹介绍：</p><pre><code>/boot/etc/usr/var/dev/lib/tmp/bin/sbin/proc/sys/mnt/media/home/root/misc/opt/srv具体分析：/etc, /bin, /sbin, /lib    系统启动就需要用到的程序，这些目录不能挂载额外的分区，必须在根文件系统的分区上    /usr/    etc    bin    sbin    lib    操作系统核心功能，可以单独分区。该程序下的配置文件一般也在/etc下/usr/share/man：上面两种程序的帮助文档位置/usr/local    bin    sbin    lib    etc    man    第三方程序，可以单独分区/opt：一些比较老的第三方程序的默认存放路径，可以单独分区/proc/sys    伪文件系统，不能单独分区，默认为空；/dev: 设备，不能单独分区；   udev机制：/home:建议单独分区，防止操作系统重装等操作时用户数据丢失。/root: 不能单独分区/var：建议单独分区/boot：内核，initrd(initramfs)： 建议单独分区     内核：          操作系统加载顺序POST--&gt;BIOS(HD)--&gt;(MBR)bootloader(该模块应该能理解文件系统结构，ext2, ext3, xfs)--&gt;内核     bootloader根据活动分区直接去定位内核位置，然后加载内核。中间和根目录没有关系。操作系统启动后，然后寻找根，并将boot目录挂载到根下。     建议给boot单独分区，然后将根目录挂载到LVM分区下。因为LVM是操作系统功能，boot需要在操作系统启动前加载。这样可以在需要时，增大根目录下的空间。</code></pre><h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2><p> 软件包管理器的核心功能</p><ul><li>制作软件包；  </li><li>安装、卸载、升级、查询、校验；</li></ul><p>不同系统上的软件包管理器</p><ul><li>Redhat, SUSE: RPM (PRM is Package Manager)</li><li>Debian: dpt</li></ul><p>依赖关系:  </p><pre><code>依赖关系顾名思义就是A软件需要使用B软件的某些功能。比如X依赖于Y，Y依赖于Z。X--&gt;Y--&gt;Z</code></pre><p>工具分类：</p><ul><li>前端工具（自动处理依赖关系）：yum, apt-get</li><li>后端工具（手动处理依赖关系）：RPM, dpt</li></ul><h2 id="rpm基础"><a href="#rpm基础" class="headerlink" title="rpm基础"></a>rpm基础</h2><p>rpm的主要功能为安装、查询、卸载、升级、校验、数据库的重建、验正数据包等工作；</p><p>rpm包来源：</p><pre><code>二进制格式    rpm包作者下载源程序，编译配置完成后，制作成rpm包。因此rpm包安装后可以直接运行。    bind-9.7.1-1.noarch.rpm    bind-9.7.1-1.ppc.rpm</code></pre><p>rpm包命名格式：</p><pre><code>假设源码格式为：bind-9.7.1.tar.gz包：组成部分（为了防止包过大，可能会将包拆为主包和子包）    主包：        bind-9.7.1-1.el5.i586.rpm    子包：        bind-libs-9.7.1-1.el5.i586.rpm        bind-utils-9.7.1-1.el5.i586.rpm包名格式：    name-version-release.arch.rpm    bind-major.minor.release1-release2.arch.rpm主版本号：重大改进次版本号：某个子功能发生重大变化发行号1：修正了部分bug，调整了一点功能发行号2:rpm包的版本号，上面三个版本号和源码包保持一致。arch：硬件平台bind-9.7.1-1.el5.i586.rpm    9.7.1和源码包一致，分别是主版本号、次版本号、发行号1    1.el5是发行号2,其中1代表rpm的发行版本，el5代表的是redhat 5系统。如果不限制系统el5可以直接省略    i586是arch：该值代表了32位的硬件平台。noarch代表不限制硬件平台。</code></pre><p>查看主机的操作系统和硬件平台版本：</p><pre><code>[demo@localhost dev]$ uname -aLinux localhost.localdomain 3.10.0-1062.el7.x86_64 #1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><p>RadHat安装盘中含有很多rpm安装包，可以将安装盘挂载在文件系统中。然后获取rpm安装包。  </p><pre><code> /dev/cdrom：光盘设备命名  </code></pre><p>1、安装</p><pre><code>rpm -i /PATH/TO/PACKAGE_FILE    -h: 以#显示进度；每个#表示2%;     -v: 显示详细过程    -vv: 更详细的过程rpm -ivh /PATH/TO/PACKAGE_FILE    --nodeps: 忽略依赖关系；（可以安装，但安装上软件也不能使用）    --replacepkgs: 重新安装，替换原有安装；    --force: 强行安装，可以实现重装或降级；\\ 安装[root@localhost demo]# rpm -ivh zsh-5.0.2-33.el7.x86_64.rpm warning: zsh-5.0.2-33.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:zsh-5.0.2-33.el7                 ################################# [100%]\\ 存在依赖，安装失败[root@localhost demo]# rpm -ivh tomcat-7.0.76-9.el7_6.noarch.rpm warning: tomcat-7.0.76-9.el7_6.noarch.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEYerror: Failed dependencies:    apache-commons-collections is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-daemon is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-dbcp is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-logging is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-pool is needed by tomcat-0:7.0.76-9.el7_6.noarch    tomcat-lib = 0:7.0.76-9.el7_6 is needed by tomcat-0:7.0.76-9.el7_6.noarch</code></pre><p>2、查询（PACKAGE_NAME可以是安装包的前缀）</p><pre><code>rpm -q PACKAGE_NAME： 查询指定的包是否已经安装rpm -qa : 查询已经安装的所有包rpm -qi PACKAGE_NAME: 查询指定包的说明信息；rpm -ql PACKAGE_NAME: 查询指定包安装后生成的文件列表；rpm -qc PACEAGE_NEME：查询指定包安装的配置文件；rpm -qd PACKAGE_NAME: 查询指定包安装的帮助文件；rpm -q --scripts PACKAGE_NAME: 查询指定包中包含的脚本    rpm -qf /path/to/somefile: 查询指定的文件是由哪个rpm包安装生成的；    如果某rpm包尚未安装，我们需查询其说明信息、安装以后会生成的文件；rpm -qpi /PATH/TO/PACKAGE_FILErpm -qpl示例：[root@localhost demo]# rpm -q zshzsh-5.0.2-33.el7.x86_64注：rpm -q zsh* 这种查询的是当前目录下以zsh开头的文件或文件夹名称是否安装[root@localhost demo]# rpm -q tomcatpackage tomcat is not installed[root@localhost demo]# rpm -qi zsh-5.0.2-33.el7.x86_64Name        : zshVersion     : 5.0.2Release     : 33.el7Architecture: x86_64Install Date: Fri 07 Jan 2022 11:02:48 PM ESTGroup       : System Environment/ShellsSize        : 5856382License     : MITSignature   : RSA/SHA256, Thu 22 Aug 2019 05:45:54 PM EDT, Key ID 24c6a8a7f4a80eb5Source RPM  : zsh-5.0.2-33.el7.src.rpmBuild Date  : Thu 22 Aug 2019 01:13:36 PM EDTBuild Host  : x86-01.bsys.centos.orgRelocations : (not relocatable)Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor      : CentOSURL         : http://zsh.sourceforge.net/Summary     : Powerful interactive shellDescription :The zsh shell is a command interpreter usable as an interactive loginshell and as a shell script command processor.  Zsh resembles the kshshell (the Korn shell), but includes many enhancements.  Zsh supportscommand line editing, built-in spelling correction, programmablecommand completion, shell functions (with autoloading), a historymechanism, and more.[root@localhost demo]# rpm -ql zsh-5.0.2-33.el7.x86_64/bin/zsh/etc/skel/.zshrc/etc/zlogin/etc/zlogout/etc/zprofile/etc/zshenv/etc/zshrc/usr/lib64/zsh                   ....[root@localhost demo]# rpm -q --scripts zsh-5.0.2-33.el7.x86_64postinstall scriptlet (using /bin/sh):if [ ! -f /etc/shells ] ; then    echo &quot;/bin/zsh&quot; &gt; /etc/shellselse    grep -q &quot;^/bin/zsh$&quot; /etc/shells || echo &quot;/bin/zsh&quot; &gt;&gt; /etc/shellsfiif [ -f /usr/share/info/zsh.info.gz ]; then# This is needed so that --excludedocs works./sbin/install-info /usr/share/info/zsh.info.gz /usr/share/info/dir \  --entry=&quot;* zsh: (zsh).An enhanced bourne shell.&quot;fi:preuninstall scriptlet (using /bin/sh):if [ &quot;$1&quot; = 0 ] ; then    if [ -f /usr/share/info/zsh.info.gz ]; then    # This is needed so that --excludedocs works.    /sbin/install-info --delete /usr/share/info/zsh.info.gz /usr/share/info/dir \      --entry=&quot;* zsh: (zsh).An enhanced bourne shell.&quot;    fifi:postuninstall scriptlet (using /bin/sh):if [ &quot;$1&quot; = 0 ] ; then    if [ -f /etc/shells ] ; then        TmpFile=`/bin/mktemp /tmp/.zshrpmXXXXXX`        grep -v &#39;^/bin/zsh$&#39; /etc/shells &gt; $TmpFile        cp -f $TmpFile /etc/shells        rm -f $TmpFile    fifi[root@localhost bin]# rpm -qf zshzsh-5.0.2-33.el7.x86_64</code></pre><p>3、升级</p><pre><code>rpm -Uvh /PATH/TO/NEW_PACKAGE_FILE: 如果装有老版本的，则升级；否则，则安装；rpm -Fvh /PATH/TO/NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，退出；    --oldpackage: 降级</code></pre><p>4、卸载</p><pre><code>rpm -e PACKAGE_NAME    --nodeps :忽略依赖关系[root@localhost bin]# rpm -e zsh-5.0.2-33.el7.x86_64</code></pre><p>5、校验  </p><pre><code>rpm -V PACKAGE_NAME[root@localhost demo]# rpm -V zshS.5....T.  c /etc/zshrc注：该选项是校验rpm产生的所有文件是否和原始rpm包中文件的信息是否一致。其中S代表文件大小不一致，M代表对应文件的权限不一致，5代表对应文件的MD5不一致，D代表文件的major和minor号不一致，L代表文件的符号链接内容不一致，U代表文件的owner不一致，G表示文件的Group不一致，T表示文件的修改时间不一致，c只有文件是一个配置文件时才会有此标识。没有变化的文件不列出。</code></pre><p>6、重建数据库</p><pre><code>rpm数据库位置:/var/lib/rpmrpm     --rebuilddb: 重建数据库，一定会重新建立；    --initdb：初始化数据库，没有才建立，有就不用建立；该命令执行过程中要等待一段时间。</code></pre><p>7、检验来源合法性，及软件包完整性； (校验rpm包) </p><p>加密类型：</p><ul><li>对称：加密解密使用同一个密钥</li><li>公钥：一对儿密钥，公钥，私钥；公钥隐含于私钥中，可以提取出来，并公开出去；</li><li>单向：</li></ul><p>红帽的公钥：</p><pre><code># ls /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release注：由于我们目前是直接使用的红帽光盘安装rpm，故我们目前使用红帽的公钥。如果rpm是从其它来源获得，则需使用来源处获取的公钥。</code></pre><p>rpm –import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-redhat-release: 导入密钥文件</p><pre><code>[root@localhost rpm-gpg]# rpm --import RPM-GPG-KEY-CentOS-7</code></pre><p>rpm -K &#x2F;PAPT&#x2F;TO&#x2F;PACKAGE_FILE</p><pre><code>dsa, gpg: 验正来源合法性，也即验正签名；可以使用--nosignature，略过此项sha1, md5: 验正软件包完整性；可以使用--nodigest，略过此项[root@localhost rpm-gpg]# rpm -K /home/demo/zsh-5.0.2-33.el7.x86_64.rpm /home/demo/zsh-5.0.2-33.el7.x86_64.rpm: rsa sha1 (md5) pgp md5 OK</code></pre><blockquote><p>注：ldd &#x2F;PATH&#x2F;TO&#x2F;BINARY_FILE #查看二进制程序依赖的库文件<br>   ldconfig -p # 查看本机已经缓存的所有可用库文件名以及文件路径映射关系</p></blockquote><h2 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h2><p>1、yum仓库中的元数据文件</p><pre><code> primary.xml.gz - 所有RPM包的列表； - 依赖关系； - 每个RPM安装生成的文件列表；  filelists.xml.gz - 当前仓库中所有RPM包的所有文件列表； other.xml.gz - 额外信息，RPM包的修改日志；  repomd.xml - 记录的是上面三个文件的时间戳和校验和；（每次访问yum仓库都会下载该文件，然后和本地的前三个文件进行比较，如果不一致则重新下载上述三个文件。）  comps*.xml:  - RPM包分组信息；（该文件包含了rpm分组，每个分组中包含了必须安装的软件、推荐安装的软件、选择安装的软件）</code></pre><p>2、本机的yum源配置</p><p>配置文件地址：&#x2F;etc&#x2F;yum.repos.d</p><p>如何为yum定义repo文件</p><pre><code>[Repo_ID]（配置标签名）name=Description （名称）baseurl= （地址）    ftp://    http://    file:///enabled=&#123;1|0&#125; （该配置时候可用）gpgcheck=&#123;1|0&#125; （是否校验完整性和来源合法性）gpgkey= （） （来源的公钥）例：[base]name=CentOS-$releasever - Basemirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/         ftp://172.16.0.1/pub/&#123;Server,VT,Cluster,ClusterStorage&#125;gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</code></pre><p>3、yum命令</p><p>yum [options] [command] [package …]</p><pre><code>-y: 自动回答为yes--nogpgchecklist: 列表     支持glob：例 yum list all zsh*，后面可以跟包名和*号    all:所有的    available：可用的，仓库中有但尚未安装的    installed: 已经安装的    updates: 可用的升级[root@localhost media]# yum list available|head -10Loaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileAvailable Packages389-ds-base.x86_64                      1.3.9.1-10.el7                      demo389-ds-base-libs.x86_64                 1.3.9.1-10.el7                      demoElectricFence.x86_64                    2.2.2-39.el7                        demoImageMagick.x86_64                      6.7.8.9-18.el7                      demoImageMagick-c++.x86_64                  6.7.8.9-18.el7                      demoImageMagick-perl.x86_64                 6.7.8.9-18.el7                      demoLibRaw.x86_64                           0.19.2-1.el7                        demoyum源名：@base该包已经安装，且是从base安装的        @anaconda该报已经安装，且是从操作系统的安装程序anaconda安装的        installed 表示该包是由rpm手动安装的      </code></pre><p>clean: 清理yum下的缓存（目录在&#x2F;var&#x2F;cache&#x2F;yum下）</p><pre><code>[ packages | headers | metadata | dbcache | all ]</code></pre><p>repolist: 显示repo列表及其简要信息</p><pre><code>allenabled： 默认disabled: 禁用[root@localhost demo]# yum repolist allLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilerepo id                           repo name                              statusdemo                              centos-demo                            enabled: 4,067repolist: 4,067</code></pre><p>install: 安装<br>update: 升级<br>update_to: 升级为指定版本<br>remove|erase：卸载</p><pre><code>yum install PACKAGE_NAME[root@localhost demo]# yum remove zshLoaded plugins: fastestmirror, langpacksResolving Dependencies--&gt; Running transaction check---&gt; Package zsh.x86_64 0:5.0.2-33.el7 will be erased--&gt; Finished Dependency ResolutionDependencies Resolved======================================================================================= Package        Arch              Version                   Repository            Size=======================================================================================Removing: zsh            x86_64            5.0.2-33.el7              installed            5.6 MTransaction Summary=======================================================================================Remove  1 PackageInstalled size: 5.6 MIs this ok [y/N]: yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transactionWarning: RPMDB altered outside of yum.  Erasing    : zsh-5.0.2-33.el7.x86_64                                             1/1 warning: /etc/zshrc saved as /etc/zshrc.rpmsave  Verifying  : zsh-5.0.2-33.el7.x86_64                                             1/1 Removed:  zsh.x86_64 0:5.0.2-33.el7                                                            Complete!</code></pre><p>info: 查看包的说明信息</p><pre><code>[root@localhost bin]# yum info zshLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileInstalled PackagesName        : zshArch        : x86_64Version     : 5.0.2Release     : 33.el7Size        : 5.6 MRepo        : installedFrom repo   : demoSummary     : Powerful interactive shellURL         : http://zsh.sourceforge.net/License     : MITDescription : The zsh shell is a command interpreter usable as an interactive login            : shell and as a shell script command processor.  Zsh resembles the ksh            : shell (the Korn shell), but includes many enhancements.  Zsh supports            : command line editing, built-in spelling correction, programmable            : command completion, shell functions (with autoloading), a history            : mechanism, and more.</code></pre><p>provides| whatprovides: 查看指定的文件或特性是由哪个包安装生成的。; </p><pre><code>[root@localhost etc]# yum provides zshLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilezsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : demozsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : @demo[root@localhost usr]# yum provides /etc/zshrcLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilezsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : demoMatched from:Filename    : /etc/zshrczsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : @demoMatched from:Filename    : /etc/zshrc</code></pre><p>grouplist：查看组列表。有些默认不显示，可以使用hidden参数</p><pre><code>[root@localhost usr]# yum grouplist hiddenLoaded plugins: fastestmirror, langpacksThere is no installed groups file.Maybe run: yum groups mark convert (see man yum)Loading mirror speeds from cached hostfileInstalled Environment Groups:   Development and Creative WorkstationAvailable Environment Groups:(可用环境组)   Minimal Install   Compute Node   Infrastructure Server   File and Print Server   Basic Web Server   Virtualization Host   Server with GUI   GNOME Desktop   KDE Plasma Workspaces   Development and Creative WorkstationInstalled Groups:   Development ToolsAvailable Groups:（可用组）   Additional Development                          ....       \\ 以上命令也可以使用[root@localhost usr]# yum grouplist Deve*</code></pre><p>groupinfo：查看组信息</p><pre><code>[root@localhost usr]# yum groupinfo &quot;Development Tools&quot;Loaded plugins: fastestmirror, langpacksThere is no installed groups file.Maybe run: yum groups mark convert (see man yum)Loading mirror speeds from cached hostfileGroup: Development ToolsGroup-Id: development Description: A basic development environment. Mandatory Packages:（必须安装）    autoconf    automake    binutils    ... Default Packages:（默认安装）    byacc    cscope    ctags    ... Optional Packages:（可选）   ElectricFence   ant   babel   bzr   chrpath    ...</code></pre><p>groupinstall：安装<br>groupremove：移除<br>groupupdate：更新  </p><pre><code>[root@localhost media]# yum groupinstall &quot;Development Tools&quot; --setopt=group_package_types=mandatory,default,optionalLoaded plugins: fastestmirror, langpacksThere is no installed groups file.Maybe run: yum groups mark convert (see man yum)Loading mirror speeds from cached hostfileResolving Dependencies--&gt; Running transaction check                        ....</code></pre><p><a href="https://blog.51cto.com/u_4528728/3804803">https://blog.51cto.com/u_4528728&#x2F;3804803</a>  </p><blockquote><p>如何创建yum仓库的元数据：   </p><p>createrepo: <a href="https://blog.csdn.net/u013158317/article/details/95587397">https://blog.csdn.net/u013158317/article/details/95587397</a></p></blockquote><div class="note green icon-padding flat"><p>练习：</p>  <p>1、将系统安装光盘挂载至/media/yum目录，用其实现yum仓库；  </p>  <p>2、配置使用http://172.16.0.1/yum/{Server,VT,Cluster,ClusterStorage}为可用yum仓库；</p><p>写一个脚本，完成以下功能：  </p><p>说明：此脚本能于同一个repo文件中创建多个Yum源的指向；  </p><p>1、接受一个文件名做为参数，此文件存放至/etc/yum.repos.d目录中，且文件名以.repo为后缀；要求，此文件不能事先存，否则，报错；  </p><p>2、在脚本中，提醒用户输入repo id；如果为quit，则退出脚本；否则，继续完成下面的步骤； </p><p>3、repo name以及baseurl的路径，而后以repo文件的格式将其保存至指定的文件中；</p>  <p>4、enabled默认为1，而gpgcheck默认设定为0；  </p><p>5、此脚本会循环执行多次，除非用户为repo id指定为quit；  </p></div>  <h2 id="手动编译安装软件"><a href="#手动编译安装软件" class="headerlink" title="手动编译安装软件"></a>手动编译安装软件</h2><p>RPM安装：  </p><pre><code>二进制格式：源程序--&gt;编译--&gt;二进制格式    有些特性是编译选定的，如果编译未选定此特性，将无法使用；    rpm包的版本会落后于源码包，甚至落后很多；bind-9.8.7, bind-9.7.2定制：手动编译安装</code></pre><p>相关工具：</p><pre><code>gcc: GNU C Complier, C语言编译工具g++: C++语言编译工具make: 项目管理工具    makefile: 定义了make（gcc,g++）按何种次序去编译这些源程序文件中的源程序使用automake--&gt; makefile.in，使用autoconf--&gt; configure，获取的源码中会包含以上两个文件。然后makefile.in和configure得到makefile</code></pre><p>编译安装的步骤：</p><ol><li><p>前提：准备开发环境(编译环境)<br>安装”Development Tools”和”Development Libraries” </p></li><li><p>获取源码包</p><pre><code> [root@localhost Desktop]# ll total 1016 -rw-rw-r--+ 1 demo demo       0 Dec 25 04:42 demo2.txt -rwxrw-rw-+ 1 demo demo 1039530 Jan  8 07:59 nginx-1.18.0.tar.gz</code></pre></li><li><p>解压源码包</p><pre><code> [root@localhost Desktop]# tar -zxvf nginx-1.18.0.tar.gz </code></pre></li><li><p>指定编译特性</p><pre><code> # cd # ./configure   --help  --prefix=/path/to/somewhere --sysconfdir=/PATH/TO/CONFFILE_PATH 功能：1、让用户选定编译特性；2、检查编译环境  // 查看软件支持的特性 [root@localhost nginx-1.18.0]# ./configure --help // 指定软件的编译特性 [root@localhost nginx-1.18.0]# ./configure --prefix=/usr/local/nginx --conf-path=/usr/local/etc --without-http_rewrite_module --without-http_gzip_module</code></pre></li><li><p>编译</p><pre><code>  make</code></pre></li><li><p>安装</p><pre><code> make install</code></pre></li><li><p>修改PATH环境变量，以能够识别此程序的二进制文件路径；</p><pre><code> 修改/etc/profile文件，然后执行source /etc/profile 在/etc/profile.d/目录建立一个以.sh为名称后缀的文件，在里面定义export PATH=$PATH:/path/to/somewhere</code></pre></li><li><p>默认情况下，系统搜索库文件的路径&#x2F;lib, &#x2F;usr&#x2F;lib; 要增添额外搜寻路径：</p><pre><code> 在/etc/ld.so.conf.d/中创建以.conf为后缀名的文件，而后把要增添的路径直接写至此文件中； # ldconfig 通知系统重新搜寻库文件     -v: 显示重新搜寻库的过程</code></pre></li><li><p>头文件：输出给系统</p><pre><code> 默认：/usr/include 增添头文件搜寻路径，使用链接进行：     /usr/local/tengine/include/   /usr/include/     两种方式：     ln -s /usr/local/tengine/include/* /usr/include/ 或     ln -s /usr/local/tengine/include  /usr/include/tengine(建议这种)</code></pre></li><li><p>man文件路径：安装在–prefix指定的目录下的man目录；&#x2F;usr&#x2F;share&#x2F;man</p><pre><code>1、man -M /PATH/TO/MAN_DIR COMMAND2、在/etc/man.config中添加一条MANPATH</code></pre></li><li><p>删除软件只需要将软件生成的文件以及上述修改删除即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;程序介绍&quot;&gt;&lt;a href=&quot;#程序介绍&quot; class=&quot;headerlink&quot; title=&quot;程序介绍&quot;&gt;&lt;/a&gt;程序介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们将语言分为两种。一种是编译器语言，另一种是解释性语言。编译语言以C语言为例，需要将源代码–&amp;g</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="yum" scheme="http://example.com/tags/yum/"/>
    
    <category term="rpm" scheme="http://example.com/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>vi编辑器</title>
    <link href="http://example.com/2022/11/27/Linux-VI/"/>
    <id>http://example.com/2022/11/27/Linux-VI/</id>
    <published>2022-11-27T11:54:59.238Z</published>
    <updated>2022-11-27T11:54:59.236Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>vi是linux中最常用的一个文本编辑器。vim是vi的增强版。</P>  </div><h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p>vim模式分为如下几种：</p><ul><li>编辑模式(命令模式)</li><li>输入模式</li><li>末行模式</li></ul><p>模式转换：  </p><pre><code>编辑--&gt;输入：    i: 在当前光标所在字符的前面，转为输入模式；    a: 在当前光标所在字符的后面，转为输入模式；    o: 在当前光标所在行的下方，新建一行，并转为输入模式；        I：在当前光标所在行的行首，转换为输入模式    A：在当前光标所在行的行尾，转换为输入模式    O：在当前光标所在行的上方，新建一行，并转为输入模式；输入--&gt;编辑：    ESC    编辑--&gt;末行：    ：末行--&gt;编辑：    ESC, ESC</code></pre><h2 id="vim打开文件"><a href="#vim打开文件" class="headerlink" title="vim打开文件"></a>vim打开文件</h2><pre><code># vim /path/to/somefilevim +# :打开文件，并定位于第#行 vim +：打开文件，定位至最后一行vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首默认处于编辑模式</code></pre><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><pre><code>1、末行模式关闭文件    :q  退出    :wq 保存并退出    :q! 不保存并退出    :w 保存    :w! 强行保存    :wq --&gt; :x2、编辑模式下退出    ZZ: 保存并退出</code></pre><h2 id="移动光标-编辑模式"><a href="#移动光标-编辑模式" class="headerlink" title="移动光标(编辑模式)"></a>移动光标(编辑模式)</h2><pre><code>1、逐字符移动：    h: 左    l: 右    j: 下    k: 上 #h: 移动#个字符；2、以单词为单位移动    w: 移至下一个单词的词首    e: 跳至当前或下一个单词的词尾    b: 跳至当前或前一个单词的词首        #w: 移动#个单词3、行内跳转：    0: 绝对行首    ^: 行首的第一个非空白字符    $: 绝对行尾4、行间跳转    #G：跳转至第#行；    G：最后一行        末行模式下，直接给出行号即可</code></pre><h2 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h2><pre><code>Ctrl+f: 向下翻一屏Ctrl+b: 向上翻一屏Ctrl+d: 向下翻半屏Ctrl+u: 向上翻半屏</code></pre><h2 id="删除单个字符"><a href="#删除单个字符" class="headerlink" title="删除单个字符"></a>删除单个字符</h2><pre><code>x: 删除光标所在处的单个字符  \#x: 删除光标所在处及向后的共#个字符</code></pre><h2 id="删除命令-d"><a href="#删除命令-d" class="headerlink" title="删除命令: d"></a>删除命令: d</h2><p>d命令跟跳转命令组合使用；</p><pre><code>#dw, #de, #db</code></pre><p>dd: 删除当前光标所在行</p><pre><code>#dd: 删除包括当前光标所在行在内的#行；</code></pre><p>末行模式下：</p><pre><code>StartADD,EndADDd        .: 表示当前行    $: 最后一行    +#: 向下的#行</code></pre><h2 id="复制命令-y"><a href="#复制命令-y" class="headerlink" title="复制命令 y"></a>复制命令 y</h2><pre><code>用法同d命令</code></pre><h2 id="修改：先删除内容，再转换为输入模式"><a href="#修改：先删除内容，再转换为输入模式" class="headerlink" title="修改：先删除内容，再转换为输入模式"></a>修改：先删除内容，再转换为输入模式</h2><pre><code>c: 用法同d命令</code></pre><h2 id="粘贴命令-p"><a href="#粘贴命令-p" class="headerlink" title="粘贴命令 p"></a>粘贴命令 p</h2><pre><code>p: 如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；P: 如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面；</code></pre><h2 id="替换："><a href="#替换：" class="headerlink" title="替换："></a>替换：</h2><pre><code>r: 替换单个字符R: 替换模式</code></pre><h2 id="撤消编辑操作-u"><a href="#撤消编辑操作-u" class="headerlink" title="撤消编辑操作 u"></a>撤消编辑操作 u</h2><pre><code>u：撤消前一次的编辑操作    连续u命令可撤消此前的n次编辑操作#u: 直接撤消最近#次编辑操作撤消最近一次撤消操作：Ctrl+r</code></pre><h2 id="重复前一次编辑操作"><a href="#重复前一次编辑操作" class="headerlink" title="重复前一次编辑操作"></a>重复前一次编辑操作</h2><p>. (点)</p><h2 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h2><pre><code>v: 按字符选取V：按矩形选取</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code>/PATTERN?PATTERN    n:向下    N:向上</code></pre><h2 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h2><p>在末行模式下使用s命令</p><pre><code>ADDR1,ADDR2s@PATTERN@string@gi1,$%：表示全文</code></pre><p>练习：将&#x2F;etc&#x2F;yum.repos.d&#x2F;server.repo文件中的<a href="ftp://instructor.example.com/pub%E6%9B%BF%E6%8D%A2%E4%B8%BAhttp://172.16.0.1/yum">ftp://instructor.example.com/pub替换为http://172.16.0.1/yum</a></p><pre><code>%s/ftp:\/\/instructor\.example\.com\/pub/http:\/\/172.16.0.1\/yum/g%s@ftp://instructor\.example\.com/pub@http://172.16.0.1/yum@g</code></pre><p>文件内容如下：</p><pre><code># repos on instructor for classroom use# Main rhel5 server[base]name=Instructor Server Repositorybaseurl=ftp://172.16.0.1/pub/Servergpgcheck=0# This one is needed for xen packages[VT]name=Instructor VT Repositorybaseurl=ftp://172.16.0.1/pub/VTgpgcheck=0# This one is needed for clustering packages[Cluster]name=Instructor Cluster Repositorybaseurl=ftp://172.16.0.1/pub/Clustergpgcheck=0# This one is needed for cluster storage (GFS, iSCSI target, etc...) packages[ClusterStorage]name=Instructor ClusterStorage Repositorybaseurl=ftp://172.16.0.1/pub/ClusterStoragegpgcheck=0</code></pre><h2 id="使用vim编辑多个文件"><a href="#使用vim编辑多个文件" class="headerlink" title="使用vim编辑多个文件"></a>使用vim编辑多个文件</h2><pre><code>vim FILE1 FILE2 FILE3:next 切换至下一个文件:prev 切换至前一个文件:last 切换至最后一个文件:first 切换至第一个文件退出:qa 全部退</code></pre><h2 id="分屏显示一个文件"><a href="#分屏显示一个文件" class="headerlink" title="分屏显示一个文件"></a>分屏显示一个文件</h2><pre><code>Ctrl+w, s: 水平拆分窗口Ctrl+w, v: 垂直拆分窗口注：先按住Ctrl+w，松开，然后按s在窗口间切换光标：Ctrl+w, ARROW(上下左右):qa 关闭所有窗口</code></pre><h2 id="分窗口编辑多个文件"><a href="#分窗口编辑多个文件" class="headerlink" title="分窗口编辑多个文件"></a>分窗口编辑多个文件</h2><pre><code>vim -o : 水平分割显示vim -O : 垂直分割显示</code></pre><h2 id="将当前文件中部分内容另存为另外一个文件"><a href="#将当前文件中部分内容另存为另外一个文件" class="headerlink" title="将当前文件中部分内容另存为另外一个文件"></a>将当前文件中部分内容另存为另外一个文件</h2><pre><code>末行模式下使用w命令:w:ADDR1,ADDR2w /path/to/somewhere</code></pre><h2 id="将另外一个文件的内容填充在当前文件中"><a href="#将另外一个文件的内容填充在当前文件中" class="headerlink" title="将另外一个文件的内容填充在当前文件中"></a>将另外一个文件的内容填充在当前文件中</h2><pre><code>:r /path/to/somefile</code></pre><h2 id="跟shell交互"><a href="#跟shell交互" class="headerlink" title="跟shell交互"></a>跟shell交互</h2><pre><code>:! COMMAND</code></pre><h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><p>1、显示或取消显示行号</p><pre><code>:set number:set nu:set nonu</code></pre><p>2、显示忽略或区分字符大小写</p><pre><code>:set ignorecase:set ic:set noic</code></pre><p>3、设定自动缩进</p><pre><code>:set autoindent:set ai:set noai</code></pre><p>4、查找到的文本高亮显示或取消</p><pre><code>:set hlsearch:set nohlsearch</code></pre><p>5、语法高亮</p><pre><code>:syntax on:syntax off</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>/etc/vimrc~/.vimrc</code></pre><div class="note green icon-padding flat"><p>注：可以使用vimtutor练习</p></div>    ]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;vi是linux中最常用的一个文本编辑器。vim是vi的增强版。&lt;/P&gt;  
&lt;/div&gt;

&lt;h2 id=&quot;vim模式&quot;&gt;&lt;a href=&quot;#vim模式&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="vi" scheme="http://example.com/tags/vi/"/>
    
  </entry>
  
  <entry>
    <title>sed（流编辑器）</title>
    <link href="http://example.com/2022/11/27/Linux-Sed/"/>
    <id>http://example.com/2022/11/27/Linux-Sed/</id>
    <published>2022-11-27T11:29:41.234Z</published>
    <updated>2022-11-27T11:29:41.232Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>sed是Linux中的一个流编辑器，它主要是针对行进行编辑的。vi和nano是全屏编辑器。</P>  <p>sed 模式空间：默认不编辑原文件，仅对模式空间中的数据做处理；而后，处理结束后，将模式空间打印至屏幕</P></div><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>sed [options] &#39;AddressCommand&#39; file ...    -n: 静默模式，不再默认显示模式空间中的内容    -i: 直接修改原文件    -e SCRIPT -e SCRIPT:可以同时执行多个脚本    -f /PATH/TO/SED_SCRIPT        sed -f /path/to/scripts  file    -r: 表示使用扩展正则表达式注：AddressCommand中地址省略代表所有行。有地址，后面的command命令不能空。Address：1、StartLine,EndLine    比如1,100    $：最后一行2、/RegExp/    /^root/3、/pattern1/,/pattern2/    第一次被pattern1匹配到的行开始，至第一次被pattern2匹配到的行结束，这中间的所有行4、LineNumber    指定的行5、StartLine, +N    从startLine开始，向后的N行；Command：    d: 删除符合条件的行；    p: 显示符合条件的行；    a \string: 在指定的行后面追加新行，内容为string        \n：可以用于换行    i \string: 在指定的行前面添加新行，内容为string    r FILE: 将指定的文件的内容添加至符合条件的行处    w FILE: 将地址指定的范围内的行另存至指定的文件中;     s/pattern/string/修饰符: 查找并替换，默认只替换每行中第一次被模式匹配到的字符串        加修饰符        g: 全局替换        i: 忽略字符大小写    s///: s###, s@@@        字串引用：                    \(\), \1, \2            l..e: like--&gt;liker          love--&gt;lover                    like--&gt;Like          love--&gt;Love        &amp;: 引用模式匹配的整个串   [root@localhost etc]# echo &quot;/etc/rc.d/&quot; | sed -r &#39;s@^(/.*)/([^/]+)/?@\1 and \2 and &amp;@g&#39;   /etc and rc.d and /etc/rc.d/     [root@localhost etc]# sed -n &#39;1,3p&#39; /etc/inittab    # inittab is no longer used when using systemd.   #   # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</code></pre><div class="note green icon-padding flat"><p>sed练习：</p><p>1、删除/etc/grub.conf文件中行首的空白符； </p> <pre><code>sed -r &#39;s@^[[:spapce:]]+@@g&#39; /etc/grub.conf</code></pre><p>2、替换/etc/inittab文件中"id:3:initdefault:"一行中的数字为5；</p><pre><code>sed &#39;s@\(id:\)[0-9]\(:initdefault:\)@\15\2@g&#39; /etc/inittab</code></pre><p>3、删除/etc/inittab文件中的空白行；</p><pre><code>sed &#39;/^$/d&#39; /etc/inittab</code></pre><p>4、删除/etc/inittab文件中开头的#号; </p><pre><code>sed &#39;s@^#@@g&#39; /etc/inittab</code></pre><p>5、删除某文件中开头的#号及后面的空白字符，但要求#号后面必须有空白字符;</p><pre><code>sed -r &#39;s@^#[[:space:]]+@@g&#39; /etc/inittab</code></pre><p>6、删除某文件中以空白字符后面跟#类的行中的开头的空白字符及#</p><pre><code>sed -r &#39;s@^[[:space:]]+#@@g&#39; /etc/inittab</code></pre><p>7、取出一个文件路径的目录名称;</p><pre><code>echo &quot;/etc/rc.d/&quot; | sed -r &#39;s@^(/.*/)[^/]+/?@\1@g&#39;基名：echo &quot;/etc/rc.d/&quot; | sed -r &#39;s@^/.*/([^/]+)/?@\1@g&#39;</code></pre><p>8、传递一个用户名参数给脚本，判断此用户的用户名跟其基本组的组名是否一致，并将结果显示出来。注使用sed命令执行状态结果需注意。</p><pre><code>[root@localhost etc]# grep root /etc/passwd | sed -n &#39;/^\(root\):.*:[[:digit:]]:[[:digit:]]:\1/p&#39;root:x:0:0:root:/root:/bin/bash</code></pre></div><p><a href="https://www.cnblogs.com/zakun/p/linux-cmd-sed.html">https://www.cnblogs.com/zakun/p/linux-cmd-sed.html</a> </p><p><a href="https://www.runoob.com/linux/linux-comm-sed.html">https://www.runoob.com/linux/linux-comm-sed.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;sed是Linux中的一个流编辑器，它主要是针对行进行编辑的。vi和nano是全屏编辑器。&lt;/P&gt;  
&lt;p&gt;sed 模式空间：默认不编辑原文件，仅对模式空间中的数据做处理；而后，处理结束后</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="sed" scheme="http://example.com/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://example.com/2022/11/27/Linux-file/"/>
    <id>http://example.com/2022/11/27/Linux-file/</id>
    <published>2022-11-27T07:57:24.976Z</published>
    <updated>2022-11-27T07:57:24.974Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相成。同时，文件系统也是一个操作系统的重要组成部分。</P></div><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在Linux中一切皆文件</p><pre><code>[demo@localhost dev]$ ll文件类型                   主设备号 次设备号crw-rw-rw-. 1 root tty       5,     0 Dec 25 04:19 ttycrw--w----. 1 root tty       4,     0 Dec 25 04:19 tty0crw--w----. 1 root tty       4,     1 Dec 25 04:19 tty1brw-rw----. 1 root disk      8,     0 Dec 25 04:19 sdabrw-rw----. 1 root disk      8,     1 Dec 25 04:19 sda1brw-rw----. 1 root disk      8,     2 Dec 25 04:19 sda2                         设备文件类型：b: 按块为单位，随机访问的设备；c：按字符为单位，线性设备；主设备号 （major number）    标识设备类型次设备号 （minor number）    标识同一种类型中不同设备</code></pre><p>创建特殊文件</p><pre><code>mknod [OPTION]... NAME TYPE MAJOR（主设备号） MINOR（次设备号）    -m MODE ： 指定权限[root@localhost dev]# mknod sda3 b 8 3[root@localhost dev]# mknod -mode 660 sda4 b 8 3</code></pre><p>磁盘设备的设备文件名：</p><pre><code>IDE, ATA：hdSATA：sdSCSI: sdUSB: sd同种设备以a，b，c...来区分同一种类型下的不同设备，即sda, sdb, sdc, ...IDE:     第一个IDE口：主、从        /dev/hda, /dev/hdb    第二个IDE口：主、从        /dev/hdc, /dev/hdd</code></pre><p>同一磁盘设备文件分区名:</p><pre><code>如hda:     hda1: 第一个主分区    hda2: 第二个主分区    hda3: 第三个主分区    hda4: 第四个主分区（MBR中的扩展分区）    hda5: 第一个逻辑分区</code></pre><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h3><p>首先了解一下磁盘的物理结构。磁盘是由一个个光盘结合在一起，每个光盘上都有一些同心圆。这些同心圆我们称之为磁道，然后将磁道划分为一个个的扇区作为基本存储单元。同时每一个光盘的同一扇区称之为柱面。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB362e3b95a3888dcdf1fc43d21c8daa00?method=download&shareKey=974939cf6495a01ed31327a286a5aa35" alt="image"></p><p>磁盘刚被创建出来后，没有任何信息。磁盘在出厂的时候会进行低级格式化。格式化之后的扇区由前导码（包括柱面号、扇区号等）、数据区和ECC（数据纠错码）组成。</p><p>大部分的磁盘能够划分出一到多个分区，叫做磁盘分区。每个分区都有独立的文件系统，每块分区的文件系统都可以不同。目前磁盘的分区组织方式有两种，分别为MBR和GPT。  </p><h3 id="分区组织方式"><a href="#分区组织方式" class="headerlink" title="分区组织方式"></a>分区组织方式</h3><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>磁盘的0号分区称为主引导记录（MBR），位于磁盘的第一扇区。MBR由Bootloader（446bytes）、Partition Table（64bytes，每个16个字节记录一个分区）、Magic Number（2个字节）组成。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB373eb090e2c333bc226709ac8b7ff105?method=download&shareKey=06a6b63acbf2ef85453d7227a63f4643" alt="image"></p><ol><li><p>Bootloader:用于标识操作系统的放置方式和位置，以便可以将其加载到计算机的内存中。    </p></li><li><p>Partition Table:由于Partition Table最多只能包含四条记录。如果磁盘分区大于4，需要将最后一条记录添加为扩展分区。扩展分区可以存储更多的分区记录。</p></li><li><p>Magic Number：如果为0x55 0xAA，则代表该设备MBR中含有Bootloader。</p></li></ol><p>在计算机启动过程中会首先启动BIOS检查各种硬件环境，之后根据BIOS的配置挨个查看存储设备的前512字节是不是以0x55 0xAA结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载该磁盘MBR中的Bootloader。并将控制权转移到相应设备（U盘、硬盘）的引导加载程序(Bootloader)。</p><p>MBR存在如下限制：</p><ol><li>操作系统无法抓取到2.2T以上的磁盘容量</li><li>MBR仅有一个区块。若被破坏后，经常无法或很难救援</li><li>MBR内存开机管理程序的区块仅446Bytes，无法容纳较多的程序码</li></ol><h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p>GPT不存在如上所述的限制。</p><blockquote><p>过去一个扇区的大小为512Bytes，目前已经有4K的扇区出现。为了相容于所有的磁盘，所以引入了逻辑区块位址（LBA)的概念。GPT将磁盘所有扇区以此LBA（默认为512Bytes喔！）来规划，而第一个LBA称为LBA0.</p></blockquote><p>GPT使用了34个LBA区块来记录分区信息。同时整个磁盘的最后33个LBA也拿来作为一个备份。GPT结构如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB1a6a41e7d27580e02d1060e36902cd66?method=download&shareKey=9aa1e15262c5049a57738d48448694f5" alt="image"></p><p>LBA0 (MBR兼容）</p><p>与MBR模式相似的，这个相容区块也分为两个部分。一个就是根之前446Bytes相似的区块，存储了第一阶段的开机管理程序。而在原本的分区表的记录区内放入了一个特殊标志，用来表示此磁盘为GPT格式。而不懂GPT分区表的磁盘管理程序，就不会认识这颗磁盘。除非用户有特别要求要处理这颗磁盘。</p><p>LBA1 （GPT表头）</p><p>记录了备份用的GPT分区放置的位置，同时放置了分区表的校验机制码。操作系统可以根据这个校验码来判断GPT是否正确。若有错误，还可以通过这个记录区来取得备份的GPT来恢复GPT的正常运行。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>磁盘在使用之前要进行高级格式化，高级格式化即在分区上分配文件系统。</p><h4 id="ext-系列"><a href="#ext-系列" class="headerlink" title="ext 系列"></a>ext 系列</h4><p>每个文件系统的结构如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd28a8793ae46cdcd002c271e2f45bcac?method=download&shareKey=255b05b4812120ce65529dfddcf1bb03" alt="image"></p><ul><li>引导块：为了一致性，每个分区都要从引导块开始，即使引导块不包括操作系统。引导块占据文件系统的前4096个字节，从磁盘上的字节偏移量0开始。引导块可用于启动操作系统。  </li><li>超级块：描述整个分区的文件系统信息。例如块大小、文件系统的大小、文件系统的块数等。  </li><li>空闲空间管理：块位图和inode位图。块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块。其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用</li><li>inode：一个文件除了数据需要存储之外，一些描述信息也需要存储。例如文件类型（常规、目录、符号链接等），权限，文件大小，创建&#x2F;修改&#x2F;访问时间等。也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中</li><li>根目录：存放文件系统目录树的根部。</li><li>文件和目录：存储文件和目录的数据。</li></ul><p>文件系统逻辑结构图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8fafced3dd9b543ffa04545dfc65680e?method=download&shareKey=c8803f0b05537d766c6ad7f60b7588da" alt="image"></p><p>Linux支持的文件系统</p><ul><li>ext3, ext4, ext2: extended</li><li>reiserfs</li><li>iso9660, swap, cifs, nfs</li><li>xfs, jfs</li><li>ocfs2, gfs2</li><li>fat32, ntfs</li></ul><h4 id="xfs文件系统"><a href="#xfs文件系统" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><p>CentOS 7 开始，默认的文件系统已经由原本的Ext4 变成了xfs 这个较适合大容量磁盘与巨型文件性能较佳的文件系统了。</p><p>Ext文件系统采用的是预先规划出所有的inode&#x2F;block&#x2F;metadata等数据，这些数据未来系统可以直接使用。xfs则是根据需要动态分配inode和block数据。当磁盘容量达到TB以上等级时，传统ext家族在文件系统格式化时预先规划inode和block就需要消耗好多的时间。</p><p>xfs文件系统的组成：</p><ol><li>数据区：这个区域和ext文件系统的block群组一样，只不过inode和block是动态产生的，并非是一开始格式化就分配好的</li><li>文件系统活动登录区：日志区。文件的变化会记录到这里。当变化完整的写入数据区后，该笔记录才会被终结。</li><li>实时运行区：当有文件要被创建时，xfs会在这个区段里面找一个到数个extent区块，将文件放置在这个区块中，等到动态分配完毕后，再写入到数据区的inode和block中。这个extent区块的大小要在格式化的时候就指定，最小值4k最大可到1G。建议不要乱动，具有磁盘阵列stripe的情况下，则建议extent设置为与stripe一样大比较好。</li></ol><p>查看xfs文件系统信息：</p><pre><code>[root@study ~]# xfs_info 挂载点|设备文件名范例一：找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录[root@study ~]# df -T /bootFilesystem Type 1K-blocks Used Available Use% Mounted on/dev/vda2 xfs 1038336 133704 904632 13% /boot# 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！[root@study ~]# xfs_info /dev/vda21 meta-data=/dev/vda2 isize=256 agcount=4, agsize=65536 blks2 = sectsz=512 attr=2, projid32bit=13 = crc=0 finobt=04 data = bsize=4096 blocks=262144, imaxpct=255 = sunit=0 swidth=0 blks6 naming =version 2 bsize=4096 ascii-ci=0 ftype=07 log =internal bsize=4096 blocks=2560, version=28 = sectsz=512 sunit=0 blks, lazy-count=19 realtime =none extsz=4096 blocks=0, rtextents=0第 1 行里面的 isize 指的是 inode 的容量，每个有 256Bytes 这么大。至于 agcount 则是前面谈到的储存区群组 （allocation group） 的个数，共有 4 个， agsize 则是指每个储存区群组具有 65536 个 block 。配合第 4 行的 block 设置为 4K，因此整个文件系统的容量应该就是 4655364K 这么大！第 2 行里面 sectsz 指的是逻辑扇区 （sector） 的容量设置为 512Bytes 这么大的意思。第 4 行里面的 bsize 指的是 block 的容量，每个 block 为 4K 的意思，共有 262144 个block 在这个文件系统内。第 5 行里面的 sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。这部份我们下面格式化的时候会举一个例子来说明。第 7 行里面的 internal 指的是这个登录区的位置在文件系统内，而不是外部设备的意思。且占用了 4K * 2560 个 block，总共约 10M 的容量。第 9 行里面的 realtime 区域，里面的 extent 容量为 4K。不过目前没有使用。</code></pre><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="分区命令"><a href="#分区命令" class="headerlink" title="分区命令"></a>分区命令</h3><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区！parted &#x2F;dev&#x2F;xxx print可以找出内部的分区表类型，之后再用 gdisk 或 fdisk 来操作系统。</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk -l [&#x2F;dev&#x2F;to&#x2F;some_device_file] ：查看当前系统识别了几块硬盘  </p><pre><code>[root@localhost dev]# fdisk -lDisk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0001d65a   Device Boot      Start         End      Blocks   Id  System/dev/sda1   *        2048     2099199     1048576   83  Linux（分区）/dev/sda2         2099200    41943039    19921920   8e  Linux LVM（分区）Disk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes</code></pre><p>fdisk &#x2F;dev&#x2F;sda  </p><pre><code>p: 显示当前硬件的分区，包括没保存的改动n: 创建新分区    e: 扩展分区（创建扩展分区，将所有空间分配给它）    p: 主分区d: 删除一个分区w: 保存退出q: 不保存退出t: 修改分区类型L: （查看分区类型）l: 显示所支持的所有类型[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xc8f76ed0.Command (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  SystemCommand (m for help): nPartition type:   p   primary (0 primary, 0 extended, 4 free)   e   extendedSelect (default p): pPartition number (1-4, default 1):   First sector (2048-41943039, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +1GPartition 1 of type Linux and of size 1 GiB is set... //再建立两个主分区Command (m for help): nPartition type:   p   primary (3 primary, 0 extended, 1 free)   e   extendedSelect (default e): eSelected partition 4First sector (6293504-41943039, default 6293504): Using default value 6293504Last sector, +sectors or +size&#123;K,M,G&#125; (6293504-41943039, default 41943039): Using default value 41943039Partition 4 of type Extended and of size 17 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  System/dev/sdb1            2048     2099199     1048576   83  Linux/dev/sdb2         2099200     4196351     1048576   83  Linux/dev/sdb3         4196352     6293503     1048576   83  Linux/dev/sdb4         6293504    41943039    17824768    5  ExtendedCommand (m for help): nAll primary partitions are in useAdding logical partition 5First sector (6295552-41943039, default 6295552):  Using default value 6295552Last sector, +sectors or +size&#123;K,M,G&#125; (6295552-41943039, default 41943039): +1GPartition 5 of type Linux and of size 1 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  System/dev/sdb1            2048     2099199     1048576   83  Linux/dev/sdb2         2099200     4196351     1048576   83  Linux/dev/sdb3         4196352     6293503     1048576   83  Linux/dev/sdb4         6293504    41943039    17824768    5  Extended/dev/sdb5         6295552     8392703     1048576   83  Linux</code></pre><p>cat &#x2F;proc&#x2F;partitions ：查看系统有哪些分区<br>partprobe [&#x2F;dev&#x2F;sda]：重新加载设备分区</p><h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><pre><code>[root@study ~]# gdisk 设备名称范例：由前一小节的 lsblk 输出，我们知道系统有个 /dev/vda，请观察该磁盘的分区与相关数据[root@study ~]# gdisk /dev/vda  #仔细看，不要加上数字喔！GPT fdisk （gdisk） version 0.8.6Partition table scan:MBR: protectiveBSD: not presentAPM: not presentGPT: presentFound valid GPT with protective MBR; using GPT. &amp;lt;==找到了 GPT 的分区表！Command （? for help）: #这里可以让你输入指令动作，可以按问号 （?） 来查看可用指令Command （? for help）: ?b back up GPT data to a filec change a partition&#39;s named delete a partition # 删除一个分区i show detailed information on a partitionl list known partition typesn add a new partition # 增加一个分区o create a new empty GUID partition table （GPT）p print the partition table # 印出分区表 （常用）q quit without saving changes  # 不储存分区就直接离开 gdiskr recovery and transformation options （experts only）s sort partitionst change a partition&#39;s type codev verify diskw write table to disk and exit  # 储存分区操作后离开 gdiskx extra functionality （experts only）? print this menuCommand （? for help）:</code></pre><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>查看当前内核所支持文件系统类型：</p><pre><code>cat /proc/filesystems  </code></pre><h4 id="ext系列文件系统"><a href="#ext系列文件系统" class="headerlink" title="ext系列文件系统"></a>ext系列文件系统</h4><p>专门管理ext系列文件：<br>mkdfs.ext4<br>mke2fs  </p><pre><code>-j: 创建ext3类型文件系统-b BLOCK_SIZE: 指定块大小，默认为4096；可用取值为1024、2048或4096；-L LABEL：指定分区卷标；-m #: 指定预留给超级用户的块数百分比-i #: 用于指定用多少字节的空间创建一个inode，默认为8192；这里给出的数值应该为块大小的2^n倍；-N #: 指定inode个数；-F: 强制创建文件系统；-E: 用户指定额外文件系统属性; [root@localhost ~]# mkfs -t ext2 /dev/sdb1mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65536 inodes, 262144 blocks13107 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8192 inodes per groupSuperblock backups stored on blocks: （超级块备份存储的块地址）    32768, 98304, 163840, 229376Allocating group tables: done                            Writing inode tables: done                            Writing superblocks and filesystem accounting information: done</code></pre><h4 id="xfs文件系统-1"><a href="#xfs文件系统-1" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><pre><code>[root@study ~]# mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \[-r parms] 设备名称选项与参数：关于单位：下面只要谈到“数值”时，没有加单位则为 Bytes 值，可以用 k,m,g,t,p （小写）等来解释比较特殊的是 s 这个单位，它指的是 sector 的“个数”喔！-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！-d ：后面接的是重要的 data section 的相关参数值，主要的值有：    agcount=数值 ：设置需要几个储存群组的意思（AG），通常与 CPU 有关    agsize=数值 ：每个 AG 设置为多少容量的意思，通常 agcount/agsize 只选一个设置即可    file ：指的是“格式化的设备是个文件而不是个设备”的意思！（例如虚拟磁盘）    size=数值 ：data section 的容量，亦即你可以不将全部的设备容量用完的意思    su=数值 ：当有 RAID 时，那个 stripe 数值的意思，与下面的 sw 搭配使用    sw=数值 ：当有 RAID 时，用于储存数据的磁盘数量（须扣除备份碟与备用碟）    sunit=数值 ：与 su 相当，不过单位使用的是“几个 sector（512Bytes大小）”的意思    swidth=数值 ：就是 su*sw 的数值，但是以“几个 sector（512Bytes大小）”来设置-f ：如果设备内已经有文件系统，则需要使用这个 -f 来强制格式化才行！-i ：与 inode 有较相关的设置，主要的设置值有：    size=数值 ：最小是 256Bytes 最大是 2k，一般保留 256 就足够使用了！    internal=[0&amp;#124;1]：log 设备是否为内置？默认为 1 内置，如果要用外部设备，使用下面设置    logdev=device ：log 存储为后面接的那个设备上头的意思，需设置 internal=0 才可！    size=数值 ：指定这块登录区的容量，通常最小得要有 512 个 block，大约 2M 以上才行！-L ：后面接这个文件系统的标头名称 Label name 的意思！-r ：指定 realtime section 的相关设置值，常见的有：    extsize=数值 ：就是那个重要的 extent 数值，一般不须设置，但有 RAID 时，    最好设置与 swidth 的数值相同较佳！最小为 4K 最大为 1G 。    范例：将前一小节分区出来的 /dev/vda4 格式化为 xfs 文件系统[root@study ~]# mkfs.xfs /dev/vda4meta-data=/dev/vda4 isize=256 agcount=4, agsize=65536 blks= sectsz=512 attr=2, projid32bit=1= crc=0 finobt=0data = bsize=4096 blocks=262144, imaxpct=25= sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal log bsize=4096 blocks=2560, version=2= sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0# 很快格是化完毕！都用默认值！较重要的是 inode 与 block 的数值[root@study ~]# blkid /dev/vda4/dev/vda4: UUID=&quot;39293f4f-627b-4dfd-a015-08340537709c&quot; TYPE=&quot;xfs&quot;# 确定创建好 xfs 文件系统了！</code></pre><p>XFS文件系统for RAID性能优化</p><p>磁盘阵列 （RAID） 就是通过将文件先细分为数个小型的分区区块 （stripe） 之后，然后将众多的 stripes 分别放到磁盘阵列里面的所有磁盘， 所以一个文件是被同时写入到多个磁盘去，当然性能会好一些。为了文件的保全性，所以在这些磁盘里面，会保留数个（与磁盘阵列的规划有关） 备份磁盘 （parity disk）， 以及可能会保留一个以上的备用磁盘（spare disk）。</p><p>文件系统的读写要能够有最优化，最好能够搭配磁盘阵列的参数来设计，这样性能才能够起来！也就是说，你可以先在文件系统就将 stripe 规划好， 那交给 RAID 去存取时，它就无须重复进行文件的 stripe 过程，性能当然会更好！那格式化时，最优化性能与什么咚咚有关呢？我们来假设个环境好了：</p><blockquote><p>我有两个线程的 CPU 数量，所以 agcount 最好指定为 2</p><p>当初设置 RAID 的 stripe 指定为 256K 这么大，因此 su 最好设置为 256k</p><p>设置的磁盘阵列有 8 颗，因为是 RAID5 的设置，所以有一个 parity （备份碟），因此指定 sw 为 7</p><p>由上述的数据中，我们可以发现数据宽度 （swidth） 应该就是 256K*7 得到 1792K，以指定 extsize 为 1792k</p></blockquote><blockquote><p>重新创建文件系统会损坏原有文件  </p></blockquote><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>mkfs: make file system  </p><pre><code>-t FSTYPE 文件系统类型    mkfs -t ext2 = mkfs.ext2mkfs -t ext3 = mkfs.ext3</code></pre><p>parted：创建文件系统，ext和xfs都可以</p><pre><code>parted [设备] [指令 [参数]]新增分区：mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束显示分区：print删除分区：rm [partition]范例一：以 parted 列出目前本机的分区表数据[root@study ~]# parted /dev/vda printModel: Virtio Block Device （virtblk） &amp;lt;==磁盘接口与型号Disk /dev/vda: 42.9GB &amp;lt;==磁盘文件名与容量Sector size （logical/physical）: 512B/512B &amp;lt;==每个扇区的大小Partition Table: gpt &amp;lt;==是 GPT 还是 MBR 分区Disk Flags: pmbr_bootNumber Start End Size File system Name Flags1 1049kB 3146kB 2097kB bios_grub2 3146kB 1077MB 1074MB xfs3 1077MB 33.3GB 32.2GB lvm4 33.3GB 34.4GB 1074MB xfs Linux filesystem5 34.4GB 35.4GB 1074MB ext4 Microsoft basic data6 35.4GB 36.0GB 537MB linux-swap（v1） Linux swap[ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ]</code></pre><h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><blockquote><p>修复文件系统时不能被挂载</p></blockquote><h4 id="xfs-repair"><a href="#xfs-repair" class="headerlink" title="xfs_repair"></a>xfs_repair</h4><p>检查并修复 XFS 文件系统</p><pre><code>[root@study ~]# xfs_repair [-fnd] 设备名称选项与参数：-f ：后面的设备其实是个文件而不是实体设备-n ：单纯检查并不修改文件系统的任何数据 （检查而已）-d ：通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作！很危险！不要随便使用范例：检查一下刚刚创建的 /dev/vda4 文件系统[root@study ~]# xfs_repair /dev/vda4Phase 1 - find and verify superblock...Phase 2 - using internal logPhase 3 - for each AG...Phase 4 - check for duplicate blocks...Phase 5 - rebuild AG headers and trees...Phase 6 - check inode connectivity...Phase 7 - verify and correct link counts...done# 共有 7 个重要的检查流程！详细的流程介绍可以 man xfs_repair 即可！</code></pre><h4 id="其它文件系统自检"><a href="#其它文件系统自检" class="headerlink" title="其它文件系统自检"></a>其它文件系统自检</h4><p>fsck: 检查并修复Linux文件系统</p><pre><code>-t FSTYPE: 指定文件系统类型-a: 自动修复</code></pre><p>e2fsck: 专用于修复ext2&#x2F;ext3文件系统</p><pre><code>-f: 强制检查；-p: 自动修复；[root@localhost ~]# e2fsck /dev/sdb1e2fsck 1.42.9 (28-Dec-2013)filesystem: clean, 11/65536 files, 4443/262144 blocks</code></pre><h3 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h3><p>blkid: 查询或查看磁盘设备的相关属性 UUID、TYPE（文件系统）、LABEL</p><pre><code>[root@localhost ~]# blkid/dev/sda1: UUID=&quot;63389af9-2128-4b68-b072-0b3d7aaca50d&quot; TYPE=&quot;xfs&quot; /dev/sda2: UUID=&quot;UN0Ex0-C5Bz-oeCn-RbEP-RR1a-x79t-Ikyjh3&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb1: UUID=&quot;224f048a-76cf-4320-89b8-4458d6b96def&quot; TYPE=&quot;ext2&quot; /dev/sr0: UUID=&quot;2019-09-11-18-50-31-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; /dev/mapper/centos-root: UUID=&quot;827a53b1-31be-4ab8-b5a2-3310ee209a81&quot; TYPE=&quot;xfs&quot; /dev/mapper/centos-swap: UUID=&quot;f03a485d-b51a-4f0a-ad29-1262c359686f&quot; TYPE=&quot;swap&quot; </code></pre><p>e2label: 用于查看或定义卷标（应该只能查看ext格式的文件系统）</p><pre><code>e2label 设备文件 卷标: 设定卷标[root@localhost ~]# e2label /dev/sdb1 filesystem[root@localhost ~]# e2label /dev/sdb1filesystem</code></pre><p>tune2fs: 调整文件系统的相关属性</p><pre><code>-j: 不损害原有数据，将ext2升级为ext3；不能反方向执行-L LABEL: 设定或修改卷标; -m #: 调整预留百分比；（预留给超级用户）-r #: 指定预留块数；（预留给超级用户）-o: 设定默认挂载选项；    acl 开启文件系统acl选项-c #：指定挂载次数达到#次之后进行自检，0或-1表关闭此功能；-i #: 每挂载使用多少天后进行自检；0或-1表示关闭此功能；-l: 显示超级块中的信息；[root@localhost ~]# tune2fs -l /dev/sdb1tune2fs 1.42.9 (28-Dec-2013)Filesystem volume name:   filesystemLast mounted on:          &lt;not available&gt;Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96defFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_fileFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              65536Block count:              262144Reserved block count:     13107Free blocks:              257701Free inodes:              65525First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      63Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Filesystem created:       Sun Dec 26 07:12:40 2021Last mount time:          n/aLast write time:          Sun Dec 26 07:24:57 2021Mount count:              0Maximum mount count:      -1Last checked:             Sun Dec 26 07:12:40 2021Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:          256Required extra isize:     28Desired extra isize:      28Default directory hash:   half_md4Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4f</code></pre><p>dumpe2fs: 显示文件系统属性信息</p><pre><code>-h: 只显示超级块中的信息[root@localhost ~]# dumpe2fs /dev/sdb1dumpe2fs 1.42.9 (28-Dec-2013)Filesystem volume name:   filesystemLast mounted on:          &lt;not available&gt;Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96defFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_fileFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              65536Block count:              262144Reserved block count:     13107Free blocks:              257701Free inodes:              65525First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      63Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Filesystem created:       Sun Dec 26 07:12:40 2021Last mount time:          n/aLast write time:          Sun Dec 26 07:24:57 2021Mount count:              0Maximum mount count:      -1Last checked:             Sun Dec 26 07:12:40 2021Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:          256Required extra isize:     28Desired extra isize:      28Default directory hash:   half_md4Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4fGroup 0: (Blocks 0-32767)  Primary superblock at 0, Group descriptors at 1-1  Reserved GDT blocks at 2-64  Block bitmap at 65 (+65), Inode bitmap at 66 (+66)  Inode table at 67-578 (+67)  32183 free blocks, 8181 free inodes, 2 directories  Free blocks: 585-32767  Free inodes: 12-8192Group 1: (Blocks 32768-65535)  Backup superblock at 32768, Group descriptors at 32769-32769  Reserved GDT blocks at 32770-32832  Block bitmap at 32833 (+65), Inode bitmap at 32834 (+66)  Inode table at 32835-33346 (+67)  32189 free blocks, 8192 free inodes, 0 directories  Free blocks: 33347-65535  Free inodes: 8193-16384</code></pre><p>xfs_admin:修改xfs文件系统：</p><pre><code>[root@study ~]# xfs_admin [-lu] [-L label] [-U uuid] 设备文件名选项与参数：-l ：列出这个设备的 label name-u ：列出这个设备的 UUID-L ：设置这个设备的 Label name-U ：设置这个设备的 UUID 喔！范例：设置 /dev/vda4 的 label name 为 vbird_xfs，并测试挂载[root@study ~]# xfs_admin -L vbird_xfs /dev/vda4writing all SBsnew label = &quot;vbird_xfs&quot; # 产生新的 LABEL 名称啰！[root@study ~]# xfs_admin -l /dev/vda4label = &quot;vbird_xfs&quot;[root@study ~]# mount LABEL=vbird_xfs /data/xfs/范例：利用 uuidgen 产生新 UUID 来设置 /dev/vda4，并测试挂载[root@study ~]# umount /dev/vda4 # 使用前，请先卸载！[root@study ~]# uuidgene0fa7252-b374-4a06-987a-3cb14f415488 # 很有趣的指令！可以产生新的 UUID 喔！[root@study ~]# xfs_admin -u /dev/vda4UUID = e0a6af55-26e7-4cb7-a515-826a8bd29e90[root@study ~]# xfs_admin -U e0fa7252-b374-4a06-987a-3cb14f415488 /dev/vda4Clearing log and setting UUIDwriting all SBsnew UUID = e0fa7252-b374-4a06-987a-3cb14f415488[root@study ~]# mount UUID=e0fa7252-b374-4a06-987a-3cb14f415488 /data/x</code></pre><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载：将新的文件系统关联至当前根文件系统，挂载完成后，要通过挂载点访问对应文件系统上的文件；</p><p>卸载：将某文件系统与当前根文件系统的关联关系预以移除；</p><p>mount：挂载</p><pre><code>mount 设备 挂载点    设备：        设备文件：/dev/sda5        卷标：LABEL=“”        UUID： UUID=“”    挂载点：目录        要求：            1、此目录没有被其它进程使用；            2、目录得事先存在；            3、目录中的原有的文件将会暂时隐藏；mount [options] [-o options] DEVICE MOUNT_POINT    -a: 表示挂载/etc/fstab文件中定义的所有文件系统    -n: 默认情况下，mount命令每挂载一个设备，都会把挂载的设备信息保存至/etc/mtab文件；使用—n选项意味着挂载设备时，不把信息写入此文件；    -t FSTYPE: 指定正在挂载设备上的文件系统的类型；不使用此选项时，mount会调用blkid命令获取对应文件系统的类型；    -r: 只读挂载，挂载光盘时常用此选项    -w: 读写挂载        -o: 指定额外的挂载选项，也即指定文件系统启用的属性；        remount: 重新挂载当前文件系统        ro: 挂载为只读        rw: 读写挂载</code></pre><p>umount: 卸载某文件系统</p><pre><code>umount 设备umount 挂载点卸载注意事项：    挂载的设备没有进程使用；</code></pre><p>mount -o loop 文件地址 MOUNT_POINT: 挂载本地回环设备（比如iso文件）</p><p>文件系统的配置文件&#x2F;etc&#x2F;fstab  </p><pre><code>OS在初始时，会自动挂载此文件中定义的每个文件系统要挂载的设备挂载点文件系统类型挂载选项（文件系统选项）转储频率(每多少天做一次完全备份)文件系统检测次序(只有根可以为1)/dev/sda5/mnt/testext3defaults0 0文件系统参数：async/sync 非同步/同步        设置磁盘是否以非同步方式运行！默认为 async（性能较佳）auto/noauto 自动/非自动    当下达 mount -a 时，此文件系统是否会被主动测试挂载。默认为 auto。rw/ro 可读写/只读    让该分区以可读写或者是只读的型态挂载上来，如果你想要分享的数据是不给使用者随意变更的， 这里也能够设置为只读。则不论在此文件系统的文件是否设置 w 权限，都无法写入喔！exec/noexec可执行/不可执行    限制在此文件系统内是否可以进行“执行”的工作？如果是纯粹用来储存数据的目录, 那么可以设置为 noexec 会比较安全。不过，这个参数也不能随便使用，因为你不知道该目录下是否默认会有可执行文件。举例来说，如果你将 noexec 设置在 /var ，当某些软件将一些可执行文件放置于 /var 下时，那就会产生很大的问题喔！ 因此，建议这个 noexec 最多仅设置于你自订或分享的一般数据目录。user/nouser允许/不允许    使用者挂载是否允许使用者使用 mount指令来挂载呢？一般而言，我们当然不希望一般身份的 user 能使用 mount 啰，因为太不安全了，因此这里应该要设置为 nouser 啰！suid/nosuid具有/不具有suid 权限    该文件系统是否允许 SUID 的存在？如果不是可执行文件放置目录，也可以设置为 nosuid 来取消这个功能！defaults 同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。默认情况使用 defaults 设置即可！</code></pre><p>mount -a：挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统  </p><p>fuser: 验正进程正在使用的文件或套接字文件  </p><pre><code>-v: 查看某文件上正在运行的进程-k: 杀死访问进程的文件-m: 指定MOUNT_POINTfuser -km MOUNT_POINT：终止正在访问此挂载点的所有进程</code></pre><h3 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h3><p>Swap（交换分区）：把不常访问的内存先写到磁盘中，然后释放这些内存，给其它更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</p><p>free :查看内存容量  </p><pre><code>-m ：以M为单位显示-g ：以g为单位显示-h ：单位换算[demo@localhost ~]$ free -h              total        used        free      shared  buff/cache   availableMem:           972M        625M        122M         16M        225M        191MSwap:          2.0G         51M        1.9Gfree是真正尚未被使用的物理内存数量。avaliable是从应用程序的角度看到的可用内存数量。Linux内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的buffer和cache。所以对于内核来说，buffer和cache都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的free内存可以用，内核就会从buffer和cache中回收内存来满足应用程序的请求。</code></pre><h4 id="创建swap实体分区"><a href="#创建swap实体分区" class="headerlink" title="创建swap实体分区"></a>创建swap实体分区</h4><ol><li><p>在硬盘中创建Swap分区</p></li><li><p>调整Swap分区类型为82</p><pre><code>fdisk 调整分区类型为 82gdisk 调整为8200</code></pre></li><li><p>开始创建Swap格式</p><pre><code> mkswap /dev/sda8  创建交换分区：      -L LABEL [root@localhost ~]# free          total        used        free      shared  buff/cache   availableMem:         995748      648288       73440       17184      274020      187264Swap:       2097148       51976     2045172</code></pre></li><li><p>开启Swap分区</p><pre><code> swapon /dev/sda8  开启交换分区 -a: 启用所有的定义在/etc/fstab文件中的交换设备 -s: 查看交换分区由哪些文件或者分区组成 [root@localhost ~]# swapon /dev/sdb5 [root@localhost ~]# free -h total        used        free      shared  buff/cache   available Mem:           972M        633M         71M         16M        267M        182M Swap:          3.0G         50M        3.0G [root@localhost var]# swapon -s FilenameType Size UsedPriority /dev/dm-1              partition   2097148 30652   -2 /var/swapfile           file   1048572   0      -3</code></pre></li></ol><p>swapoff &#x2F;dev&#x2F;sda8 关闭交换分区  </p><h4 id="创建swap文件分区"><a href="#创建swap文件分区" class="headerlink" title="创建swap文件分区"></a>创建swap文件分区</h4><p>如何在一个分区中创建一个文件，并把它添加到swap交换分区中  </p><blockquote><p>回环设备loopback, 使用软件来模拟实现硬件</p></blockquote><p>dd ： 读取、转换并输出数据</p><pre><code>if=数据来源of=数据存储目标bs=1 读取或输出的块大小count=2 拷贝多少个块seek=#: 创建数据文件时，创建文件跳过的空间大小dd if=/dev/sda of=/mnt/usb/mbr.backup bs=512 count=1dd if=/mnt/usb/mbr.backup of=/dev/sda bs=512 count=1</code></pre><p>首先，创建一个镜像文件：&#x2F;dev&#x2F;zero 读出的都是0</p><pre><code>dd if=/dev/zero of=/var/swapfile bs=1M count=1024 </code></pre><p>其次，将文件创建为swap分区</p><pre><code>[root@localhost var]# mkswap /var/swapfile Setting up swapspace version 1, size = 1048572 KiBno label, UUID=86213827-3a91-4171-9892-e9c8efd42e2b</code></pre><p>最后，开启swap分区文件</p><pre><code>[root@localhost var]# swapon /var/swapfileswapon: /var/swapfile: insecure permissions 0644, 0600 suggested.[root@localhost var]# free -h              total        used        free      shared  buff/cache   availableMem:           972M        631M         67M         16M        274M        182MSwap:          3.0G         50M        3.0G</code></pre><h3 id="xfs文件备份与还原"><a href="#xfs文件备份与还原" class="headerlink" title="xfs文件备份与还原"></a>xfs文件备份与还原</h3><h4 id="xfsdump备份"><a href="#xfsdump备份" class="headerlink" title="xfsdump备份"></a>xfsdump备份</h4><p>xfsdumcp是xfs文件系统备份工具，可以进行完整备份和增量备份。同时xfsdumcp是通过文件系统的UUID来分辨各个备份文件的，因此不能备份两个具有相同UUID的文件系统。</p><pre><code>[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据选项与参数：-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ （默认为 0，即完整备份）-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 设备文件名或其他一般文件文件名等-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态</code></pre><p>完整备份</p><pre><code># 1\. 先确定 /boot 是独立的文件系统喔！[root@study ~]# df -h /bootFilesystem Size Used Avail Use% Mounted on/dev/vda2 1014M 131M 884M 13% /boot # 挂载 /boot 的是 /dev/vda 设备！# 看！确实是独立的文件系统喔！ /boot 是挂载点！# 2\. 将完整备份的文件名记录成为 /srv/boot.dump ：[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /bootxfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /bootxfsdump: using file dump （drive_simple） strategyxfsdump: version 3.1.4 （dump format 3.0） - type ^C for status and controlxfsdump: level 0 dump of study.centos.vbird:/boot # 开始备份本机/boot系统xfsdump: dump date: Wed Jul 1 18:43:04 2015 # 备份的时间xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1 # 这次dump的IDxfsdump: session label: &quot;boot_all&quot; # 简单给予一个名字记忆xfsdump: ino map phase 1: constructing initial dump list # 开始备份程序xfsdump: ino map phase 2: skipping （no pruning necessary）xfsdump: ino map phase 3: skipping （only one dump stream）xfsdump: ino map construction completexfsdump: estimated dump size: 103188992 Bytesxfsdump: creating dump session media file 0 （media 0, file 0）xfsdump: dumping ino mapxfsdump: dumping directoriesxfsdump: dumping non-directory filesxfsdump: ending media filexfsdump: media file size 102872168 Bytesxfsdump: dump size （non-dir files） : 102637296 Bytesxfsdump: dump complete: 1 seconds elapsedxfsdump: Dump Summary:xfsdump: stream 0 /srv/boot.dump OK （success）xfsdump: Dump Status: SUCCESS# 在指令的下达方面，你也可以不加 -L 及 -M 的，只是那就会进入互动模式，要求你 enter！# 而执行 xfsdump 的过程中会出现如上的一些讯息，您可以自行仔细的观察！[root@study ~]# ll /srv/boot.dump-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump[root@study ~]# ll /var/lib/xfsdump/inventory-rw-r--r--. 1 root root 5080 Jul 1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj-rw-r--r--. 1 root root 312 Jul 1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex-rw-r--r--. 1 root root 576 Jul 1 18:43 fstab# 使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔！</code></pre><p>累积备份</p><pre><code># 0\. 看一下有没有任何文件系统被 xfsdump 过的数据？[root@study ~]# xfsdump -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:43:04 2015session label: &quot;boot_all&quot;session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1level: 0resumed: NOsubtree: NOstreams: 1stream 0:pathname: /srv/boot.dumpstart: ino 132 offset 0end: ino 2138243 offset 0interrupted: NOmedia files: 1media file 0:mfile index: 0mfile type: datamfile size: 102872168mfile start: ino 132 offset 0mfile end: ino 2138243 offset 0media label: &quot;boot_all&quot;media id: a6168ea6-1ca8-44c1-8d88-95c863202eabxfsdump: Dump Status: SUCCESS# 我们可以看到目前仅有一个 session 0 的备份数据而已！而且是 level 0 喔！# 1\. 先恶搞一下，创建一个大约 10 MB 的文件在 /boot 内：[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=1010+0 records in10+0 records out10485760 Bytes （10 MB） copied, 0.166128 seconds, 63.1 MB/s# 2\. 开始创建差异备份文件，此时我们使用 level 1 吧：[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot....（中间省略）....[root@study ~]# ll /srv/boot*-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump-rw-r--r--. 1 root root 10510952 Jul 1 18:46 /srv/boot.dump1# 看看文件大小，岂不是就是刚刚我们所创建的那个大文件的容量吗？ ^_^# 3\. 最后再看一下是否有记录 level 1 备份的时间点呢？[root@study ~]# xfsdump -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2....（中间省略）....session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1resumed: NOsubtree: NOstreams: 1stream 0:pathname: /srv/boot.dump1start: ino 455518 offset 0....（下面省略）....</code></pre><h4 id="xfsrestore还原"><a href="#xfsrestore还原" class="headerlink" title="xfsrestore还原"></a>xfsrestore还原</h4><pre><code>[root@study ~]# xfsrestore -I &amp;lt;==用来察看备份文件数据[root@study ~]# xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录 &amp;lt;==单一文件全系统复原[root@study ~]# xfsrestore [-f 备份文件] -r 待复原目录 &amp;lt;==通过累积备份文件来复原系统[root@study ~]# xfsrestore [-f 备份文件] -i 待复原目录 &amp;lt;==进入互动模式选项与参数：-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等-f ：后面接的就是备份文件！企业界很有可能会接 /dev/st0 等磁带机！我们这里接文件名！-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，需要这东西来达成累积复原-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！</code></pre><p>用xfsrestore查看xfsdump备份数据</p><pre><code>[root@study ~]# xfsrestore -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:43:04 2015session label: &quot;boot_all&quot;session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1level: 0pathname: /srv/boot.dumpmfile size: 102872168media label: &quot;boot_all&quot;session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1pathname: /srv/boot.dump1mfile size: 10510952media label: &quot;boot_2&quot;xfsrestore: Restore Status: SUCCESS</code></pre><p>完全备份还原</p><pre><code># 1\. 直接将数据给它还原回去即可！[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/bootxfsrestore: using file dump （drive_simple） strategyxfsrestore: version 3.1.4 （dump format 3.0） - type ^C for status and controlxfsrestore: using online session inventoryxfsrestore: searching media for directory dumpxfsrestore: examining media file 0xfsrestore: reading directoriesxfsrestore: 8 directories and 327 entries processedxfsrestore: directory post-processingxfsrestore: restoring non-directory filesxfsrestore: restore complete: 1 seconds elapsedxfsrestore: Restore Summary:xfsrestore: stream 0 /srv/boot.dump OK （success） # 是否是正确的文件啊？xfsrestore: Restore Status: SUCCESS如果只想要复原某一个目录或文件的话，直接加上“ -s 目录 ”这个选项与参数即可！</code></pre><p>部分备份还原</p><pre><code># 继续复原 level 1 到 /tmp/boot 当中！[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot</code></pre><p>仅还原部分文件的 xfsrestore 互动模式</p><pre><code># 1\. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！[root@study ~]# mkdir /tmp/boot3[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3========================== subtree selection dialog ==========================the following commands are available:pwdls [ &amp;lt;path&amp;gt; ]cd [ &amp;lt;path&amp;gt; ]add [ &amp;lt;path&amp;gt; ] # 可以加入复原文件列表中delete [ &amp;lt;path&amp;gt; ] # 从复原列表拿掉文件名！并非删除喔！extract # 开始复原动作！quithelp-&amp;gt; ls455517 initramfs-3.10.0-229.el7.x86_64kdump.img138 initramfs-3.10.0-229.el7.x86_64.img141 initrd-plymouth.img140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img137 vmlinuz-3.10.0-229.el7.x86_64136 symvers-3.10.0-229.el7.x86_64.gz135 config-3.10.0-229.el7.x86_64134 System.map-3.10.0-229.el7.x86_64133 .vmlinuz-3.10.0-229.el7.x86_64.hmac1048704 grub2/131 grub/-&amp;gt; add grub-&amp;gt; add grub2-&amp;gt; add config-3.10.0-229.el7.x86_64-&amp;gt; extract[root@study ~]# ls -l /tmp/boot3-rw-r--r--. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64drwxr-xr-x. 2 root root 26 May 4 17:52 grubdrwxr-xr-x. 6 root root 104 Jun 25 00:02 grub2# 就只会有 3 个文件名被复原，当然，如果文件名是目录，那下面的子文件当然也会被还原回来的！</code></pre><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>RAID中文名称为独立磁盘冗余阵列，简称为磁盘阵列。简单的说，RAID是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。RAID的主要优势有如下几点：大容量、高性能、可靠性、可管理性（它将多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器）。实现RAID的关键技术为镜像、数据条带、数据校验技术。RAID的每种级别仅代表磁盘组织方式不同，没有上下之分。  </p><p>一般来说， RAID 不可作为数据备份的替代方案，它对非磁盘故障等造成的数据丢失无能为力，比如病毒、人为破坏、意外删除等情形。此时的数据丢失是相对操作系统、文件系统、卷管理器或者应用系统来说的，对于 RAID 系统来身，数据都是完好的，没有发生丢失。所以，数据备份、灾 备等数据保护措施是非常必要的，与 RAID 相辅相成，保护数据在不同层次的安全性，防止发生数据丢失。</p><p>从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及软硬混合 RAID 三种。软 RAID 所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片，效率自然最低。硬 RAID 配备了专门的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片以及阵列缓冲，不占用 CPU 资源，但成本很高。软硬混合 RAID 具备 RAID 控制 &#x2F; 处理芯片，但缺乏 I&#x2F;O 处理芯片，需要 CPU 和驱动程序来完成，性能和成本 在软 RAID 和硬 RAID 之间。不建议使用软RAID。</p><p>常见raid级别如下，具体可参见文章<a href="https://blog.csdn.net/ensp1/article/details/81318135">https://blog.csdn.net/ensp1/article/details/81318135</a>，以上关于raid内容也是摘取自这篇文章。</p><h4 id="raid-0"><a href="#raid-0" class="headerlink" title="raid 0"></a>raid 0</h4><p>raid 0基于条带化技术。将数据按照stripe大小切分之后存放到各磁盘中</p><p><img src="https://img-blog.csdnimg.cn/20200701102411750.png" alt="image"></p><pre><code>    性能提升: 读，写    冗余能力（容错能力）: 无    空间利用率：nS    至少2块盘</code></pre><h4 id="raid-1"><a href="#raid-1" class="headerlink" title="raid 1"></a>raid 1</h4><p>raid 1基于镜像技术。将数据复制为N份存放到各磁盘中。</p><p><img src="https://img-blog.csdnimg.cn/20200701102427735.png" alt="image"></p><pre><code>    性能表现：写性能下降，读性能提升    冗余能力：有    空间利用率：1/2    至少2块盘</code></pre><h4 id="raid-5"><a href="#raid-5" class="headerlink" title="raid 5"></a>raid 5</h4><p>raid 5采用的是条带化和校验技术。将数据按照stripe大小切分并且计算数据校验信息然后分别存放到各磁盘中。当一个磁盘损坏后可以根据其它磁盘数据进行恢复，而且该技术中校验信息不是存放到固定磁盘中的。</p><p><img src="https://img-blog.csdnimg.cn/20200701102535811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vuc3Ax,size_16,color_FFFFFF,t_70" alt="image"></p><pre><code>    性能表现：读，写提升    冗余能力：有    空间利用率：(n-1)/n    至少需要3块</code></pre><p>raid 5 并发问题<a href="https://forum.huawei.com/enterprise/zh/thread/580916590801731584">https://forum.huawei.com/enterprise/zh/thread/580916590801731584</a></p><h4 id="raid10"><a href="#raid10" class="headerlink" title="raid10"></a>raid10</h4><p>raid 10 从下往上是先采用raid 1的镜像技术，再采用raid 0 的条带化技术。</p><p><img src="https://img-blog.csdnimg.cn/2020070110262565.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：1/2    至少需要4块</code></pre><h4 id="raid-01"><a href="#raid-01" class="headerlink" title="raid 01"></a>raid 01</h4><p>raid 01 从下往上是先采用raid 0的条带化技术，再采用raid 1的镜像技术。<br><img src="https://img-blog.csdnimg.cn/20200701102612237.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：1/2    至少需要4块</code></pre><h4 id="raid-50"><a href="#raid-50" class="headerlink" title="raid 50"></a>raid 50</h4><p>raid 50 从下往上是先采用raid 5技术，再采用raid 0 技术。<br><img src="https://img-blog.csdnimg.cn/20200701102710274.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：(n-2)/n    至少需要6块</code></pre><h4 id="jbod"><a href="#jbod" class="headerlink" title="jbod"></a>jbod</h4><p>jbod并不是一个raid技术，它仅仅只是将几个磁盘组成一个大的存储设备。</p><p><img src="https://img-blog.csdnimg.cn/20200701102345894.png" alt="image"></p><pre><code>    性能表现：无提升    冗余能力：无    空间利用率：100%    至少需要2块</code></pre><h4 id="软件raid练习"><a href="#软件raid练习" class="headerlink" title="软件raid练习"></a>软件raid练习</h4><p>以下我们使用逻辑RAID作为练习，软件RAID在Linux中的设备名为&#x2F;dev&#x2F;md</p><p>mdadm：将任何块设备做成RAID </p><pre><code>模式化的命令：    创建模型        -C             专用选项：                -l: 级别                -n #: 设备个数（raid使用的磁盘数量）                -a &#123;yes|no&#125;: 是否自动为其创建设备文件                -c: CHUNK大小, 2^n，默认为64K                -x #: 指定空闲盘个数    管理模式        --add,         --remove,         --fail        mdadm /dev/md# --fail /dev/sda7    监控模式        -F：    增长模式        -G：    装配模式        -A:</code></pre><p>查看RAID阵列的详细信息</p><pre><code>mdadm -D /dev/md#    --detail</code></pre><p>停止阵列：</p><pre><code>mdadm -S /dev/md#    --stop</code></pre><p>将当前RAID信息保存至配置文件，以便以后进行装配：</p><pre><code>mdamd -D --scan &gt; /etc/mdadm.conf</code></pre><p>使用软raid操作如下：</p><pre><code>1. 在磁盘/dev/sdb上创建四个磁盘分区（6，7,8,9），每个分区的类型修改为fd[root@localhost var]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nAll primary partitions are in useAdding logical partition 6First sector (8394752-41943039, default 8394752): Using default value 8394752Last sector, +sectors or +size&#123;K,M,G&#125; (8394752-41943039, default 41943039): +1GPartition 6 of type Linux and of size 1 GiB is setCommand (m for help): tPartition number (1-8, default 8): fdPartition number (1-8, default 8): 6Hex code (type L to list all codes): fdChanged type of partition &#39;Linux&#39; to &#39;Linux raid autodetect&#39;2. 使用mdadm命令创建raid[root@localhost dev]# mdadm -C /dev/md0 -l 1 -n 2 -a yes -x 1 /dev/sdb&#123;6,7,8&#125;mdadm: Note: this array has metadata at the start and    may not be suitable as a boot device.  If you plan to    store &#39;/boot&#39; on this device please ensure that    your boot-loader understands md/v1.x metadata, or use    --metadata=0.90   （软raid不能作为启动分区）Continue creating array? Continue creating array? (y/n) ymdadm: Defaulting to version 1.2 metadatamdadm: array /dev/md0 started.[root@localhost dev]# ll -d /dev/md*brw-rw----. 1 root disk 9, 0 Jan  1 04:42 /dev/md03. 在raid上创建文件系统[root@localhost dev]# mke2fs /dev/md0mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65408 inodes, 261632 blocks13081 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8176 inodes per groupSuperblock backups stored on blocks:     32768, 98304, 163840, 229376Allocating group tables: done                            Writing inode tables: done                            Writing superblocks and filesystem accounting information: done4. 挂载文件系统[root@localhost dev]# mount /dev/md0 /mnt5. 拷贝并查看文件[root@localhost mnt]# cp /etc/inittab ./[root@localhost mnt]# lltotal 20-rw-r--r--. 1 root root   511 Jan  1 04:47 inittabdrwx------. 2 root root 16384 Jan  1 04:46 lost+found[root@localhost mnt]# cat inittab # inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM....6. 查看raid信息[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:           Version : 1.2     Creation Time : Sat Jan  1 04:42:17 2022        Raid Level : raid1        Array Size : 1046528 (1022.00 MiB 1071.64 MB)     Used Dev Size : 1046528 (1022.00 MiB 1071.64 MB)      Raid Devices : 2     Total Devices : 3       Persistence : Superblock is persistent       Update Time : Sat Jan  1 04:47:39 2022             State : clean     Active Devices : 2   Working Devices : 3    Failed Devices : 0     Spare Devices : 1Consistency Policy : resync              Name : localhost.localdomain:0  (local to host localhost.localdomain)              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72            Events : 17    Number   Major   Minor   RaidDevice State       0       8       22        0      active sync   /dev/sdb6       1       8       23        1      active sync   /dev/sdb7       2       8       24        -      spare   /dev/sdb87. 查看raid状态    cat /proc/mdstat8. 将sdb6标识为损坏[root@localhost mnt]# mdadm /dev/md0 --fail /dev/sdb6mdadm: set /dev/sdb6 faulty in /dev/md0[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                    ...                    ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       0       8       22        -      faulty   /dev/sdb69. 在raid中移除sdb6[root@localhost mnt]# mdadm /dev/md0 --remove /dev/sdb6mdadm: hot removed /dev/sdb6 from /dev/md0[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                        ...                        ...Consistency Policy : resync              Name : localhost.localdomain:0  (local to host localhost.localdomain)              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72            Events : 37    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb710. 查看文件[root@localhost mnt]# cat inittab     # inittab is no longer used when using systemd.    #    # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.    ...  11. 在raid中添加磁盘[root@localhost mnt]# mdadm /dev/md0 --add /dev/sdb9mdadm: added /dev/sdb9[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                            ...                            ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       3       8       25        -      spare   /dev/sdb912. 停止raid[root@localhost /]# umount /dev/md0[root@localhost /]# mdadm -S /dev/md0mdadm: stopped /dev/md013. 重新挂载停止的raid[root@localhost /]# mdadm -A /dev/md0 /dev/sdb&#123;7,8,9&#125;mdadm: /dev/md0 has been started with 2 drives and 1 spare.[root@localhost /]# mdadm -D /dev/md0/dev/md0:                        ...                    ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       3       8       25        -      spare   /dev/sdb9 14. 查看文件 [root@localhost mnt]# cat inittab  # inittab is no longer used when using systemd. # # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.                         ... 15. 增长模式（将raid的热备磁盘增加到阵列工作磁盘中） mdadm -G /dev/md0 -n 4</code></pre><p>watch: 周期性地执行指定命令，并以全屏方式显示结果  </p><pre><code>-n #：指定周期长度，单位为秒，默认为2格式： watch -n # &#39;COMMAND&#39;</code></pre><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>LVM是逻辑卷管理，它是Linux下磁盘分区的一种管理机制。该功能可以实现用户在无需停机的情况下可以调整各个分区的大小。</p><ul><li>PV(物理卷): 对应于我们的实体分区或硬盘</li><li>VG(卷  组): PV的组合</li><li>LV(逻辑卷): VG会被切成LV.这个LV就是最后格式化后给用户使用的。</li><li>PE(物理盘区): LVM管理的基础存储单元。LVM会把PV分成一个个PE进行存储。</li></ul><p>VG(卷组)的边界大小取决于PV(物理卷)组合的大小。</p><p>虽然PV组合成了VG，但是要真正使用就要划分LV(逻辑卷).在VG上可以划分多个LV，但这多个LV的大小加起来的和不能超过VG。如果发现VG不够用了，可以增加PV（物理卷），如果LV中空间不足可以扩大LV。</p><p>对卷创建快照，实际上就是对逻辑卷创建快照，而快照卷必须和逻辑卷处于同一个卷组中。也就意味这，如果你要打算对某个LV逻辑卷创建快照，就必须在同一个卷组中预留出空间给其中的某个逻辑卷创建快照卷。</p><blockquote><p>为什么能够实现VG的扩展以及LV的扩展？其实将PV放入VG时就要把PV这个物理卷的所有空间划分成一个物理块，及一个个存储单元。 这个块不是文件系统块，而是PE(PhysicalExtend物理盘区)，只要物理卷加入VG后，新加卷中划分的PE一定是和VG原因的PE大小相同。所以在创建VG时要制定VG所使用多大的PE。</p></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>【MD】:Multi Device 多设备</p><p>Mdadm是一个用户空间工具，是RAID的管理工具，与真正的RAID工作没有太大关系。真正的RAID集成在linux内核中</p><p>【DM】Device Mapper设备映射也是linux中一种常用的管理机制</p><p>DM 与MD近似，也能够提供一种逻辑设备。DM比MD的功能要强大。因为DM不仅仅能提供MD的RAID的功能，它还是逻辑卷（LVM2）基础。同时，在逻辑卷的基础上我们也能实现RAID0,RAID1这样的功能。DM与MD中有某些功能是重叠的，但并不完全重叠。所以，我们通常使用MD做RAID用DM做LVM2。DM像MD一样也是有一个核心模块，和许多子模块组成的。例如MD的核心有RAID0,RAID1,RAID5,RAID1+0等，由多个子模块完成不同的级别。DM也是有多个子模块完成不同的组织方式。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB89700cb2e26795cf3122f1060d00709e?method=download&shareKey=69125b23b714204d3f30cced62ae321b" alt="image"></p><p>例如：</p><ul><li>linear:有点类似Jbod。能够将多个磁盘的存储空间拼接在一块，当做一个磁盘来使用。</li><li>mirror:类似于镜像。</li><li>Snapshot：快照，向虚拟机一样，能够保留数据在做快照那一刻时的状态。快照，也可以说是访问同一条数据的另外一条路径。（主要用途是数据备份）</li><li>Multipath：多路径。多路径需要借助于DM模块来配置，能够实现数据存储设备的寻路能够通过多跟不同线来完成。</li></ul><h3 id="LVM使用流程"><a href="#LVM使用流程" class="headerlink" title="LVM使用流程"></a>LVM使用流程</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd1ecce605925715ca45bf008c7828c25?method=download&shareKey=40e1bb6104763d539a75435d5898d461" alt="image"></p><h3 id="LVM相关操作"><a href="#LVM相关操作" class="headerlink" title="LVM相关操作"></a>LVM相关操作</h3><p><a href="https://www.cnblogs.com/klb561/p/9074168.html">https://www.cnblogs.com/klb561/p/9074168.html</a></p><p>练习：<br>1、创建一个2G的分区，文件系统为ext2，卷标为DATA，块大小为1024，预留管理空间为磁盘分区的8%；挂载至&#x2F;backup目录，要求使用卷标进行挂载，且在挂载时启动此文件系统上的acl功能；</p><pre><code># mke2fs -L DATA -b 1024 -m 8  /dev/sda7# mount -o acl LABEL=DATA /backup# tune2fs -o acl /dev/sda7# mount LABEL=DATA /backup</code></pre><p>2、将此文件系统的超级块中的信息中包含了block和inode的行保存至&#x2F;tmp&#x2F;partition.txt中；</p><pre><code># tune2fs -l | egrep -i  &quot;block|inode&quot; &gt;&gt; /tmp/partition.txt  # dumpe2fs -h |</code></pre><p>3、复制&#x2F;etc目录中的所有文件至此文件系统；而后调整此文件系统类型为ext3，要求不能损坏已经复制而来的文件；</p><pre><code># cp -r /etc/*  /backup# tune2-j /dev/sda7</code></pre><p>4、调整其预留百分比为3%；</p><pre><code># tune2fs -m 3 -L DATA /dev/sda7</code></pre><p>5、以重新挂载的方式挂载此文件系统为不更新访问时间戳(表示在读文件时不去更改文件的access time属性），并验正其效果；</p><pre><code># stat /backup/inittab# cat /backup/inittab# stat # mount -o remount,noatime /backup# cat # stat</code></pre><p>6、对此文件系统强行做一次检测；</p><pre><code>e2fsck -f /dev/sda7</code></pre><p>7、删除复制而来的所有文件，并将此文件系统重新挂载为同步(sync)；而后再次复制&#x2F;etc目录中的所有文件至此挂载点，体验其性能变化；</p><pre><code># rm -rf /backup/*# mount -o remount,sync /backup# cp -r /etc/* /backup</code></pre><p>8、创建一个5G的分区，文件系统为ext3，卷标为MYDATA，块大小为1024，预留管理空间为磁盘分区的3%，要求开机后可以自动挂载至&#x2F;data目录，并且自动挂载的设备要使用卷标进行引用；</p><p>9、创建一个本地回环文件&#x2F;var&#x2F;swaptemp&#x2F;swapfile来用于swap，要求大小为512MB，卷标为SWAP-FILE，且开机自动启用此交换设备；</p><pre><code># mkdir /var/swaptemp# dd if=/dev/zero of=/var/swaptemp/swapfile bs=1M count=512# mkswap LABLE=SWAP-FILE /var/swaptemp/swapfile/etc/fstab/var/swaptemp/swapfile  swapswapdefaults0 0</code></pre><p>10、上述第一问，如何让其自动挂载的同时启用ACL功能；</p><pre><code>/etc/fstabLABEL=&#39;MYDATA&#39;/dataext3defaults,acl0 0</code></pre><p>11、 创建一个空间大小为10G的RAID5设备；其chuck大小为32k；要求此设备开机时可以自动挂载至&#x2F;backup目录；</p><p>12、练习：创建一个由两个物理卷组成的大小为20G的卷组myvg，要求其PE大小为16M；而后在此卷组中创建一个大小为5G的逻辑卷lv1，此逻辑卷要能在开机后自动挂载至&#x2F;users目录，且支持ACL功能；</p><p>13、缩减前面创建的逻辑卷lv1的大小至2G；</p><p>写一个脚本(前提：请为虚拟机新增一块硬盘，假设它为&#x2F;dev&#x2F;sdb)，为指定的硬盘创建分区： </p><p>1、列出当前系统上所有的磁盘，让用户选择，如果选择quit则退出脚本；如  果用户选择错误，就让用户重新选择；</p><p>2、当用户选择后，提醒用户确认接下来的操作可能会损坏数据，并请用户确认；如果用户选择y就继续，n就退出；否则，让用户重新选择；  </p><p>3、抹除那块硬盘上的所有分区(提示，抹除所有分区后执行sync命令，并让脚本睡眠3秒钟后再分区)；并为其创建三个主分区，第一个为20M，第二个为512M, 第三个为128M，且第三个为swap分区类型；(提示：将分区命令通过echo传送给fdisk即可实现)  </p><pre><code>fdisk -l |grep &quot;dd if=/dev/zero of=/dev/sdb bs=512 count=1sync （程序在运行过程中会先修改内存，到达一定限制后才会从内存写入磁盘。此命令就是将内存中的改变写入磁盘）sleep 3（dd修改硬盘速度很快，防止磁盘接受指令过快导致不识别）</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p> 本文介绍了磁盘的组成、磁盘分区、文件系统、swap分区、xfs文件系统的备份和还原、raid、lvm相关内容。<p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 请描述一下MBR和GPT是什么？</p><p>3. CentOS7 为啥将默认文件系统改为xfs</p><p>4. raid？raid0？ raid1？ raid5？raid01？ raid10？</p><p>5. LVM的作用？LVM的组成？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 马哥Linux运维课程</p> <p>2. 鸟哥Linux私房菜-基础版</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="LVM" scheme="http://example.com/tags/LVM/"/>
    
    <category term="RAID" scheme="http://example.com/tags/RAID/"/>
    
    <category term="XFS" scheme="http://example.com/tags/XFS/"/>
    
    <category term="MBR" scheme="http://example.com/tags/MBR/"/>
    
    <category term="GPT" scheme="http://example.com/tags/GPT/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://example.com/2022/11/25/Linux-basic/"/>
    <id>http://example.com/2022/11/25/Linux-basic/</id>
    <published>2022-11-25T09:16:13.689Z</published>
    <updated>2022-11-25T09:16:13.688Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册</p></div><h2 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title="Linux的基本原则"></a>Linux的基本原则</h2><ul><li>一些皆文件</li><li>配置文件保存为纯文本格式</li><li>由目的单一的小程序组成，组合小程序完成复杂任务</li><li>尽量避免捕获用户接口（尽量减少与用户交互，比如如果命令运行成功则不会显示任何信息，没有消息是最好的消息）</li></ul><h2 id="Linux交互"><a href="#Linux交互" class="headerlink" title="Linux交互"></a>Linux交互</h2><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><p>Shell是用户和操作系统进行交互的软件。在Linux中它分为如下类型：  </p><blockquote><ul><li>GUI（图形界面交互）  <ul><li>Gnode  </li><li>KDE  </li><li>XFace</li></ul></li><li>CLI（命令行交互）  <ul><li>sh</li><li>bash</li><li>csh</li><li>zsh</li><li>ksh</li><li>tcsh</li></ul></li></ul></blockquote><p> 使用bash登陆Linux后会显示命令提示符（prompt）：</p><pre><code>[root@localhost ~]#    </code></pre><p>其中root是用户名，localhost是主机名，~代表家目录（&#x2F;代表根目录），#代表管理员（$代表普通用户）  </p><blockquote><p>虚拟终端(terminal)：Ctrl+Alt+F1-F6。Linux中有六个虚拟终端，每个虚拟终端都是一个Shell程序。一个用户可以在多个虚拟终端中同时登陆互不影响。CentOS 7之前可以使用init 3命令将图形shell转换为命令行Shell，使用init 5则相反。CentOS 7之后使用systemctl isolate multi-user.target或者systemctl isolate graphical.target切换</p></blockquote><h3 id="bash特性"><a href="#bash特性" class="headerlink" title="bash特性"></a>bash特性</h3><p>1、命令历史、命令补全 </p><pre><code>  history：查看命令历史 -c：清空命令历史 -d OFFSET [n]: 删除指定位置的命令 -w：保存命令历史至历史文件中  HISTSIZE环境变量: 命令历史缓冲区大小 ~/.bash_history：命令历史文件路径 命令历史的使用技巧：  !n      ：执行命令历史中的第n条命令； !-n     :执行命令历史中的倒数第n条命令；  !!      : 执行上一条命令； !string ：执行命令历史中最近一个以指定字符串开头的命令 !$      :引用前一个命令的最后一个参数;  Esc, .  :引用前一个命令的最后一个参数，先按Esc，再按.； Alt+. :引用前一个命令的最后一个参数，只在linux终端中可以； 命令、路径补全： 命令补全：搜索PATH环境变量所指定的每个路径下以我们给出的字符串开头的可执行文件，如果多于一个，两次tab，可以给出列表；否则将直接补全； 路径补全：搜索我们给出的起始路径下的每个文件名，并试图补全；</code></pre><p>2、管道、重定向<br>3、命令别名  </p><pre><code>alias CMDALIAS=&#39;COMMAND [options] [arguments]&#39; 定义别名在shell中定义的别名仅在当前shell生命周期中有效；别名的有效范围仅为当前shell进程；ualias CMDALIAS 解除别名\CMD ： 执行原命令</code></pre><p>4、命令行编辑  </p><pre><code>光标跳转：  Ctrl+a：跳到命令行首Ctrl+e：跳到命令行尾Ctrl+u: 删除光标至命令行首的内容Ctrl+k: 删除光标至命令行尾的内容Ctrl+l: 清屏</code></pre><p>5、命令行展开  </p><pre><code>命令替换: $(COMMAND), 反引号：`COMMAND`把命令中某个子命令替换为其执行结果的过程,如：：file-2013-02-28-14-53-31.txtbash支持的引号：``: 命令替换&quot;&quot;: 弱引用，可以实现变量替换&#39;&#39;: 强引用，不完成变量替换命令行展开：&#123;a,d&#125;_&#123;b,c&#125;mkdir -pv /mnt/test/&#123;x/m,y&#125;cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>6、文件名通配  </p><pre><code> globbing *: 任意长度的任意字符 ?：任意单个字符 []：匹配指定范围内的任意单个字符     [abc], [a-m], [a-z], [A-Z], [0-9], [a-zA-Z], [0-9a-zA-Z]     [:space:]：空白字符     [:punct:]：标点符号     [:lower:]：小写字母     [:upper:]: 大写字母     [:alpha:]: 大小写字母     [:digit:]: 数字     [:alnum:]: 数字和大小写字母  # man 7 glob  [^]: 匹配指定范围之外的任意单个字符  [[:alpha:]]*[[:space:]]*[^[:alpha:]]  注：文件通配符并不能匹配所有情况，比如：显示所有以数字结尾且文件名中不包含空白的文件；ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>7、变量<br>8、编程  </p><blockquote><p>注：&#x2F;etc&#x2F;shells：指定了当前系统可用的安全shell  </p></blockquote><div class="note green icon-padding flat"><p>练习：</p><p>1、创建a123, cd6, c78m, c1 my, m.z, k 67, 8yu, 789等文件；注意，以上文件是以逗号隔开的，其它符号都是文件名的组成部分；  </p><p>2、显示所有以a或m开头的文件；  </p><pre><code>ls [am]*  </code></pre><p>3、显示所有文件名中包含了数字的文件； </p> <pre><code>ls *[0-9]*   ls *[[:digit:]]*  </code></pre><p>4、显示所有以数字结尾且文件名中不包含空白的文件； </p> <pre><code>ls *[^[:space:]]*[0-9]   ?????????  </code></pre><p>5、显示文件名中包含了非字母或数字的特殊符号的文件； </p> <pre><code>ls *[^[:alnum:]]*</code></pre></div><h3 id="登陆式shell和非登陆式shell"><a href="#登陆式shell和非登陆式shell" class="headerlink" title="登陆式shell和非登陆式shell"></a>登陆式shell和非登陆式shell</h3><p>站在用户登录的角度来说，SHELL的类型：</p><ul><li><p>登录式shell:</p><ul><li>正常通过某终端登录</li><li>su - USERNAME </li><li>su -l USERNAME</li></ul></li><li><p>非登录式shell:</p><ul><li>su USERNAME</li><li>图形终端下打开命令窗口</li><li>自动执行的shell脚本</li></ul></li></ul><p>bash的配置文件：</p><ul><li><p>全局配置</p><pre><code>  /etc/profile    /etc/profile.d/*.sh    /etc/bashrc </code></pre></li><li><p>个人配置</p><pre><code>  ~/.bash_profile   ~/.bashrc</code></pre></li></ul><p>profile类的文件：  </p><ul><li>设定环境变量</li><li>运行命令或脚本</li></ul><p>bashrc类的文件：  </p><ul><li>设定本地变量</li><li>定义命令别名</li></ul><p>登录式shell如何读取配置文件？  </p><pre><code>/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</code></pre><p>非登录式shell如何配置文件?</p><pre><code>~/.bashrc --&gt; /etc/basrc --&gt; /etc/profile.d/*.sh</code></pre><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><p>Linux的一级目录如下：  </p><ul><li>&#x2F;boot: 系统启动相关的文件，如内核、initrd，以及grub(bootloader)  </li><li>&#x2F;dev: 设备文件  </li><li>设备文件：  <ul><li>块设备：随机访问，数据块  </li><li>字符设备：线性访问，按字符为单位  </li><li>设备号：主设备号（major）和次设备号（minor）</li></ul></li><li>&#x2F;etc：配置文件  </li><li>&#x2F;home：用户的家目录，每一个用户的家目录通常默认为&#x2F;home&#x2F;USERNAME  </li><li>&#x2F;root：管理员的家目录；  </li><li>&#x2F;lib：库文件  <ul><li>静态库,  .a   </li><li>动态库， .dll, .so (shared object)</li></ul></li><li>&#x2F;lib&#x2F;modules：内核模块文件  </li><li>&#x2F;media：挂载点目录，移动设备  </li><li>&#x2F;mnt：挂载点目录，额外的临时文件系统  </li><li>&#x2F;opt：可选目录，第三方程序的安装目录  </li><li>&#x2F;proc：伪文件系统，内核映射文件  </li><li>&#x2F;sys：伪文件系统，跟硬件设备相关的属性映射文件  </li><li>&#x2F;tmp：临时文件, &#x2F;var&#x2F;tmp  </li><li>&#x2F;var：可变化的文件  </li><li>&#x2F;bin: 可执行文件, 用户命令  </li><li>&#x2F;sbin：管理命令</li></ul><p>&#x2F;usr：shared, read-only  </p><ul><li>&#x2F;usr&#x2F;bin  </li><li>&#x2F;usr&#x2F;sbin  </li><li>&#x2F;usr&#x2F;lib</li></ul><p>&#x2F;usr&#x2F;local：  </p><ul><li>&#x2F;usr&#x2F;local&#x2F;bin  </li><li>&#x2F;usr&#x2F;local&#x2F;sbin  </li><li>&#x2F;usr&#x2F;local&#x2F;lib</li></ul><p>Linux中文件命名规则：  </p><ol><li>长度不能超过255个字符；  </li><li>不能使用&#x2F;当文件名  </li><li>严格区分大小写</li></ol><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>1、命令格式：</p><blockquote><p>命令 选项 参数</p><p>选项  </p><ul><li>短选项：- (多个选项可以组合 -a -b &#x3D; -ab)</li><li>长选项：- -</li></ul><p>参数：命令的作用对象</p></blockquote><p>2、命令类型：  </p><ul><li>内置命令(shell内置)，内部，内建  </li><li>外部命令：在文件系统的某个路径下有一个与命令名称相应的可执行文件</li></ul><p>3、type: 显示指令属于哪种类型</p><pre><code>[root@localhost ~]# type lsls is aliased to `ls --color=auto&#39; (命令别名)[root@localhost ~]# type cdcd is a shell builtin  （内部命令）[root@localhost ~]# type vivi is /usr/bin/vi （外部命令，对应文件）</code></pre><p>4、环境变量：命名的内存空间  </p><pre><code>变量赋值:NAME=Jerry  PATH: 使用冒号分隔的路径，命令的默认搜索路径  </code></pre><h3 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h3><blockquote><p>获得命令的使用帮助：<br>内部命令：help COMMAND<br>外部命令：COMMAND –help<br>在线手册：info COMMAND  (不常用)<br>文    档：&#x2F;usr&#x2F;share&#x2F;doc<br>命令手册：man COMMAND  </p><p>注：帮助中符号的意思<br>&lt;&gt;：必选     [] ：可选    … : 可以出现多次     | ：多选一    {} ：分组  </p></blockquote><p>man [指定章节数字] COMMAND  </p><pre><code>[root@localhost ~]# man DATEDATE(1)（1代表章节）                                                            User Commands                                                                   DATE(1)NAME（命令名称及功能简要说明）       date - print or set the system date and timeSYNOPSIS（用法说明，包括可用的选项）       date [OPTION]... [+FORMAT]       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION（命令功能的详尽说明，可能包括每一个选项的意义）     OPTIONS：说明每一个选项的意义         Display the current time in the given FORMAT, or set the system date.       Mandatory arguments to long options are mandatory for short options too.       -d, --date=STRING              display time described by STRING, not &#39;now&#39;FILES：此命令相关的配置文件        ......BUGS：       ......EXAMPLES：使用示例        ......SEE ALSO：另外参照      ...... 注：man文档查看方法    翻屏：        向后翻一屏：SPACE        向前翻一屏：b        向后翻一行：ENTER        向前翻一行：k    查找：        /KEYWORD: 向后            n: 下一个            N：前一个             ?KEYWORD：向前        n: 下一个        N：前一个         q: 退出</code></pre><p>man帮助中分章节，每个章节中存放不同类型的命令。比如1和5章节中都包含passwd。man命令如果不指定章节数，则默认显示最小章节的命令。查看5章节的passwd帮助使用man 5 passwd：  </p><ul><li>1：用户命令(&#x2F;bin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;bin)  </li><li>2：系统调用  </li><li>3：库用户  </li><li>4：特殊文件(设备文件)  </li><li>5：文件格式(配置文件的语法)  </li><li>6：游戏  </li><li>7：杂项(Miscellaneous)  </li><li>8: 管理命令(&#x2F;sbin, &#x2F;usr&#x2F;sbin, &#x2F;usr&#x2F;local&#x2F;sbin)</li></ul><p>whatis COMMAND：查看命令属于那些章节  </p><pre><code>[root@localhost ~]# whatis date  date (1)             - print or set the system date and time  date (1p)            - write the date and time</code></pre><div class="note blue icon-padding flat"><p>练习：</p>  <p>1. 使用date单独获取系统当前的年份、月份、日、小时、分钟、秒  </p>  <p>2. echo和printf是内部命令还是外部命令？  </p>  <p>3. echo和printf作用？  </p>  <p>4. echo和printf如何显示“The year is 2013. Today is 26.”为两行？  </p>  <p>5. file命令及其用法？</p>  </div><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>Linux时间有两种。一种是硬件时钟，另一种是系统时钟。</p><blockquote><ul><li>硬件时钟：CPU内置振荡器确定时间，同时CPU内置纽扣电源为振荡器提供电量。</li><li>系统时钟：Linux系统启动后，读取硬件时间并以软件方式模拟一个振荡器。date查看的便是系统时钟。</li></ul></blockquote><p>date：时间管理  </p><blockquote><p>-d 后跟字符串，显示字符串指定的时间 </p></blockquote><pre><code>[root@localhost ~]# date -d &quot;2 days ago&quot;  Fri Nov 19 02:05:54 EST 2021  [root@localhost ~]# date -d &quot;2021/11/21&quot;  Sun Nov 21 00:00:00 EST 2021    \\\\ 指定时间输出格式：  [root@localhost ~]# date -d &quot;10 days ago&quot; +&quot;The day is %Y-%m-%d %H:%M:%S%nThe day is %A&quot;  The day is 2021-11-11 02:27:09  The day is Thursday  \\\\ 修改时间  [root@localhost ~]# date -s &quot;2019-01-01 08:08:08&quot;Tue Jan  1 08:08:08 EST 2019</code></pre><p>clock、hwclock：硬件时钟</p><pre><code>-s 将系统时间更新为硬件时钟-w 将硬件时钟更新为系统时间</code></pre><p>cal：查看日历</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>ls（list）：列出指定路径下的文件  </p><pre><code> -l：长格式      文件类型：          -：普通文件 (f)          d: 目录文件          b: 块设备文件 (block)          c: 字符设备文件 (character)          l: 符号链接文件(symbolic link file)          p: 命令管道文件(pipe)          s: 套接字文件(socket)      文件权限：9位，每3位一组，每一组：rwx(读，写，执行), r--      文件硬链接的次数      文件的属主(owner)      文件的属组(group)      文件大小(size)，单位是字节      时间戳(timestamp)：最近一次被修改的时间          访问:access，文件最近访问时间          修改:modify，文件内容发生了改变          改变:change，metadata，元数据（如文件名、文件权限等属性改变）  -h：做单位转换，提高信息可读性  -a: 显示以.开头的隐藏文件      . 表示当前目录      .. 表示父目录  -A  显示以.开头的隐藏文件（除.和..目录）  -d: 显示目录自身属性，而不是目录下的内容。只显示当前文件或目录的属性  -i: index node, inode  -r: 逆序显示  -R: 递归(recursive)显示  </code></pre><p>pwd（Printing Working directory）：输出当前工作路径  </p><p>cd: change directory  </p><pre><code>cd ~: 进入指定用户的家目录  cd -:在当前目录和前一次所在的目录之间来回切换  </code></pre><p>mkdir：创建空目录  </p><pre><code>-p: 目录已存在不报错，父路径不存在自动创建  -v: verbose 打印出创建的每个目录mkdir -pv /mnt/test2/&#123;a,d&#125;_&#123;b,c&#125;：命令行展开，创建a_b, a_c, d_b, d_c目录</code></pre><p>tree：查看目录树</p><p>rmdir (remove directory)：删除空目录  </p><pre><code>-p: 如果父目录为空也会自动删除</code></pre><p>du ： 用于显示目录或文件的大小  </p><pre><code>-s 仅显示总计  -h 做单位换算，提高信息可读性</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>touch  修改文件的访问时间或修改时间为当前时间</p><pre><code> -a  仅仅改变访问时间   -m  仅仅改变修改时间   -t  指定[[CC]YY]MMDDhhmm[.ss]，代替当前时间   -c  不创建任何文件  </code></pre><blockquote><p>注：修改访问或修改任何一个时间都会自动修改改变时间为当前时间</p></blockquote><p>stat  展示文件或文件系统属性</p><pre><code>[root@localhost Music]# stat 11.txt   File: &#39;11.txt&#39;  Size: 14              Blocks: 8          IO Block: 4096   regular fileDevice: fd00h/64768d    Inode: 3169019     Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2019-01-01 01:01:00.000000000 -0500Modify: 2019-01-01 01:01:00.000000000 -0500Change: 2021-11-21 06:07:26.151522828 -0500 Birth: - </code></pre><p>nano：文本编辑器，不常用。</p><p>rm  删除文件或目录  </p><pre><code>-i 每一次删除之前都提示    -f 忽略不存在的文件，强制删除不提示  -r 递归删除</code></pre><p>cp SRC DEST 复制文件  </p><pre><code>-r：递归拷贝目录下内容  -d：复制时保留链接，如果是链接文件复制后依然是链接文件。  -i：存在目标文件则提示是否覆盖  -f：覆盖已经存在的目标文件而不给出提示。-p（小写）：保留这个文件原来的权限、属主、属组、时间戳。注：目前我用普通用户复制属主和属组还是变化。-P（大写）：如果是链接复制为链接-a：归档复制，常用于备份，相当于-dR --preserve=all多个文件到一个目录cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>mv SRC DEST  移动文件<br>mv -t DEST SRC  -t 是将源和目标位置反向</p><p>install  复制文件并可以设置属性  </p><pre><code> install -d DIRECOTRY ... ：创建目录     install -m ：可以指定权限   install SRC DEST 复制文件，复制之后会有执行权限   install -t DIRECTORY SRC...  </code></pre><h3 id="查看文本"><a href="#查看文本" class="headerlink" title="查看文本"></a>查看文本</h3><p>cat：连接文件并显示  </p><pre><code>-n 显示行号   -E 显示每一行的结束符$ [root@localhost Music]# cat file1 file2  this file is one.  this file is two.   [root@localhost Music]# cat -n file1 file2       1  this file is one.       2  this file is two.  [root@localhost Music]# cat -E file1 file2  this file is one.$  this file is two.$  [root@localhost Music]# cat -nE file1 file2       1  this file is one.$       2  this file is two.$</code></pre><p>tac: 将文件内容倒着显示</p><pre><code>[root@localhost Music]# tac file1this file is one, the line is 6.this file is one, the line is 5.this file is one, the line is 4.this file is one, the line is 3.this file is one, the line is 2.this file is one, the line is 1.</code></pre><p>more：以一页一页的方式查看文本，到文件末尾会自动退出。详细使用见man命令</p><p>less：less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。到文件末尾不会自动退出。</p><p>head:查看前n行   </p><pre><code>-n: 指定行数，默认为10  </code></pre><p>tail:查看后n行  </p><pre><code>-n: 指定行数，默认为10  -f: 会把文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>file： 辨识文件类型  </p><p>测试文件内容：</p><pre><code>Tom:25:male:2013/05/06  Jack:24:famale:2013/05/06Json:23:male:2013/05/06Mark:26:famale:2013/05/06</code></pre><p>cut:  分割文件中的每一行，并只显示选择字段</p><pre><code>-d: 指定字段分隔符，默认是空格-f: 指定要显示的字段    -f 1,3    -f 1-3[root@localhost Music]# cut -d : -f 1,3 file3Tom:maleJack:famaleJson:maleMark:famale</code></pre><p>sort：文本排序</p><pre><code>-n：数值排序-r: 降序-t: 字段分隔符-k: 以哪个字段为关键字进行排序-u: 排序后相同的行只显示一次-f: 排序时忽略字符大小写[root@localhost Music]# sort -n -t : -k 2 file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06WangWu:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06ZhaoLiu:26:male:2013/05/06LiSi:111:male:2013/05/06[root@localhost Music]# sort -n -t : -k 2 -u file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06LiSi:111:male:2013/05/06</code></pre><p>uniq:去重，去重时两行相邻并且内容一致才会认定是重复</p><pre><code>-c: 显示文件中行重复的次数-d: 只显示重复的行</code></pre><p>wc (word count)：文本统计，打印文件的行数、单词数、字节数</p><pre><code> -l：打印行数 -w：打印单词数 -c：打印字节数 -L：打印最长行的长度</code></pre><p>tr —— 转换或删除字符  </p><pre><code>tr [OPTION]... SET1 [SET2]      -d: 删除出现在字符集中的所有字符tr ab AB ：将文档中的a全部转换为A，将b全部转换为B，并不是ab转AB</code></pre><h3 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h3><p>locate: 非实时，模糊匹配，查找是根据全系统文件数据库进行的，速度快；<br>updatedb: 手动生成文件数据库（比较慢）</p><p>find：实时、精确、支持众多查找标准、遍历指定目录中的所有文件完成查找，速度慢；</p><pre><code>find 查找路径 匹配标准 查找到以后的处理运作查找路径：默认为当前目录匹配标准：默认为指定路径下的所有文件处理运作：默认为显示匹配标准：-name &#39;FILENAME&#39;：对文件名作精确匹配    文件名通配：        *：任意长度的任意字符        ?:任意单个字符        []:匹配指定范围内的任意单个字符-iname &#39;FILENAME&#39;: 文件名匹配时不区分大小写-regex PATTERN：基于正则表达式进行文件名匹配-user USERNAME: 根据属主查找-group GROUPNAME: 根据属组查找-uid UID: 根据UID查找-gid GID: 根据GID查找-nouser：查找没有属主的文件(删除用户之后，文件的属主则会变为用户对应的uid)-nogroup: 查找没有属组的文件(删除组之后，文件的属组则会变为用户对应的gid)-type     f: 普通文件    d：目录文件    c：字符设备文件    b：块设备文件    l：符号链接文件    p：命名管道文件    s：套接字文件-size [+|-] 大小 +大于 -小于    #k    #M    #G -mtime：在过去n天修改过的文件（单位：天）-ctime：在过去n天改变过的文件-atime：在过去n天访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-mmin：在过去n分钟修改过的文件（单位：分钟）-cmin：在过去n分钟改变过的文件-amin：在过去n分钟访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-maxdepth:递归层数-perm MODE：精确匹配    /MODE: 任意一位匹配即满足条件    -MODE: 文件权限能完全包含此MODE时才符合条件        -644    644: rw-r--r--    755: rwxr-xr-x    750: rwxr-x---    find ./ -perl -001 组合条件：以上条件之间的逻辑，    -a：与    -o：或    -not： 非     \( \)：括号要转义运作：    -print: 显示    -ls：类似ls -l的形式显示每一个文件的详细    -ok COMMAND &#123;&#125; \; 每一次操作都需要用户确认，命令中需要文件名的地方用&#123;&#125;代替    -exec COMMAND &#123;&#125; \;每一次操作都不需要用户确认，命令中需要文件名的地方用&#123;&#125;代替</code></pre><div class="note green icon-padding flat"><p>练习：  </p><p>1)在/mnt下创建boot和sysroot； </p> <p>2)在/mnt/boot下创建grub；  </p><p>3)在/mnt/sysroot下创建proc, sys, bin, sbin, lib, usr, var, etc, dev, home, root, tmp  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a)在/mnt/sysroot/usr下创建bin, sbin, lib  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b)在/mnt/sysroot/lib下创建modules  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)在/mnt/sysroot/var下创建run, log, lock  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d)在/mnt/sysroot/etc下创建init.d  </p><p>4)创建目录/backup；  </p><p>5)复制目录/etc至/backup目录中，并重命名为“etc-当前日期”，如etc-2013-02-26；要求保留文件原来的属性，保持链接文件；   </p><p>6）复制文件/etc/inittab为/tmp/inittab.new，并删除inittab.new文件的后两行； </p> <pre><code>  # cp /etc/inittab  /tmp/inittab.new    # nano /tmp/inittab.new</code></pre><p>7）描述GPL, BSD, Apache三个开源协定的大体联系及区别。</p><p>8）如何获取Linux当前最新的内核版本号？  </p>      <pre><code>  www.kernel.org</code></pre><p>9）列出你所了解的Linux发行版，并说明其跟Linux内核的关系。</p>  <pre><code>Linux, GNU: GNU/Linux, 源代码发行版：Fedora, RedHat(CentOS), SUSE, Debian(Ubuntu, Mint), Gentoo, LFS(Linux From Scratch)</code></pre><p>10）、查找/var目录下属主为root并且属组为mail的所有文件；</p><pre><code>find /var -user root -group mail</code></pre><p>11）、查找/usr目录下不属于root,bin或student的文件；</p><pre><code>find /usr -not -user root -a -not -user bin -a -not -user studentfind /usr -not \( -user root -o -user bin -o -user student \)</code></pre><p>12）、查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件；</p><pre><code>find /etc -mtime -7 -not \ ( -user root -o -user student \)find /etc -mtime -7 -not -user root -a -not -user student</code></pre><p>13）、查找当前系统上没有属主或属组且最近1天内曾被访问过的文件，并将其属主属组均修改为root；</p>    <pre><code>find / \( -nouser -o -nogroup \) -a -atime -1 -exec chown root:root &#123;&#125; \; </code></pre><p>14）、查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中；</p>    <pre><code>find /etc -size +1M &gt;&gt; /tmp/etc.largefiles</code></pre><p>15）、查找/etc目录下所有用户都没有写权限的文件，显示出其详细信息；</p><pre><code>find /etc -not -perm /222 -ls</code></pre></div><h3 id="用户、权限和组基础"><a href="#用户、权限和组基础" class="headerlink" title="用户、权限和组基础"></a>用户、权限和组基础</h3><p>Linux的用户管理使用如下机制：  </p><blockquote><p>认证机制：Authentication（使用用户名密码）<br>授权：Authorization（使用权限管理）<br>审计：Audition (日志)</p></blockquote><p>权限：  r, w, x</p><ul><li><p>文件：  </p><ul><li>r：可读，可以使用类似cat等命令查看文件内容；  </li><li>w：可写，可以编辑或删除此文件；  </li><li>x: 可执行，exacutable，可以命令提示符下当作命令提交给内核运行；</li></ul></li><li><p>目录：  </p><ul><li>r: 可以对此目录执行ls以列出内部的所有文件；  </li><li>w: 可以在此目录创建文件；  </li><li>x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；</li></ul></li></ul><p>权限和数字对应关系：</p><pre><code> 0 000 ---: 无权限 1 001 --x: 执行 2 010 -w-: 写 3 011 -wx: 写和执行 4 100 r--: 只读 5 101 r-x: 读和执行 6 110 rw-: 读写 7 111 rwx: 读写执行 755：rwxr-xr-x 640：rw-r-----  660: rw-rw---- 775: rwxrwxr-x</code></pre><p>用户：UID, &#x2F;etc&#x2F;passwd  </p><pre><code>account: 登录名password: 密码UID：GID：基本组IDcomment: 注释HOME DIR：家目录SHELL：用户的默认shell</code></pre><p>组：GID, &#x2F;etc&#x2F;group  </p><pre><code>组名：  密码：  GID:  以此组为其附加组的用户列表：</code></pre><p>影子口令：  </p><ul><li><p>用户：&#x2F;etc&#x2F;shadow</p><pre><code>  account: 登录名    encrypted password: 加密的密码    date of last password change：最近一次修改密码的时间  minimum password age：最短使用期限  maximum password age：最长使用期限  password warning period：警告时间  password inactivity period：非活动时间  account expiration date：账号过期时间</code></pre></li><li><p>组：&#x2F;etc&#x2F;gshadow</p></li></ul><p>影子文件中存储的密码都会进行相应的单向加密，加密算法分类如下：  </p><ul><li>对称加密：加密和解密使用同一个密码  </li><li>公钥加密：每个密码都成对儿出现，一个为私钥(secret key)，一个为公钥(public key)  </li><li>单向加密，散列加密：提取数据特征码，常用于数据完整性校验  <ul><li>1、雪崩效应  </li><li>2、定长输出  </li><li>MD5：Message Digest, 128位定长输出  </li><li>SHA1：Secure Hash Algorithm, 160位定长输出</li></ul></li></ul><p>用户类别：</p><ul><li>管理员：0  </li><li>普通用户： 1-65535  </li><li>系统用户：1-499  </li><li>一般用户：500-60000</li></ul><p>用户组类别：</p><ul><li>私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组  </li><li>基本组：创建用户时，指定的用户的默认组  </li><li>附加组，额外组：默认组以外的其它组</li></ul><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>useradd  [options]  USERNAME 添加用户  </p><pre><code> -u UID（用户ID） -g GID（基本组ID\基本组名，组必须存在） -G GID,...  （附加组） -c &quot;COMMENT&quot; （注释） -d /path/to/directory （家目录） -s SHELL （指定SHELL） -m -k （创建家目录。-k将/etc/skel下内容复制到家目录中） -M （不创建家目录） -r: 添加系统用户</code></pre><p>&#x2F;etc&#x2F;login.defs</p><blockquote><p>用于在Linux创建用户时，对用户的一些基本属性做默认设置。该配置对root用户无效。并且，当此文件中的配置与 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 文件中的用户信息有冲突时，系统会以&#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 为准。  </p></blockquote><p>userdel [option] USERNAME 删除用户  </p><pre><code> -r: 同时删除用户的家目录</code></pre><p>id：查看用户的帐号属性信息  </p><pre><code> -u: 显示用户ID -g: 显示基本组ID -G: 显示附加组ID -n: 每个选项不显示ID，显示名称[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><p>finger USERNAME：查看用户账号信息</p><p>usermod ： 修改用户帐号属性</p><pre><code>   -u UID 修改用户ID-g GID 修改基本组-a -G GID：不使用-a选项，会覆盖此前的附加组；-c：修改用户账户备注文字-d -m：修改用户的家目录，-m选项是将原来家目录中的内容复制新的家目录-s：修改用户shell-l：修改用户帐号名称-L：锁定帐号-U：解锁帐号usermod -a -G GROUPNAME，... USERNAME</code></pre><p>chage ： 修改用户密码信息</p><pre><code>-d: 最近一次的修改时间-E: 过期时间-I：非活动时间-m: 最短使用期限-M: 最长使用期限-W: 警告时间</code></pre><p>chsh: 修改用户的默认shell</p><p>chfn：修改注释信息</p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>passwd [USERNAME]</p><pre><code> --stdin ： 从标准输入中读入，主要用于管道传入 -l：锁定帐号  -u：解锁帐号   -d: 删除用户密码</code></pre><p>pwck：检查用户帐号完整性</p><pre><code>[root@localhost ~]# pwckuser &#39;ftp&#39;: directory &#39;/var/ftp&#39; does not existuser &#39;saslauth&#39;: directory &#39;/run/saslauthd&#39; does not existuser &#39;gluster&#39;: directory &#39;/run/gluster&#39; does not existuser &#39;pulse&#39;: directory &#39;/var/run/pulse&#39; does not existuser &#39;gnome-initial-setup&#39;: directory &#39;/run/gnome-initial-setup/&#39; does not existpwck: no changes</code></pre><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><p>groupadd 添加组</p><pre><code> -g GID 指定组ID -r：添加为系统组</code></pre><p>groupmod 修改组</p><pre><code> -g GID 修改组ID -n GRPNAME 更改组名称</code></pre><p>groupdel 删除组  </p><p>gpasswd：为组设定密码  </p><pre><code>gpasswd -d A GROUP ：将用户A从GROUP组移除  </code></pre><p>newgrp GRPNAME &lt;–&gt; exit：为用户指定临时基本组，需要指定组密码，用exit退出。</p><pre><code>[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ newgrp hadoop Password: [demo@localhost ~]$ iduid=1000(demo) gid=1001(hadoop) groups=1001(hadoop),1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ exitexit[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、创建一个用户mandriva，其ID号为2002，基本组为distro（组ID为3003），附加组为linux； </p>  <pre><code># groupadd -g 3003 distro# groupadd linux# useradd -u 2002 -g distro -G linux mandriva</code></pre><p>2、创建一个用户fedora，其全名为Fedora Community，默认shell为tcsh；</p>   <pre><code># useradd -c &quot;Fedora Community&quot; -s /bin/tcsh fedora</code></pre><p>3、修改mandriva的ID号为4004，基本组为linux，附加组为distro和fedora；</p> <pre><code># usermod -u 4004 -g linux -G distro,fedora mandriva</code></pre><p>4、给fedora加密码，并设定其密码最短使用期限为2天，最长为50天；</p> <pre><code># passwd -n 2 -x 50 fedora</code></pre><p>5、将mandriva的默认shell改为/bin/bash; </p> <pre><code>usermod -s /bin/bash mandirva</code></pre><p>6、添加系统用户hbase，且不允许其登录系统；</p> <pre><code># useradd -r -s /sbin/nologin hbase</code></pre></div><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>chown USERNAME file,…  改变文件属主(只有管理员可以使用此命令)  </p><pre><code> -R: 修改目录及其内部文件的属主 --reference=/path/to/somefile file,...：将文件的属主和属组和参照文件保持一致  chown    :GRPNAME file,...      ：改变文件属组信息 chown    .GRPNAME file,...      ：改变文件属组信息 chown USERNAME:GRPNAME file,... ：改变文件属主、属组信息 chown USERNAME.GRPNAME file,... ：改变文件属主、属组信息</code></pre><p>chgrp GRPNAME file,… 改变文件属组(只有管理员可以使用此命令)  </p><pre><code>-R: 修改目录及其内部文件的属组--reference=/path/to/somefile file,...：将文件的属组和参照文件保持一致  </code></pre><p>chmod MODE file,… 修改文件的权限</p><pre><code>-R: 修改目录及其内部文件的权限--reference=/path/to/somefile file,... ：将文件的权限和参照文件保持一致 修改文件权限：chmod  MODE file,...chomd  755 /home/demo/11.txt修改某类用户用户权限：u（属主）,g（属组）,o（其他）,a（所有）chmod 用户类别=MODE file,...chomd  u=rw /home/demo/11.txt修改某类用户的某位或某些位权限：u,g,o,achmod 用户类别+|-MODE file,...chmod u+w /home/demo/11.txtchmod ug+w /home/demo/11.txtchmod u+w,g+r /home/demo/11.txt</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、新建一个没有家目录的用户openstack；  </p>  <pre><code># useradd -M openstack  </code></pre><p>2、复制/etc/skel为/home/openstack；  </p>  <pre><code># cp -r /etc/skel /home/openstack  </code></pre><p>3、改变/home/openstack及其内部文件的属主属组均为openstack； </p>   <pre><code># chown -R openstack:openstack /home/openstack  </code></pre><p>4、/home/openstack及其内部的文件，属组和其它用户没有任何访问权限  </p>  <pre><code># chmod -R go= /home/openstack  （不修改属主的权限） </code></pre><p>5、不用命令如何添加一个用户  </p>  <pre><code>在/etc/passwd、/etc/shadow、/etc/group中分别添加一条记录使用openssl passwd -1 -salt xxxxxxxx（八位随机数） password 获取加密密码使用如上步骤</code></pre></div><h3 id="umask-遮掩码"><a href="#umask-遮掩码" class="headerlink" title="umask(遮掩码)"></a>umask(遮掩码)</h3><p>每个用户都会有一个遮掩码，遮掩码的作用是设置用户创建文件或目录的权限。Linux文件默认不具有执行权限。</p><pre><code>文件权限：666-umask （文件不具有执行权限） 目录权限：777-umask建议用权限位相减</code></pre><p>umask: 023</p><pre><code>文件：666-023=643 X （文件默认不能具有执行权限，如果算得的结果中有执行权限，则将其权限加1；故结果应为644）目录：777-023=754</code></pre><p>注：umask：027 创建的文件或目录其它用户无任何权限</p><h3 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h3><p>程序在运行过程中需要和I&#x2F;O设备打交道，而程序一般是不直接指定具体的输入和输出设备的。因此系统为我们提供了一些默认的输入和输出设置。</p><ul><li>默认输出设备：标准输出，STDOUT, 1（文件描述符），显示器</li><li>默认输入设备：标准输入, STDIN, 0（文件描述符） ，键盘  </li><li>标准错误输出：STDERR, 2（文件描述符）  ，显示器</li></ul><p>I&#x2F;O重定向就是修改程序的输入和输出的位置。</p><pre><code>&gt;:  标准输出覆盖输出&gt;&gt;：标准输出追加输出2&gt;: 重定向错误输出2&gt;&gt;:重定向错误输出追加方式&amp;&gt;: 重定向标准输出或错误输出至同一个文件&lt;：输入重定向&lt;&lt;：Here Document 此处生成文档    使用：&lt;&lt;EOF或者END         cat &lt;&lt; EOF         cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        [root@localhost ~]# cat        this is my first line.        this is my first line.        this is my secondary line.        this is my secondary line.        ^C        [root@localhost ~]# cat &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        this is my first line.        this is my secondary line.        [root@localhost ~]# cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        [root@localhost ~]# cat /tmp/myfile.txt         this is my first line.        this is my secondary line.</code></pre><p>tee：将标准输入写入标准输出和文件<br>        echo “hello world”|tee &#x2F;tmp&#x2F;hello.out</p><p>set可以对系统的某些功能性选项进行开启或关闭。 </p><pre><code>set -C: 禁止对已经存在文件使用覆盖重定向；  强制覆盖输出，则使用 &gt;|set +C: 关闭上述功能</code></pre><p>管道：一端流入，一端流出。即前一个命令的输出，作为后一个命令的输入。</p><pre><code>命令1 | 命令2 | 命令3 | ...echo “redhat” | passwd -stdin hive：使用命令行修改用户密码</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、统计/usr/bin/目录下的文件个数；</p><pre><code> # ls /usr/bin | wc -l</code></pre><p>2、取出当前系统上所有用户的shell，要求，每种shell只显示一次，并且按顺序进行显示；</p><pre><code> # cut -d: -f7 /etc/passwd | sort -u</code></pre><p>3、思考：如何显示/var/log目录下每个文件的内容类型？</p><pre><code> # file /var/log/* # file &#39;ls /var/log&#39;</code></pre><p>4、取出/etc/inittab文件的第6行；</p><pre><code> # head -6 /etc/inittab | tail -1</code></pre><p>5、取出/etc/passwd文件中倒数第9个用户的用户名和shell，显示到屏幕上并将其保存至/tmp/users文件中；</p><pre><code> # tail -9 /etc/passwd | head -1 | cut -d: -f1,7 | tee /tmp/users</code></pre><p>6、显示/etc目录下所有以pa开头的文件，并统计其个数；</p><pre><code># ls -d /etc/pa* | wc -l</code></pre><p>7、不使用文本编辑器，将alias cls=clear一行内容添加至当前用户的.bashrc文件中；</p><pre><code># echo &quot;alias cls=clear&quot; &gt;&gt; ~/.bashrc</code></pre></div><h2 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h2><h3 id="常规正则表达式"><a href="#常规正则表达式" class="headerlink" title="常规正则表达式"></a>常规正则表达式</h3><p>grep: 根据模式搜索文本，并将符合模式的文本行显示出来。</p><p>Pattern（模式）: 文本字符和正则表达式的元字符组合而成匹配条件</p><p>grep [options] PATTERN [FILE…]</p><pre><code>-i:忽略大小写--color : 匹配到的字符串亮色显示-v: 显示没有被模式匹配到的行-o：只显示被模式匹配到的字符串-E：使用扩展正则表达式-A：显示匹配字符串的前N行-B：显示匹配字符串的后N行-C：显示匹配字符串的前后N行</code></pre><p>Pattern（模式）元字符如下：</p><pre><code>字符匹配：：    .: 匹配任意单个字符    []: 匹配指定范围内的任意单个字符    [^]：匹配指定范围外的任意单个字符    字符集合：[:digit:], [:lower:], [:upper:], [:punct:], [:space:], [:alpha:], [:alnum:]匹配次数（贪婪模式）    *: 匹配其前面的字符任意次    \?: 匹配其前面的字符1次或0次    \&#123;m,n\&#125;:匹配其前面的字符至少m次，至多n次        a, b, ab, aab, acb, adb, amnb        a*b， a?b        a.*b            .*: 任意长度的任意字符        \&#123;1,\&#125;        \&#123;0,3\&#125;位置锚定：    ^: 锚定行首，此字符后面的任意内容必须出现在行首    $: 锚定行尾，此字符前面的任意内容必须出现在行尾    ^$: 空白行    \&lt;或\b: 锚定词首，其后面的任意字符必须作为单词首部出现    \&gt;或\b: 锚定词尾，其前面的任意字符必须作为单词的尾部出现分组：    \(\)    \(ab\)* 后向引用        \1: 引用第一个左括号以及与之对应的右括号所包括的所有内容如：demo    He love his lover.    She like her liker.    He like his lover.[root@localhost ~]# grep &quot;\(l..e\).*\1r\.&quot; demoHe love his lover.She like her liker.</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示/proc/meminfo文件中以不区分大小的s开头的行；</p><pre><code>grep -i &#39;^s&#39; /proc/meminfogrep &#39;^[sS]&#39; /proc/meminfo</code></pre><p>2、显示/etc/passwd中以nologin结尾的行;</p> <pre><code>grep &#39;nologin$&#39; /etc/passwd</code></pre><p>3、取出默认shell为/sbin/nologin的用户列表</p><pre><code>grep &quot;nologin$&#39; /etc/passwd | cut -d: -f1</code></pre><p>4、取出默认shell为bash，且其用户ID号最小的用户的用户名</p><pre><code>grep &#39;bash$&#39; /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1</code></pre><p>5、显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；</p>    <pre><code>grep &quot;^#[[:space:]]\&#123;1,\&#125;[^[:space:]]&quot; /etc/inittab</code></pre><p>6、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；</p>    grep ':[0-9]:' /etc/inittab<p>7、显示/boot/grub/grub.conf文件中以一个或多个空白字符开头的行；</p>    <pre><code>grep &#39;^[[:space:]]\&#123;1,\&#125;&#39; /boot/grub/grub.conf</code></pre><p>8、显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；</p><pre><code>grep &#39;^\([0-9]\).*\1$&#39; /etc/inittab</code></pre><p>9、找出某文件中的，1位数，或2位数；</p><pre><code>grep &#39;[0-9]\&#123;1,2\&#125;&#39; /proc/cpuinfogrep --color &#39;\&lt;[0-9]\&#123;1,2\&#125;\&gt;&#39; /proc/cpuinfo</code></pre><p>10、找出ifconfig命令结果中的1-255之间的整数；</p>  <p>9、查找当前系统上名字为student(必须出现在行首)的用户的帐号的相关信息, 文件为/etc/passwd</p>    <pre><code>grep &#39;^student\&gt;&#39; /etc/passwd | cut -d: -f3id -u student</code></pre><p>10、 分析/etc/inittab文件中如下文本中前两行的特征(每一行中出现在数字必须相同)，请写出可以精确找到类似两行的模式：</p><pre><code>l1:1:wait:/etc/rc.d/rc 1l3:3:wait:/etc/rc.d/rc 3grep &#39;^l\([0-9]\):\1.*\1$&#39; /etc/inittab</code></pre></div><h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h3><pre><code>grep -E = egrep    字符匹配：        .        []        [^]    次数匹配：        *:         ?:        +: 匹配其前面的字符至少1次        &#123;m,n&#125;    位置锚定：        ^        $        \&lt;        \&gt;    分组：        ()：分组        \1, \2, \3, ...    或者        |: or        C|cat: 为 C或cat 不是 Cat或cat</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示所有以数字结尾且文件名中不包含空白的文件；</p>    <pre><code>ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>2、找出/boot/grub/grub.conf文件中1-255之间的数字；</p>    <pre><code>\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;ifconfig | egrep &#39;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39; ifconfig | egrep --color &#39;(\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.)&#123;3&#125;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39;只查找前三类IP地址：（1-223）\&lt;([1-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[01][0-9]|22[0-3])\&gt;(\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;)&#123;2&#125;\.\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;</code></pre></div><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>   su [-l] 用户名：切换用户<br>   sudo COMMAND：完成部分特权指令</p><pre><code>配置文件/etc/sudoers文件中的如下行： 106 ## Allows people in group wheel to run all commands107 %wheel  ALL=(ALL)       ALL</code></pre><h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>SUID: 运行某程序时，相应进程的属主是程序文件自身的属主，而不是启动者；</p><pre><code>chmod u+s FILEchmod u-s FILE    如果FILE本身原来就有执行权限，则SUID显示为s；否则显示S；</code></pre><p>SGID: 运行某程序时，相应进程的属组是程序文件自身的属组，而不是启动者所属的基本组；同时该文件夹下所创建文件的属组是文件夹的属组，而不是创建用户的属组。</p><pre><code>chmod g+s FILEchmod g-s FILE    develop team, hadoop, hbase, hive    /tmp/project/        develop</code></pre><p>Sticky: 在一个公共目录，每个都可以创建文件，删除自己的文件，但不能删除别人的文件；</p><pre><code>chmod o+t DIRchmod o-t DIR</code></pre><p>注：以上三种权限就像rwx一样，也可以使用数字表示。比如 chmod 5755 &#x2F;backup&#x2F;test，而且umask的第一位数字代表的就是这三种权限。</p><h2 id="文件系统访问列表"><a href="#文件系统访问列表" class="headerlink" title="文件系统访问列表"></a>文件系统访问列表</h2><p>FACL(Filesystem Access Control List):利用文件扩展保存额外的访问控制权限 </p><p>setfacl</p><pre><code>-m: 设定    u:UID:perm    d:u：UID：perm 对目录有用，该目录下的新建文件拥有此默认权限    g:GID:perm    d:g：GID：perm 对目录有用，该目录下的新建文件拥有此默认权限-x：取消    u:UID    g:GID</code></pre><p>getfacl：查看文件系统访问权限</p><pre><code>[demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-group::rw-mask::rw- (这个会根据自动变化，为文件的最大权限)other::r--[demo@localhost ~]$ setfacl -m u:demo2:rwx demo.txt [demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-user:demo2:rwxgroup::rw-mask::rwx (这个会根据自动变化，为文件的最大权限)other::r--// 目录下设置默认权限[demo@localhost ~]$ setfacl -m d:u:demo2:rw- Desktop/[demo@localhost ~]$ cd Desktop/[demo@localhost Desktop]$ lltotal 0[demo@localhost Desktop]$ touch demo2.txt[demo@localhost Desktop]$ getfacl demo2.txt # file: demo2.txt# owner: demo# group: demouser::rw-user:demo2:rw-group::r-x#effective:r--mask::rw-other::r--[demo@localhost ~]$ lltotal 4-rw-rwxr--+ 1 demo demo 18 Dec 17 11:28 demo.txt  （具有acl属性权限结尾会有+）drwxr-xr-x+ 2 demo demo 23 Dec 25 04:42 Desktop</code></pre><h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><p>压缩算法不同，压缩比也会不同。常见的压缩格式有：gz, bz2, xz, zip, Z</p><p>Z格式（只能压缩单个文件。如果是文件夹，则是压缩文件夹内的每个文件）</p><pre><code>compress FILENAMEuncompress [demo@localhost ~]$ compress inittab -rw-r--r--. 1 demo demo 390 Dec 29 09:24 inittab.Z[demo@localhost ~]$ uncompress inittab.Z -rw-r--r--. 1 demo demo 511 Dec 29 09:24 inittab</code></pre><p>gz格式（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>gzip /PATH/TO/SOMEFILE：压缩完成后会删除原文件    -d：解压    -#：1-9，指定压缩比，默认是6；gunzip /PATH/TO/SOMEFILE.gz: 解压完成后会删除原文件zcat /PATH/TO/SOMEFILE.gz： 不解压的情况，查看文本文件的内容[demo@localhost ~]$ gzip inittab-rw-r--r--. 1 demo demo 316 Dec 29 09:24 inittab.gz</code></pre><p>bz2格式，该格式比gz有着更大压缩比（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>bzip2 /PATH/TO/SOMEFILE        -d: 解压        -#: 1-9,默认是6        -k: 压缩时保留原文件        bunzip2 /PATH/TO/SOMEFILE.bz2  解压完成后会删除原文件bzcat 不解压的情况，查看文本文件的内容[demo@localhost ~]$ bzip2 inittab -rw-r--r--. 1 demo demo 349 Dec 29 09:24 inittab.bz2</code></pre><p>xz格式：（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>xz /PATH/TO/SOMEFILE    -d：解压    -#: 1-9, 默认是6    -k: 压缩时保留原文件        unxz：解压xzdec:解压xzcat：不解压的情况，查看文本文件的内容。[demo@localhost ~]$ xz inittab -rw-r--r--. 1 demo demo 372 Dec 29 09:24 inittab.xz</code></pre><p>注：以上压缩和解压会删除原文件  </p><p>zip: 既归档（可以指定文件夹压缩）又压缩的工具  </p><pre><code>zip FILENAME.zip FILE1 FILE2 ...: 压缩后不删除原文件unzip FILENAME.zip ：解压</code></pre><p>tar: 归档工具, .tar</p><pre><code>-c: 创建归档文件-f FILE.tar: 操作的归档文件（压缩时是压缩后文件名，解压时是解压的文件名）-x: 展开归档--xattrs: 归档时，保留文件的扩展属性信息-t: 不展开归档，直接查看归档了哪些文件-C: 在解压时指定解压后文件的存放位置-zcf: 归档并调用gzip压缩-zxf: 调用gzip解压缩并展开归档，-z选项可省略-jcf: 归档并调用bzip2压缩-jxf:-Jcf: 归档并调xz压缩-Jxf:[demo@localhost etc]$ tar -Jcf conf.tar.xz ./etc  压缩[demo@localhost etc]$ tar -zxf conf.tar.xz -C ./etc/ 解压</code></pre><p>cpio: 归档工具，不常用</p><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><p>w：显示目前登陆系统的用户信息（su 切换用户还是显示原用户）</p><pre><code>[demo@localhost ~]$ w 04:52:09 up 33 min,  2 users,  load average: 0.00, 0.03, 0.13USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATdemo     :0       :0               04:20   ?xdm?   1:12   0.26s /usr/libexec/gndemo     pts/0    :0               04:21    1.00s  0.49s  0.01s w</code></pre><p>who：显示当前登录系统的用户（w的简化版）</p><pre><code>[demo2@localhost demo]$ whodemo     :0           2021-12-25 04:20 (:0)demo     pts/0        2021-12-25 04:21 (:0)</code></pre><p>sleep #：等待多少秒<br>whoami：显示当前用户</p><pre><code>[demo2@localhost demo]$ whoamidemo2</code></pre><p>last，显示&#x2F;var&#x2F;log&#x2F;wtmp文件，显示用户登录历史及系统重启历史  </p><pre><code>-n #: 显示最近#次的相关信息[demo2@localhost demo]$ lastdemo     pts/0        :0               Sat Dec 25 04:21   still logged in   demo     :0           :0               Sat Dec 25 04:20   still logged in   demo     :0           :0               Sat Dec 25 04:20 - 04:20  (00:00)    reboot   system boot  3.10.0-1062.el7. Sat Dec 25 04:19 - 04:57  (00:38)    demo     pts/0        :0               Fri Dec 17 11:27 - 11:34  (00:06)    demo     :0           :0               Fri Dec 17 11:25 - crash (7+16:53) </code></pre><p>lastb，&#x2F;var&#x2F;log&#x2F;btmp文件，显示用户错误的登录尝试  </p><pre><code>-n #:[root@localhost demo]# lastbdemo2    pts/0                         Sat Dec 25 04:59 - 04:59  (00:00)    btmp begins Sat Dec 25 04:59:30 2021</code></pre><p>lastlog: 显示每一个用户最近一次的成功登录信息；</p><pre><code>-u USERNAME: 显示特定用户最近的登录信息[root@localhost demo]# lastlogUsername         Port     From             Latestroot             pts/0                     Sat Dec 25 04:59:06 -0500 2021bin                                        **Never logged in**daemon                                     **Never logged in**adm                                        **Never logged in**lp                                         **Never logged in**</code></pre><p>basename：获取文件名</p><pre><code>$0: 执行脚本时的脚本路径及名称[root@localhost demo]# basename /home/demo/demo.txtdemo.txt</code></pre><p>mail：发送邮件</p><pre><code>[root@localhost demo]# mail -s &quot;first&quot; demo &lt; demo.txt [root@localhost demo]# su - demoLast login: Sat Dec 25 04:59:21 EST 2021 on pts/0[demo@localhost ~]$ mailHeirloom Mail version 12.5 7/5/10.  Type ? for help.&quot;/var/spool/mail/demo&quot;: 1 message 1 new&gt;N  1 root                  Sat Dec 25 05:10  18/617   &quot;first&quot;&amp; 1Message  1:From root@localhost.localdomain  Sat Dec 25 05:10:07 2021Return-Path: &lt;root@localhost.localdomain&gt;X-Original-To: demoDelivered-To: demo@localhost.localdomainDate: Sat, 25 Dec 2021 05:10:06 -0500To: demo@localhost.localdomainSubject: firstUser-Agent: Heirloom mailx 12.5 7/5/10Content-Type: text/plain; charset=us-asciiFrom: root@localhost.localdomain (root)Status: Rthis is new file.&amp; 注：用户邮件目录在/var/spool/mail</code></pre><p>hostname: 显示主机名</p><pre><code>如果当前主机的主机名不是www.magedu.com，就将其改为www.magedu.com如果当前主机的主机名是localhost，就将其改为www.magedu.com如果当前主机的主机名为空，或者为(none)，或者为localhost，就将其改为www.magedu.com[ -z `hostname` ] || [ `hostname` == &#39;(none)&#39; -o `hostname` == &#39;localhost&#39; ] &amp;&amp; hostname www.magedu.com</code></pre><p>生成随机数RANDOM: 0-32768</p><pre><code>随机数生成器：熵池(收集系统产生中断的时间作为随机数)/dev/random:(收集系次产生中断的时间作为随机数，如果不足需要等待)/dev/urandom:(收集系统产生中断的时间作为随机数，如果不足则自行生成随机数)[demo@localhost mail]$ echo $RANDOM12963</code></pre><p>ln [-s -v] SRC DEST：建立符号链接</p><pre><code>-s：建立软链接-v：建立硬链接[demo@localhost ~]$ ln -s /etc/inittab ./[root@localhost demo]# ln -v /etc/inittab inittab1 ‘inittab1’ =&gt; ‘/etc/inittab’[root@localhost demo]# lltotal 8-rw-rwxr--+ 1 demo demo  18 Dec 17 11:28 demo.txtdrwxr-xr-x+ 2 demo demo  23 Dec 25 04:42 Desktopdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Documentsdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Downloadslrwxrwxrwx. 1 demo demo  12 Dec 25 05:48 inittab -&gt; /etc/inittab-rw-r--r--. 2 root root 511 Aug  8  2019 inittab1drwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Musicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Picturesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Publicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Templatesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Videos硬链接：（存储文件的inode）    1、只能对文件创建，不能应用于目录；    2、不能跨文件系统；    3、创建硬链接会增加文件被链接的次数；    符号链接：（存储文件的字符串）    1、可应用于目录；    2、可以跨文件系统；    3、不会增加被链接文件的链接次数；    4、其大小为指定的路径所包含的字符个数；</code></pre><p>du </p><pre><code>-s ：查看文件夹总大小-h ：单位换算[root@localhost etc]# du20./fonts/conf.d24./fonts72./grub.d12./pki/rpm-gpg156./pki/ca-trust/extracted/java......42436[root@localhost etc]# du -s42436.[root@localhost etc]# du -sh42M</code></pre><p>df: </p><pre><code>-h：查看各文件系统的存储  -i：查看各文件系统inode的使用量[root@localhost etc]# df -hFilesystem               Size  Used Avail Use% Mounted ondevtmpfs                 470M     0  470M   0% /devtmpfs                    487M     0  487M   0% /dev/shmtmpfs                    487M  8.7M  478M   2% /runtmpfs                    487M     0  487M   0% /sys/fs/cgroup/dev/mapper/centos-root   17G  4.2G   13G  25% //dev/sda1               1014M  171M  844M  17% /boottmpfs                     98M  4.0K   98M   1% /run/user/42tmpfs                     98M   28K   98M   1% /run/user/1000/dev/sr0                 4.4G  4.4G     0 100% /run/media/demo/CentOS 7 x86_64tmpfs                     98M     0   98M   0% /run/user/0[root@localhost etc]# df -iFilesystem               Inodes  IUsed   IFree IUse% Mounted ondevtmpfs                 120210    391  119819    1% /devtmpfs                    124468      1  124467    1% /dev/shmtmpfs                    124468    995  123473    1% /runtmpfs                    124468     16  124452    1% /sys/fs/cgroup/dev/mapper/centos-root 8910848 155245 8755603    2% //dev/sda1                524288    340  523948    1% /boottmpfs                    124468      6  124462    1% /run/user/42tmpfs                    124468     19  124449    1% /run/user/1000/dev/sr0                      0      0       0     - /run/media/demo/CentOS 7 x86_64tmpfs                    124468      1  124467    1% /run/user/0</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>终端类型：</p><pre><code>console: 控制台 直接连接在计算机上的显示器、鼠标、键盘pty: 物理终端 (VGA) tty#: 虚拟终端 (VGA) 服务器ttyS#: 串行终端pts/#: 伪终端 通过ssh等登陆到linux主机上所使用的终端</code></pre><p>计算机总线：  </p><ul><li>地址总线：内存寻址  </li><li>数据总线：传输数据  </li><li>控制总线：控制指令</li></ul><p>进程：在每个进程看来，当前主机上只存在内核和当前进程。进程是程序的副本，进程是程序执行实例  </p><p>环境变量：  </p><pre><code>PATH  HISTSIZE  SHELL：用户当前使用SHELL  </code></pre><p>LANG&#x3D;en 修改Linux编码  </p><p>read ： 从标准输入中读取数据，并以空格切分。将分割结果存入后面参数中的变量。具体使用参见：<br><a href="https://www.runoob.com/linux/linux-comm-read.html">https://www.runoob.com/linux/linux-comm-read.html</a>  </p><pre><code>-p “PROMPT&quot;: 给出提示    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;Linux的基本原则&quot;&gt;&lt;a href=&quot;#Linux的基本原则</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://example.com/2022/11/24/MakeBlog/"/>
    <id>http://example.com/2022/11/24/MakeBlog/</id>
    <published>2022-11-24T13:58:42.850Z</published>
    <updated>2022-11-24T13:58:42.850Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。</p><p></p><p>为什么选择个人博客？我搭建个人博客的原因是由于个人博客的样式可控。</p></div><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>机器环境: CentOS Linux release 7.7.1908 (Core)  </li><li>内核环境: 3.10.0-1062.el7.x86_64</li></ul><p>本博客采用nodejs平台+hexo框架+Butterfly主题+Github Pages搭建</p><ul><li>nodejs 是一个javascirpt的运行环境。我的理解为js原本是在浏览器上运行的脚本语言，有了nodejs之后，js就可以像shell脚本一样直接在机器上运行。</li><li>hexo框架是一个基于node.js的快速生成静态博客的框架</li><li>Butterfly是hexo博客的一款主题。</li><li>Github Pages是github提供的一项静态站点托管服务。</li></ul><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="搭建本地Hexo"><a href="#搭建本地Hexo" class="headerlink" title="搭建本地Hexo"></a>搭建本地Hexo</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>本文采用nodejs的二进制安装方式，由于我的Linux机器为CentOS 7，安装最新版会报错，因此我选择安装12.15.0这个版本。  </p><pre><code># 进入根目录cd /usr/local/# 获取二进制安装包wget https://nodejs.org/download/release/v12.15.0/node-v12.15.0-linux-x64.tar.gz# 解压tar -xf node-v12.15.0-linux-x64.tar.gzrm -rf node-v12.15.0-linux-x64.tar.gz# 创建软件包链接ln -sv node-v12.15.0-linux-x64/ nodejs# 让命令可以直接执行ln -sv /usr/local/nodejs/bin/node /usr/local/binln -sv /usr/local/nodejs/bin/npm /usr/local/bin# 检查是否能够运行[root@localhost bin]# node -vv12.15.0[root@localhost bin]# npm -v6.13.4</code></pre><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>查看是否安装git。hexo初始化的时候需要使用git命令从github下载hexo相关代码，后期将博客部署到github上也依赖git。</p><pre><code>[root@localhost bin]# git --versiongit version 1.8.3.1</code></pre><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>在家目录下建立blob目录作为hexo的根目录</p><pre><code># 建立目录mkdir ~/blobcd ~/blob# 永久设置npm源（不修改执行的时候会卡住）npm config set registry https://registry.npm.taobao.org# 安装hexo-cli，nodejs的npm相当于Linux的yum[root@localhost blob]# npm install -g hexo-cli/usr/local/node-v12.15.0-linux-x64/bin/hexo -&gt; /usr/local/node-v12.15.0-linux-x64/lib/node_modules/hexo-cli/bin/hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-cli@4.3.0added 59 packages from 51 contributors in 5.498s# 初始化文件夹hexo init# 安装 hexo 所需要的依赖包npm install</code></pre><p>在安装中遇到如下问题：Error: ENOENT: no such file or directory, uv_cwd</p><p>解决方案：重启终端</p><h4 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h4><p>hexo 常用命令：</p><ul><li>hexo g 生成静态网站</li><li>hexo s 启动服务器</li><li>hexo d 部署</li><li>hexo clean 清理生成的静态网站</li></ul><p>部署：</p><pre><code>[root@192 blob]# hexo g &amp;&amp; hexo sINFO  Validating configINFO  Start processingINFO  Files loaded in 130 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2022/index.htmlINFO  Generated: archives/2022/11/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/jquery.fancybox.min.cssINFO  Generated: js/script.jsINFO  Generated: css/style.cssINFO  Generated: 2022/11/21/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.woff2INFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.min.jsINFO  Generated: js/jquery-3.4.1.min.jsINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: css/images/banner.jpgINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  17 files generated in 410 msINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</code></pre><p>访问网站：<br><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204625063.png" alt="images"></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo的主题可以在github仓库中搜索hexo-theme或者hexo官网查找，本文使用的主题为butterfly。</p><pre><code># 从github仓库中下载主题（hexo根目录中）：git https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly# 修改hexo根目录下_config.xml 配置文件theme: landscape 改为 theme: butterfly# 重新部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>在浏览器中打开报如下问题：</p><pre><code># 显示内容：extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pug解决方案（hexo根目录）：npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></pre><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c51af39bb0820efc4ea19d42c7252b2?method=download&shareKey=577f858ad5b22a1545471f53e5f2416e" alt="image"></p><h3 id="优化主题"><a href="#优化主题" class="headerlink" title="优化主题"></a>优化主题</h3><p>至此，上面的博客已经具有了一个框架。下面我们进行相应的优化。参考博客：  </p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>更改博客主题、描述、作者、语言、时区（hexo根目录下配置文件）</p><pre><code># Sitetitle: 知与行subtitle: &#39;&#39;description: &#39;学而不思则惘，思而不学则殆&#39;keywords:  author: QiYanlanguage: zh-CNtimezone: Asia/Shanghai</code></pre><p>图像修改：背景图下载地址<a href="https://wallhaven.cc/">https://wallhaven.cc/</a> ，图像放到hexo_root&#x2F;themes&#x2F;主题名&#x2F;source&#x2F;img&#x2F;。如下修改的是主题配置文件（hexo_root&#x2F;theme&#x2F;主题名&#x2F;_config.xml）。</p><pre><code># 主页图index_img: /img/background.jpg    # 头像：avatar:  img: /img/avatar.png#文档图（cover:  # display the cover or not (是否顯示文章封面)  index_enable: false  aside_enable: false  archives_enable: false  # the position of cover in home page (封面顯示的位置)  # left/right/both  position: both  # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)  default_cover: </code></pre><p>cover中设置default_cover之后，文件列表和文章内容的top图都是同一张图。<br>解决方案：<a href="https://blog.csdn.net/zzq0523/article/details/122954271">https://blog.csdn.net/zzq0523/article/details/122954271</a>）</p><p>修改菜单：</p><pre><code>menu:   首页: / || fas fa-home   归档: /archives/ || fas fa-archive   标签: /tags/ || fas fa-tags   分类: /categories/ || fas fa-folder-open  # List||fas fa-list:  #   Music: /music/ || fas fa-music  #   Movie: /movies/ || fas fa-video  # Link: /link/ || fas fa-link   关于: /about/ || fas fa-heart</code></pre><p>创建相关页面</p><pre><code>#前往你的 Hexo 博客的根目錄hexo new page tags#找到source/tags/index.md這個文件添加 type: &quot;tags&quot;并将title后的名字改为中文 ---title: 標籤date: 2018-01-05 00:00:00type: &quot;tags&quot;---# 添加分类页hexo new page categories---title: 分类date: 2022-11-21 08:20:51types: &quot;categories&quot;---</code></pre><p>添加动态文字：</p><pre><code>subtitle:  enable: true  # Typewriter Effect (打字效果)  effect: true  # Effect Speed Options (打字效果速度參數)  startDelay: 300 # time before typing starts in milliseconds  typeSpeed: 150 # type speed in milliseconds  backSpeed: 50 # backspacing speed in milliseconds  # loop (循環打字)  loop: true  # source 調用第三方服務  # source: false 關閉調用  # source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/  # source: 2  調用今日詩詞（簡體） https://www.jinrishici.com/  # subtitle 會先顯示 source , 再顯示 sub 的內容  source: false  # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字  sub:    - 今日事&amp;#44;今日畢    - Never put off till tomorrow what you can do today</code></pre><p>安装搜索框</p><pre><code>[root@192 butterfly]# npm install hexo-generator-search --savenpm notice created a lockfile as package-lock.json. You should commit this file.+ hexo-generator-search@2.4.3added 6 packages from 5 contributors in 1.551s# 修改主题配置文件local_search:  enable: true# 重启hexo否则会报错hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>添加字数统计功能：</p><pre><code>npm install hexo-wordcount --save# 修改主题配置文件wordcount:     enable: true# 重启hexo</code></pre><p>给文章列表添加字数统计：  </p><p><a href="http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/">http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/</a></p><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p><a href="https://imbhj.com/25c13146/">https://imbhj.com/25c13146/</a><br><a href="https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/">https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/</a></p><h2 id="托管静态页面"><a href="#托管静态页面" class="headerlink" title="托管静态页面"></a>托管静态页面</h2><h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><p>首先在github中注册账号  </p><p>创建仓库。每个用户只能创建一个github pages，因此仓库名称必须为&lt;用户名&gt;.github.io，否则创建的为普通仓库</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224741804.png" alt="image">、</p><p>在github pages仓库中创建一个index.html文件用于测试  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225639083.png" alt="image"></p><p>在浏览器页面输入https:&#x2F;&#x2F;用户名.github.io&#x2F; 查看是否访问成功  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229230057034.png" alt="image"></p><h3 id="免密登录github"><a href="#免密登录github" class="headerlink" title="免密登录github"></a>免密登录github</h3><p>CentOS中生成登录密钥：</p><pre><code># 其中 邮箱名 是你注册 GitHub 的邮箱ssh-keygen -t rsa -C &quot;邮箱名&quot; # 后面输入三个回车</code></pre><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image"></p><p>CentOS 进入~&#x2F;.ssh目录，复制id_rsa.pub中的内容。将公钥复制到github中。</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235220955.png" alt="image"></p><p>测试是否能够正常连接：</p><pre><code>[root@192 images]# ssh -T git@github.comHi qiyankuo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>安装部署插件</p><pre><code># 这样执行会报错[root@192 blob]# npm install hexo-deplyer-gitnpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmmirror.com/hexo-deplyer-git - [NOT_FOUND] hexo-deplyer-git not foundnpm ERR! 404 npm ERR! 404  &#39;hexo-deplyer-git@latest&#39; is not in the npm registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404 npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     /root/.npm/_logs/2022-11-22T02_25_42_682Z-debug.log# 正确方式[root@192 blob]# npm install hexo-deployer-git --save# 修改hexo根目录下配置文件deploy:  type: &#39;git&#39;  repo: git@github.com:用户名/仓库名  #如：git@github.com:qiyankuo/qiyankuo.github.io.git  branch: main# 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </code></pre><p>在浏览器中输入https:&#x2F;&#x2F;用户名.github.io&#x2F;进行测试（这个可能会有些延迟）</p><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><h3 id="git相关概念"><a href="#git相关概念" class="headerlink" title="git相关概念"></a>git相关概念</h3><p><a href="https://www.runoob.com/git/git-workspace-index-repo.html">https://www.runoob.com/git/git-workspace-index-repo.html</a></p><h3 id="创建仓库并上传图片"><a href="#创建仓库并上传图片" class="headerlink" title="创建仓库并上传图片"></a>创建仓库并上传图片</h3><p>在github中新建仓库images</p><p>在CentOS下关联github仓库，进行图片管理</p><pre><code># 先进入准备放置github仓库的目录cd ...# 克隆仓库git clone 仓库地址 # 如：https://github.io/qiyankuo/images# 将需要添加的图片移动到仓库目录中mv ... ...git add 文件名  # 添加xyz文件至indexgit commit -m &quot;描述&quot;  # 提交git remote origin git@github.com:qiyankuo/images.git  # 设置远程连接别名git push origin main  # 将本地内容提交到github中</code></pre><h3 id="引用图片地址"><a href="#引用图片地址" class="headerlink" title="引用图片地址"></a>引用图片地址</h3><p>在github中找到图像发现无法显示，在图片上右键在新标签中打开图像显示url如下：<a href="https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg">https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg</a></p><p>参照网上教程使用免费的CDN服务jsDriver进行github加速，但是我发现这个好像不能用。故我采用如下方式：</p><ul><li><p>github镜像 <a href="https://hub.nuaa.cf/">https://hub.nuaa.cf/</a> 访问上面的图片将githubusercontent.com修改为nuaa.cf。即</p><pre><code>  https://raw.nuaa.cf/qiyankuo/images/main/hexo/betterfly.jpg  注：这种方式发现本地部署和github pages中都无法查看</code></pre></li><li><p>Github RAW 加速服务<a href="https://www.7ed.net/start/raw-cdn.html">https://www.7ed.net/start/raw-cdn.html</a>，在githubusercontent中添加上s就可以了。即</p><pre><code>  [https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg](https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg)  注：这种方式发现本地部署可以查看，浏览器也可以查看，但是github pages页面中无法查看</code></pre></li><li><p>最终采用有道云笔记存储图片，或者可以用gitee存储图片。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>    经过了三四天的时间终于将自己的个人博客搭建完成。搭建博客的过程中也遇到了很多问题。首先，原本准备使用next主题，但是这个主题有一些地方无法调整，当时想过放弃或者先搭建一个后期再通过学习前端进行修改。之后当看到51cto的博客样式，这个博客已经满足我的基本需要。当我无意中找到butterfly官网的文章之后，感觉这就是我想要的文章样式。</p><p>    其次，起初采用github搭建，但是考虑到github国内访问速度较慢。开始转gitee上搭建，但是gitee需要实名认证（被拒了）。继续github进行搭建。</p><p>    搭建完之后发现jsDriver不能使用，最终找到了Github RAW 加速服务进行替换。后期计划的话博客样式应该还会不断的进行调整。最后，准备使用typora和picgo搭建书写博客的环境，typora收费，picgo官网上说仅在Windows和macos进行了测试。</p><p>    目前更新了文章之后发布都是手动发布的，图片也是手动上传。我准备做一个shell脚本，自动完成图片的上传替换以及自动发布功能。当然，博客搭建完了。更重要的是不断的更新自己的知识，不断的发布博客。即不能为了发博客而写博客，也不能因为忙而不写博客。</p></div><div class="note green icon-padding flat"><p>参考文档：</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://butterfly.js.org/posts/dc584b87</p><p>https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;为什么选择个人博客？我搭建个人博客的原因是由于个人博客</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/11/21/hello-world/"/>
    <id>http://example.com/2022/11/21/hello-world/</id>
    <published>2022-11-21T09:22:02.494Z</published>
    <updated>2022-11-21T09:22:02.491Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
