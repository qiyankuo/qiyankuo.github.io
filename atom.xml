<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知与行</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-12T14:25:21.469Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>QiYan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker基础</title>
    <link href="http://example.com/2022/12/12/Docker/"/>
    <id>http://example.com/2022/12/12/Docker/</id>
    <published>2022-12-12T14:25:21.471Z</published>
    <updated>2022-12-12T14:25:21.469Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文主要介绍容器化底层实现技术（chroot、namespace、cgroup）、docker安装和卸载、容器管理工具的相关内容。</p></div><h2 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h2><p>一提起容器化，大家首先想到的便是docker。docker是容器化技术的代表，但容器化技术并不是从docker开始诞生的。容器化技术最早可以追溯到chroot命令，chroot实现了将一个进程的文件系统进行隔离。docker最早是基于LXC技术的一系列封装。LXC是Linux原生支持的容器技术，可以提供轻量级的虚拟化。后来docker改为了自己研发并开源的runc技术运行容器。</p><p>docker采用的是C&#x2F;S架构，使用远程API来管理和构建容器，并通过namespace和cgroup来实现容器的资源隔离与安全保障等。docker的三大理念为build（构建）、ship（运输）、run（运行）。docker和java很相似。它们都追求一次编译、到处运行。</p><p>docker的组成：</p><p><img src="http://www.yunweipai.com/wp-content/uploads/2020/06/JX2M8NLVEKMRH_RY5ZMG-780x393.png" alt="image"></p><ul><li>Docker主机：一个物理机或虚拟机，用于运行Docker服务进程和容器，也称为宿主机，node节点</li><li>Docker仓库：保存镜像的仓库，官方仓库: <a href="https://hub.docker.com/">https://hub.docker.com/</a> 。也可以搭建私有仓库harbor</li><li>Docker镜像：镜像可以理解为创建实例使用的模板</li><li>Docker容器：容器是从镜像生成对外提供服务的一个或一组服务</li><li>Docker服务端：Docker守护进程，运行docker容器</li><li>Docker客户端：客户端使用docker 命令或其他工具调用docker API</li></ul><p>容器和虚拟机比较：</p><p><img src="http://www.yunweipai.com/wp-content/uploads/2020/06/image-20200225140931257-780x297.png" alt="image"><br>优点：</p><ul><li>资源利用率更高：一台物理机可以运行数百个容器，但是一般只能运行数十个虚拟机</li><li>开销更小：不需要启动单独的虚拟机OS内核占用硬件资源</li><li>启动速度更快：可以在数秒内完成启动</li><li>集成性更好：和CI&#x2F;CD（持续集成&#x2F;持续部署）相关技术结合性更好，实现自动化管理</li></ul><p>缺点：</p><ul><li>多个容器共用宿主机的内核，各应用之间的隔离不如虚拟机彻底</li></ul><h2 id="Docker安装与卸载"><a href="#Docker安装与卸载" class="headerlink" title="Docker安装与卸载"></a>Docker安装与卸载</h2><h3 id="操作系统选择"><a href="#操作系统选择" class="headerlink" title="操作系统选择"></a>操作系统选择</h3><p>Docker 目前已经支持多种操作系统的安装运行，比如Ubuntu、CentOS、Redhat、Debian、Fedora，甚至是还支持了Mac和Windows，在linux系统上需要内核版本在3.10或以上。</p><h3 id="Docker版本选择"><a href="#Docker版本选择" class="headerlink" title="Docker版本选择"></a>Docker版本选择</h3><p>docker版本号之前一直是0.X版本或1.X版本，但是从2017年3月1号开始改为每个季度发布一次稳版，其版本号规则也统一变更为YY.MM，例如17.09表示是2017年9月份发布的。</p><p>Docker之前没有区分版本，但是2017年推出(将docker更名为)新的项目Moby，github地址：<a href="https://github.com/moby/moby%EF%BC%8C">https://github.com/moby/moby，</a> Moby项目属于Docker项目的全新上游，Docker将是一个隶属于的Moby的子产品，而且之后的版本之后开始区分为 CE（Docker Community Edition，社区版本）和 EE（Docker Enterprise Edition，企业收费版），CE社区版本和EE企业版本都是每个季度发布一个新版本，但是EE版本提供后期安全维护1年，而CE版本是4个月。</p><p>如果要布署到kubernets上，需要查看相关kubernets对docker版本要求的说明，比如<a href="https://github.com/kubernetes/kubernetes/blob/v1.17.2/CHANGELOG-1.17.md">https://github.com/kubernetes/kubernetes/blob/v1.17.2/CHANGELOG-1.17.md</a></p><h3 id="CentOS安装docker"><a href="#CentOS安装docker" class="headerlink" title="CentOS安装docker"></a>CentOS安装docker</h3><p>CentOS 6 因内核太旧，即使支持安装docker，但会有各种问题，不建议安装<br>CentOS 7 的 extras 源虽然可以安装docker，但包比较旧，建议从官方源或镜像源站点下载安装docker<br>CentOS 8 有新技术 podman 代替 docker<br>因此建议在CentOS 7 上安装 docker</p><h4 id="rpm包安装："><a href="#rpm包安装：" class="headerlink" title="rpm包安装："></a>rpm包安装：</h4><p>官方rpm包下载地址:</p><p><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/">https://download.docker.com/linux/centos/7/x86_64&#x2F;stable&#x2F;Packages&#x2F;</a></p><p>阿里镜像下载地址：</p><p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/">https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64&#x2F;stable&#x2F;Packages&#x2F;</a></p><h4 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h4><p>安装所需的软件包。yum-utils 提供了 yum-config-manager </p><pre><code>yum install -y yum-utils </code></pre><p>添加阿里软件源信息</p><pre><code>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 前两步可以使用如下命令替换wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>更新yum源并安装docker-ce</p><pre><code>yum makecache fastyum -y install docker-ce</code></pre><p>没有指定版本默认安装的是docker最新版本，如果需要安装指定版本可以参考如下操做</p><pre><code>查找Docker-CE的版本:[root@localhost yum.repos.d]# yum list docker-ce --showduplicates | sort -r * updates: mirrors.tuna.tsinghua.edu.cnLoading mirror speeds from cached hostfileLoaded plugins: fastestmirror, langpacks * extras: mirrors.tuna.tsinghua.edu.cndocker-ce.x86_64            3:20.10.9-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.8-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.7-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.6-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.5-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.4-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.3-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.2-3.el7                     docker-ce-stabledocker-ce.x86_64            3:20.10.21-3.el7                    docker-ce-stable安装指定版本的Docker-CEyum -y install docker-ce-3:20.10.9-3.el7   </code></pre><p>开启docker服务</p><pre><code>systemctl enable --now docker</code></pre><p>镜像加速，在&#x2F;etc&#x2F;docker&#x2F;daemon.json文件中添加以下内容</p><pre><code>&#123;&quot;registry-mirrors&quot;:[&quot;https://reg-mirror.qiniu.com/&quot;]&#125; 参考：https://www.runoob.com/docker/docker-mirror-acceleration.html</code></pre><p>检查配置是否生效：</p><pre><code>$ docker infoRegistry Mirrors:    https://reg-mirror.qiniu.com</code></pre><h4 id="一键安装脚本"><a href="#一键安装脚本" class="headerlink" title="一键安装脚本"></a>一键安装脚本</h4><pre><code>[root@centos7 ~]#cat install_docker_for_centos7.sh #!/bin/bash##********************************************************************#Author:        wangxiaochun#QQ:            29308620#Date:          2020-01-26#FileName：      install_docker_for_centos7.sh#URL:           http://www.magedu.com#Description：       The test script#Copyright (C):     2020 All rights reserved#********************************************************************COLOR=&quot;echo -e \\033[1;31m&quot;END=&quot;\033[m&quot;VERSION=&quot;19.03.5-3.el7&quot;wget -P /etc/yum.repos.d/ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  || &#123; $&#123;COLOR&#125;&quot;互联网连接失败，请检查网络配置!&quot;$&#123;END&#125;;exit; &#125;yum clean all yum -y install docker-ce-$VERSION docker-ce-cli-$VERSION || &#123; $&#123;COLOR&#125;&quot;Base,Extras的yum源失败,请检查yum源配置&quot;$&#123;END&#125;;exit; &#125;</code></pre><h4 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h4><p>二进制安装下载路径<br><a href="https://download.docker.com/linux/">https://download.docker.com/linux/</a></p><p><a href="https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64/">https://mirrors.aliyun.com/docker-ce/linux/static/stable/x86_64&#x2F;</a></p><p>下载包并安装</p><pre><code>[root@centos8 ~]#wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.5.tgz--2020-01-24 18:02:55--  https://download.docker.com/linux/static/stable/x86_64/docker-19.03.5.tgzResolving download.docker.com (download.docker.com)... 143.204.83.37, 143.204.83.32, 143.204.83.95, ...Connecting to download.docker.com (download.docker.com)|143.204.83.37|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 63252595 (60M) [application/x-tar]Saving to: ‘docker-19.03.5.tgz’docker-19.03.5.tgz          100%[=========================================&gt;]  60.32M  11.3MB/s    in 5.6s    2020-01-24 18:03:02 (10.7 MB/s) - ‘docker-19.03.5.tgz’ saved [63252595/63252595][root@centos8 ~]#tar xvf docker-19.03.5.tgz docker/docker/docker-initdocker/dockerdocker/dockerddocker/runcdocker/ctrdocker/docker-proxydocker/containerddocker/containerd-shim[root@centos8 ~]#cp docker/* /usr/bin/[root@centos8 ~]#groupadd -r docker</code></pre><p>将Ubuntu1804或CentOS7基于包方式安装的相关文件复制到相应目录下</p><pre><code>[root@ubuntu1804 ~]#scp /lib/systemd/system/docker.* /lib/systemd/system/containerd.service  10.0.0.8:/lib/systemd/system/The authenticity of host &#39;10.0.0.8 (10.0.0.8)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:8mUO3Wy13Ktt5pRBKaOU40avmw1x0gH5XTPK48CEWoM.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#39;10.0.0.8&#39; (ECDSA) to the list of known hosts.root@10.0.0.8&#39;s password: docker.service                                             100% 1683   650.8KB/s   00:00  docker.socket                                              100%  197   303.3KB/s   00:00 containerd.service                                         100%  487   516.6KB/s   00:00 [root@centos8 ~]#systemctl daemon-reload[root@centos8 ~]#systemctl enable --now docker[root@centos8 ~]#docker versionClient: Docker Engine - Community Version:           19.03.5 API version:       1.40 Go version:        go1.12.12 Git commit:        633a0ea838 Built:             Wed Nov 13 07:22:05 2019 OS/Arch:           linux/amd64 Experimental:      falseServer: Docker Engine - Community Engine:  Version:          19.03.5  API version:      1.40 (minimum version 1.12)  Go version:       go1.12.12  Git commit:       633a0ea838  Built:            Wed Nov 13 07:28:45 2019  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          v1.2.10  GitCommit:        b34a5c8af56e510852c35414db4c1f4fa6172339 runc:  Version:          1.0.0-rc8+dev  GitCommit:        3e425f80a8c931f88e6d94a8c831b9d5aa481657 docker-init:  Version:          0.18.0  GitCommit:        fec3683</code></pre><p>测试：</p><pre><code>[root@centos8 ~]#docker run hello-worldUnable to find image &#39;hello-world:latest&#39; locallylatest: Pulling from library/hello-world1b930d010525: Pull complete Digest: sha256:9572f7cdcee8591948c2963463447a53466950b3fc15a247fcad1917ca215a2fStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><h4 id="CentOS8安装docker"><a href="#CentOS8安装docker" class="headerlink" title="CentOS8安装docker"></a>CentOS8安装docker</h4><p>在CentOS8上安装docker会自动安装podman。docker工具只是一个脚本，调用了Podman</p><pre><code>[root@centos8 ~]#dnf install docker[root@centos8 ~]#rpm -ql podman-docker/usr/bin/docker[root@centos8 ~]#cat /usr/bin/docker#!/bin/sh[ -f /etc/containers/nodocker ] || \echo &quot;Emulate Docker CLI using podman. Create /etc/containers/nodocker to quiet msg.&quot; &gt;&amp;2exec /usr/bin/podman &quot;$@&quot;[root@centos8 ~]#podman versionVersion:            1.4.2-stable2RemoteAPI Version:  1Go Version:         go1.12.8OS/Arch:            linux/amd64</code></pre><p>修改拉取镜像地址的顺序，提高速度</p><pre><code>[root@centos8 ~]#vim /etc/containers/registries.conf[registries.search]registries = [&#39;docker.io&#39;，&#39;quay.io&#39;，&#39;registry.redhat.io&#39;, &#39;registry.access.redhat.com&#39;]   </code></pre><h3 id="docker卸载"><a href="#docker卸载" class="headerlink" title="docker卸载"></a>docker卸载</h3><p>删除安装包：</p><pre><code>yum remove docker-ce</code></pre><p>删除镜像、容器、配置文件等内容：</p><pre><code>rm -rf /var/lib/docker</code></pre><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>各个docker容器运行在同一个docker主进程并且共用同一个宿主机的内核。因此docker的隔离性必然需要解决如下问题：</p><ul><li><p>怎么样保证每个容器都有不同的文件系统并且能互不影响？</p></li><li><p>一个docker主进程内的各个容器都是其子进程，如何实现允许一个容器内的不同进程的 (内存、缓存等)数据访问，但是不能跨容器直接访问其他容器的数据？</p></li><li><p>每个容器怎么解决IP及端口分配的问题？</p></li><li><p>多个容器的主机名能一样吗？</p></li><li><p>每个容器都要不要有root用户？怎么解决账户重名问题？</p></li></ul><p>以上问题的解决便用到namespace技术，namespace技术可以参考如下链接：<a href="https://mp.weixin.qq.com/s/d4VHKyGiCIHwrau74B4tPw">https://mp.weixin.qq.com/s/d4VHKyGiCIHwrau74B4tPw</a></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>启动三个容器用于以下验证过程：</p><pre><code># 拉取镜像docker pull nginx# 启动容器docker run  -d --name nginx-1 -p 80:80 nginxdocker run  -d --name nginx-2 -p 81:80 nginxdocker run  -d --name nginx-3 -p 82:80 nginx# 查看[root@localhost overlay2]# docker psCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES349dc29cf8aa   nginx     &quot;/docker-entrypoint.…&quot;   6 seconds ago    Up 5 seconds    0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   nginx-3e324641b9c3e   nginx     &quot;/docker-entrypoint.…&quot;   12 seconds ago   Up 11 seconds   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   nginx-23d811f1b783f   nginx     &quot;/docker-entrypoint.…&quot;   23 seconds ago   Up 21 seconds   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx-1</code></pre><h3 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h3><p>docker使用chroot技术使每个容器都有自己的独立根文件系统以实现文件系统的隔离。</p><p>查看容器ID</p><pre><code>/var/lib/containerd/io.containerd.runtime.v2.task/moby[root@localhost moby]# lltotal 0drwx--x--x. 2 root root 6 Dec 12 04:51 349dc29cf8aacab7f7f1ff651f887698dc3a419417834d2eb3570032505058c1drwx--x--x. 2 root root 6 Dec 12 04:51 3d811f1b783fd3bee14cc9d10dea74934530813cc3d65b7f58156e9b542e070ddrwx--x--x. 2 root root 6 Dec 12 04:51 e324641b9c3e722332b9cdbd8f8aeffc0f04aaf0421fef0b0699bb1e261d79e2</code></pre><p>查看容器对应的根文件系统位置</p><pre><code>[root@localhost moby]# docker inspect --format=&#39;&#123;&#123;.GraphDriver.Data.MergedDir&#125;&#125;&#39; 349dc29cf8aacab7f7f1ff651f887698dc3a419417834d2eb3570032505058c1/var/lib/docker/overlay2/f2e2bb3381063e69c20a5164887390e5eb6cd57fed28755f7c520204d4c4e093/merged[root@localhost moby]# cd /var/lib/docker/overlay2/f2e2bb3381063e69c20a5164887390e5eb6cd57fed28755f7c520204d4c4e093/merged</code></pre><p>进入根文件系统目录查看</p><pre><code>[root@localhost merged]# lltotal 12drwxr-xr-x. 2 root root 4096 Dec  4 19:00 bindrwxr-xr-x. 2 root root    6 Sep  3 08:10 bootdrwxr-xr-x. 1 root root   43 Dec 12 04:51 devdrwxr-xr-x. 1 root root   41 Dec  5 23:46 docker-entrypoint.d-rwxrwxr-x. 1 root root 1616 Dec  5 23:46 docker-entrypoint.shdrwxr-xr-x. 1 root root   19 Dec 12 04:51 etcdrwxr-xr-x. 2 root root    6 Sep  3 08:10 homedrwxr-xr-x. 1 root root   45 Dec  4 19:00 libdrwxr-xr-x. 2 root root   34 Dec  4 19:00 lib64drwxr-xr-x. 2 root root    6 Dec  4 19:00 mediadrwxr-xr-x. 2 root root    6 Dec  4 19:00 mntdrwxr-xr-x. 2 root root    6 Dec  4 19:00 optdrwxr-xr-x. 2 root root    6 Sep  3 08:10 procdrwx------. 2 root root   37 Dec  4 19:00 rootdrwxr-xr-x. 1 root root   23 Dec 12 04:51 rundrwxr-xr-x. 2 root root 4096 Dec  4 19:00 sbindrwxr-xr-x. 2 root root    6 Dec  4 19:00 srvdrwxr-xr-x. 2 root root    6 Sep  3 08:10 sysdrwxrwxrwt. 1 root root    6 Dec  5 23:46 tmpdrwxr-xr-x. 1 root root   66 Dec  4 19:00 usrdrwxr-xr-x. 1 root root   19 Dec  4 19:00 var</code></pre><p>验证：</p><pre><code>[root@localhost merged]# docker exec nginx-3 ls -ltotal 12drwxr-xr-x.   2 root root 4096 Dec  5 00:00 bindrwxr-xr-x.   2 root root    6 Sep  3 12:10 bootdrwxr-xr-x.   5 root root  340 Dec 12 09:51 devdrwxr-xr-x.   1 root root   41 Dec  6 04:46 docker-entrypoint.d-rwxrwxr-x.   1 root root 1616 Dec  6 04:46 docker-entrypoint.shdrwxr-xr-x.   1 root root   19 Dec 12 09:51 etcdrwxr-xr-x.   2 root root    6 Sep  3 12:10 homedrwxr-xr-x.   1 root root   45 Dec  5 00:00 libdrwxr-xr-x.   2 root root   34 Dec  5 00:00 lib64drwxr-xr-x.   2 root root    6 Dec  5 00:00 mediadrwxr-xr-x.   2 root root    6 Dec  5 00:00 mntdrwxr-xr-x.   2 root root    6 Dec  5 00:00 optdr-xr-xr-x. 240 root root    0 Dec 12 09:51 procdrwx------.   2 root root   37 Dec  5 00:00 rootdrwxr-xr-x.   1 root root   23 Dec 12 09:51 rundrwxr-xr-x.   2 root root 4096 Dec  5 00:00 sbindrwxr-xr-x.   2 root root    6 Dec  5 00:00 srvdr-xr-xr-x.  13 root root    0 Dec 12 07:47 sysdrwxrwxrwt.   1 root root    6 Dec  6 04:46 tmpdrwxr-xr-x.   1 root root   66 Dec  5 00:00 usrdrwxr-xr-x.   1 root root   19 Dec  5 00:00 var</code></pre><blockquote><p>MNT namespace 实现磁盘挂载点的隔离<br>IPC namespace 实现允许一个容器内的不同进程的(内存、缓存等)数据访问，但是不能跨容器直接访问其他容器的数据。</p></blockquote><h3 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h3><p>UTS namespace（UNIX Timesharing System包含了运行内核的名称、版本、底层体系结构类型等信息）用于系统标识，其中包含了主机名hostname 和域名domainname 。它使得一个容器拥有属于自己hostname标识，这个主机名标识独立于宿主机系统和其上的其他容器。</p><pre><code>[root@localhost merged]# docker ps -aCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                               NAMES349dc29cf8aa   nginx     &quot;/docker-entrypoint.…&quot;   38 minutes ago   Up 38 minutes   0.0.0.0:82-&gt;80/tcp, :::82-&gt;80/tcp   nginx-3e324641b9c3e   nginx     &quot;/docker-entrypoint.…&quot;   39 minutes ago   Up 38 minutes   0.0.0.0:81-&gt;80/tcp, :::81-&gt;80/tcp   nginx-23d811f1b783f   nginx     &quot;/docker-entrypoint.…&quot;   39 minutes ago   Up 39 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   nginx-1[root@localhost merged]# docker exec -it 34 sh# hostname349dc29cf8aa# cat /etc/hosts127.0.0.1localhost::1localhost ip6-localhost ip6-loopbackfe00::0ip6-localnetff00::0ip6-mcastprefixff02::1ip6-allnodesff02::2ip6-allrouters172.17.0.4349dc29cf8aa# uname -r3.10.0-1062.el7.x86_64# lscpuArchitecture:                    x86_64CPU op-mode(s):                  32-bit, 64-bitByte Order:                      Little EndianAddress sizes:                   42 bits physical, 48 bits virtualCPU(s):                          1On-line CPU(s) list:             0Thread(s) per core:              1Core(s) per socket:              1Socket(s):                       1NUMA node(s):                    1Vendor ID:                       GenuineIntelCPU family:                      6Model:                           141Model name:                      11th Gen Intel(R) Core(TM) i5-11400H @ 2.70GHzStepping:                        1CPU MHz:                         2688.002BogoMIPS:                        5376.00Hypervisor vendor:               VMwareVirtualization type:             fullL1d cache:                       48 KiBL1i cache:                       32 KiBL2 cache:                        1.3 MiBL3 cache:                        12 MiBNUMA node0 CPU(s):               0Vulnerability L1tf:              Not affectedVulnerability Mds:               Not affectedVulnerability Meltdown:          Not affectedVulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prct                                 l and seccompVulnerability Spectre v1:        Mitigation; Load fences, __user pointer sanitizationVulnerability Spectre v2:        Mitigation; Enhanced IBRS, IBPBFlags:                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge m                                 ca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall                                  nx pdpe1gb rdtscp lm constant_tsc arch_perfmon nopl x                                 topology tsc_reliable nonstop_tsc eagerfpu pni pclmulq                                 dq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popc                                 nt tsc_deadline_timer aes xsave avx f16c rdrand hyperv                                 isor lahf_lm abm 3dnowprefetch ssbd ibrs ibpb stibp ib                                 rs_enhanced fsgsbase tsc_adjust bmi1 avx2 smep bmi2 in                                 vpcid rdseed adx smap xsaveopt arat md_clear spec_ctrl                                  intel_stibp flush_l1d arch_capabilities</code></pre><h3 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h3><p>在Linux中，有一个PID为1的进程为其它所有进程的父进程。同理，在每个容器中也要有一个父进程，而容器之间进程的隔离采用PID namespace技术。</p><p>debian 系统安装基础命令</p><pre><code>apt updateapt install procps (top命令)apt install iputils-ping (ping命令)apt install net-tools (网络工具)</code></pre><p>查看容器内进程：</p><pre><code>[root@localhost merged]# docker exec -it 34 shps aux  #我们可以看到容器中id为1的进程为nginxUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot          1  0.0  0.0   8916   744 ?        Ss   09:51   0:00 nginx: master processnginx        29  0.0  0.1   9304  1092 ?        S    09:51   0:00 nginx: worker processroot         76  0.0  0.0   2468   628 pts/0    Rs   10:42   0:00 shroot        424  0.0  0.1   6744  1504 pts/0    R+   10:47   0:00 ps aux</code></pre><p>宿主机的PID究竟与容器内的PID是什么关系？</p><pre><code># 查看和docker相关的进程[root@localhost merged]# ps -ef|grep dockerroot       4284      1  0 04:02 ?        00:00:03 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockroot      57875   4284  0 04:51 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.17.0.2 -container-port 80root      57879   4284  0 04:51 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 80 -container-ip 172.17.0.2 -container-port 80root      57990   4284  0 04:51 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 81 -container-ip 172.17.0.3 -container-port 80root      57994   4284  0 04:51 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 81 -container-ip 172.17.0.3 -container-port 80root      58097   4284  0 04:51 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 82 -container-ip 172.17.0.4 -container-port 80root      58101   4284  0 04:51 ?        00:00:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 82 -container-ip 172.17.0.4 -container-port 80root      60530   2538  0 05:53 pts/0    00:00:00 grep --color=auto docker# 查看和containerd相关的进程[root@localhost merged]# ps -ef|grep containerdroot       3947      1  0 03:56 ?        00:00:03 /usr/bin/containerdroot      57891      1  0 04:51 ?        00:00:03 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 3d811f1b783fd3bee14cc9d10dea74934530813cc3d65b7f58156e9b542e070d -address /run/containerd/containerd.sockroot      58006      1  0 04:51 ?        00:00:03 /usr/bin/containerd-shim-runc-v2 -namespace moby -id e324641b9c3e722332b9cdbd8f8aeffc0f04aaf0421fef0b0699bb1e261d79e2 -address /run/containerd/containerd.sockroot      58113      1  0 04:51 ?        00:00:04 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 349dc29cf8aacab7f7f1ff651f887698dc3a419417834d2eb3570032505058c1 -address /run/containerd/containerd.sockroot      60730   2538  0 06:07 pts/0    00:00:00 grep --color=auto containerd# 查看某个containerd-shim-runc-v2相关的进程[root@localhost merged]# ps -ef|grep 57891root      57891      1  0 04:51 ?        00:00:04 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 3d811f1b783fd3bee14cc9d10dea74934530813cc3d65b7f58156e9b542e070d -address /run/containerd/containerd.sockroot      57911  57891  0 04:51 ?        00:00:00 nginx: master process nginx -g daemon off;root      60748   2538  0 06:08 pts/0    00:00:00 grep --color=auto 57891</code></pre><h3 id="NET-Namespace"><a href="#NET-Namespace" class="headerlink" title="NET Namespace"></a>NET Namespace</h3><p>docker使用NET Namespace实现网络隔离，在每个network space内部都类似于虚拟机一样有自己的网卡、监听端口、TCP&#x2F;IP协议栈等。</p><p><img src="http://www.yunweipai.com/wp-content/uploads/2020/06/image-20200122202720294.png" alt="image"></p><p>docker0实质就是Linux的虚拟网桥,网桥是OSI七层模型的数据链路层的网络设备。</p><p>通过brctl show命令查看宿主机上桥接设备：</p><pre><code>[root@localhost merged]# brctl showbridge namebridge idSTP enabledinterfacesdocker08000.02424bbbf88bnoveth4aa8bbb                                        veth4ff4cb3                                        veth67f8efavirbr08000.525400a46c62yesvirbr0-nic</code></pre><p>通过ifconfig查看宿主机网卡IP</p><pre><code>veth4aa8bbb: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet6 fe80::fc6b:38ff:feda:614b  prefixlen 64  scopeid 0x20&lt;link&gt;        ether fe:6b:38:da:61:4b  txqueuelen 0  (Ethernet)        RX packets 4118  bytes 285929 (279.2 KiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 4388  bytes 9949505 (9.4 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0veth4ff4cb3: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet6 fe80::6423:62ff:fed5:21c5  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 66:23:62:d5:21:c5  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 11  bytes 860 (860.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0veth67f8efa: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet6 fe80::c32:16ff:fec5:2127  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 0e:32:16:c5:21:27  txqueuelen 0  (Ethernet)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 24  bytes 2628 (2.5 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>通过ifconfig查看容器网卡IP</p><pre><code>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.17.0.4  netmask 255.255.0.0  broadcast 172.17.255.255        ether 02:42:ac:11:00:04  txqueuelen 0  (Ethernet)        RX packets 4586  bytes 10337173 (9.8 MiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 4317  bytes 300918 (293.8 KiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><h3 id="User-Namespace"><a href="#User-Namespace" class="headerlink" title="User Namespace"></a>User Namespace</h3><p>各个容器内可能会出现重名的用户和用户组名称，或重复的用户UID或者GID，那么怎么隔离各个容器内的用户空间呢？<br>User Namespace允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户UID和GID，只是会把用户的作用范围限制在每个容器内，即A容器和B容器可以有相同的用户名称和ID的账户，但是此用户的有效范围仅是当前容器内，不能访问另外一个容器内的文件系统，即相互隔离、互补影响、永不相见</p><p><img src="http://www.yunweipai.com/wp-content/uploads/2020/06/image-20200122094332796.png" alt="image"></p><h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>在一个容器，如果不对其做任何资源限制，则宿主机会允许其占用无限大的内存空间，有时候会因为代码bug程序会一直申请内存，直到把宿主机内存占完，为了避免此类的问题出现，宿主机有必要对容器进行资源分配限制，比如CPU、内存等，Linux Cgroups的全称是Linux Control Groups，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等。此外，还能够对进程进行优先级设置，以及将进程挂起和恢复等操作。该技术具体内容可以参照如下博客：<a href="https://juejin.cn/post/6923535735819763719">https://juejin.cn/post/6923535735819763719</a></p><h2 id="容器管理工具"><a href="#容器管理工具" class="headerlink" title="容器管理工具"></a>容器管理工具</h2><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>Docker 启动一个容器也需要一个外部模板，称为镜像。docke的镜像可以保存在一个公共的地方共享使用，需要时将镜像下载下来就可以使用。最主要的是可以在镜像基础之上做自定义配置并且可以再把其提交为一个镜像，一个镜像可以被启动为多个容器。</p><p>Docker的镜像是分层的，镜像底层为库文件且为只读层即不能写入也不能删除数据，从镜像加载启动为一个容器后会生成一个可写层，其写入的数据会复制到宿主机上对应容器的目录，但是容器内的数据在删除容器后也会被随之删除。<br><img src="http://www.yunweipai.com/wp-content/uploads/2020/06/image-20200122213106815.png" alt="image"></p><h3 id="podman"><a href="#podman" class="headerlink" title="podman"></a>podman</h3><p>Podman即Pod Manager tool，它是一个 为 Kubernetes 而生的开源的容器管理工具。原来是 CRI-O（即容器运行时接口CRI 和开放容器计划OCI） 项目的一部分，后来被分离成一个单独的项目叫 libpod。其可在大多数Linux平台上使用。它是一种无守护程序的容器引擎，用于在Linux系统上开发，管理和运行任何符合Open Container Initiative（OCI）标准的容器和容器镜像。</p><p>Podman 提供了一个与Docker兼容的命令行前端，Podman 里面87%的指令都和Docker CLI 相同。因此可以简单地认为Docker CLI是podman别名，即“ alias docker &#x3D; podman”。事实上，podman使用的一些库也是docker的一部分。目前，Podman已经被CentOS8集成。</p><p>podman和docker不同之处：</p><blockquote><p>docker 需要在我们的系统上运行一个守护进程(docker daemon)，这会产生一定的开销，而podman 不需要。</p><p>启动容器的方式不同：docker cli命令通过API跟Docker Engine(引擎)交互告诉它我想创建一个container，然后docker Engine才会调用OCI container runtime(runc)来启动一个container。这代表container的process(进程)不会是Docker CLI的child process(子进程)，而是Docker Engine的child process。Podman是直接跟OCI containner runtime(runc)进行交互来创建container的，所以container process直接是podman的child process。</p><p>因为docke有docker daemon，所以docker启动的容器支持–restart选项，但是podman不支持</p><p>docker需要使用root用户来创建容器。podman既可以由root用户运行，也可以由非特权用户运行。</p></blockquote><h2 id="容器相关技术"><a href="#容器相关技术" class="headerlink" title="容器相关技术"></a>容器相关技术</h2><p>容器技术除了的docker之外，还有coreOS的rkt，还有阿里的Pouch，为了保证容器生态的标准性和健康可持续发展，包括Linux 基金会、Docker、微软、红帽谷歌和、IBM等公司在2015年6月共同成立了一个叫open container（OCI）的组织，其目的就是制定开放的标准的容器规范，目前OCI一共发布了两个规范，分别是runtime spec和 image format spec，有了这两个规范，不同的容器公司开发的容器只要兼容这两个规范，就可以保证容器的可移植性和相互可操作性。</p><h3 id="容器runtime"><a href="#容器runtime" class="headerlink" title="容器runtime"></a>容器runtime</h3><p>runtime是真正运行容器的地方，为容器提供相应的运行环境。</p><p>目前主流的三种runtime</p><ul><li>lxc：linux上早期的runtime，Docker早期就是采用lxc作为runtime</li><li>runc：目前Docker默认的runtime，runc遵守OCI规范，因此可以兼容lxc</li><li>rkt：是CoreOS开发的容器runtime，也符合OCI规范，所以使用rkt也可以运行Docker容器</li></ul><h3 id="容器管理工具-1"><a href="#容器管理工具-1" class="headerlink" title="容器管理工具"></a>容器管理工具</h3><p>管理工具连接runtime与用户，对用户提供图形或命令方式操作，然后管理工具将用户操作传递给runtime执行。</p><ul><li>lxc是lxd的管理工具</li><li>Runc的管理工具是docker engine，docker engine包含后台deamon和cli两部分，大家经常提到的Docker就是指的docker engine</li><li>rkt的管理工具是rkt cli</li></ul><h3 id="容器定义工具"><a href="#容器定义工具" class="headerlink" title="容器定义工具"></a>容器定义工具</h3><p>容器定义工具允许用户定义容器的属性和内容，以方便容器能够被保存、共享和重建。</p><ul><li>Dockerfile：包含N个命令的文本文件，通过dockerfile创建出docker image。</li><li>Docker image：是docker 容器的模板，runtime依据docker image创建容器</li><li>ACI(App container image)：与docker image类似，是CoreOS开发的rkt容器的镜像格式</li></ul><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><p>统一保存镜像而且是多个不同镜像版本的地方，叫做镜像仓库</p><ul><li>Docker hub：docker官方的公共仓库，已经保存了大量的常用镜像，可以方便大家直接使用</li><li>阿里云，网易等第三方镜像仓库</li><li>Image registry：docker官方提供的私有仓库部署工具，无web管理界面，目前使用较少</li><li>Harbor：vmware提供的自带web界面自带认证功能的镜像仓库，目前有很多公司使用</li></ul><h3 id="编排工具"><a href="#编排工具" class="headerlink" title="编排工具"></a>编排工具</h3><p>当多个容器在多个主机运行的时候，单独管理容器是相当复杂而且很容易出错。同时也无法实现某一台主机宕机后容器自动迁移到其他主机从而实现高可用的目的。因此需要有一种工具可以实现统一管理、动态伸缩、故障自愈、批量执行等功能，这就是容器编排引擎。</p><p>容器编排通常包括容器管理、调度、集群定义和服务发现等功能</p><ul><li>Docker swarm：docker 开发的容器编排引擎</li><li>Kubernetes：google领导开发的容器编排引擎，内部项目为Borg，且其同时支持docker和CoreOS</li><li>Mesos+Marathon：Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。mesos(资源分配)与marathon(容器编排平台)一起提供容器编排引擎功能</li></ul><h3 id="docker依赖技术"><a href="#docker依赖技术" class="headerlink" title="docker依赖技术"></a>docker依赖技术</h3><p>容器网络：docker自带的网络docker network仅支持管理单机上的容器网络，当多主机运行的时候需要使用第三方开源网络，例如calico、flannel等</p><p>服务发现：容器的动态扩容特性决定了容器IP也会随之变化。因此需要有一种机制自动识别并将用户请求动态转发到新创建的容器上，kubernetes自带服务发现功能，需要结合kube-dns服务解析内部域名。</p><p>容器监控：可以通过原生命令docker ps&#x2F;top&#x2F;stats 查看容器运行状态，另外也可以使Prometheus 、heapster等第三方监控工具监控容器的运行状态</p><p>数据管理：容器的动态迁移会导致其在不同的Host之间迁移，因此如何保证与容器相关的数据也能随之迁移或随时访问，可以使用逻辑卷&#x2F;存储挂载等方式解决</p><p>日志收集：docker原生的日志查看工具docker logs。但是容器内部的日志需要通过ELK等专门的日志收集分析和展示工具进行处理</p><h3 id="docker命令帮助"><a href="#docker命令帮助" class="headerlink" title="docker命令帮助"></a>docker命令帮助</h3><p>查看docker命令帮助</p><pre><code>dockerman docker docker  --helpman docker-COMMANDdocker COMMAND --help</code></pre><p>docker版本</p><pre><code>[root@localhost merged]# docker versionClient: Docker Engine - Community Version:           20.10.21 API version:       1.41 Go version:        go1.18.7 Git commit:        baeda1f Built:             Tue Oct 25 18:04:24 2022 OS/Arch:           linux/amd64 Context:           default Experimental:      trueServer: Docker Engine - Community Engine:  Version:          20.10.21  API version:      1.41 (minimum version 1.12)  Go version:       go1.18.7  Git commit:       3056208  Built:            Tue Oct 25 18:02:38 2022  OS/Arch:          linux/amd64  Experimental:     false containerd:  Version:          1.6.12  GitCommit:        a05d175400b1145e5e6a735a6710579d181e7fb0 runc:  Version:          1.1.4  GitCommit:        v1.1.4-0-g5fd4c4d docker-init:  Version:          0.19.0  GitCommit:        de40ad0</code></pre><p>验证docker0网卡</p><p>在docker安装启动之后，默认会生成一个名称为docker0的网卡并且默认IP地址为172.17.0.1</p><pre><code>[root@localhost merged]# ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:c0:5c:81 brd ff:ff:ff:ff:ff:ff    inet 192.168.1.9/24 brd 192.168.1.255 scope global noprefixroute dynamic ens33       valid_lft 240631sec preferred_lft 240631sec    inet6 2408:8221:581c:8e80:be41:bbfd:6412:d184/64 scope global noprefixroute dynamic        valid_lft 2428sec preferred_lft 2428sec    inet6 fe80::61fb:3363:b674:ae48/64 scope link noprefixroute        valid_lft forever preferred_lft forever3: virbr0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default qlen 1000    link/ether 52:54:00:a4:6c:62 brd ff:ff:ff:ff:ff:ff    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0       valid_lft forever preferred_lft forever4: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000    link/ether 52:54:00:a4:6c:62 brd ff:ff:ff:ff:ff:ff5: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default     link/ether 02:42:4b:bb:f8:8b brd ff:ff:ff:ff:ff:ff    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0       valid_lft forever preferred_lft forever    inet6 fe80::42:4bff:febb:f88b/64 scope link        valid_lft forever preferred_lft forever</code></pre><p>查看docker相关信息</p><pre><code>[root@ubuntu1804 ~]#docker infoClient: Debug Mode: false     #client 端是否开启 debugServer: Containers: 2   #当前 主机运行的容器总数  Running: 0     #有几个容器是正在运行的  Paused: 0      #有几个容器是暂停的  Stopped: 2     #有几个容器是停止的 Images: 4       #当前服务器的镜像数 Server Version: 19.03.5   #服务端版本 Storage Driver: overlay2  #正在使用的存储引擎  Backing Filesystem: extfs   #后端文件系统，即服务器的磁盘文件系统  Supports d_type: true  #是否支持 d_type  Native Overlay Diff: true  #是否支持差异数据存储 Logging Driver: json-file   #日志类型  Cgroup Driver: cgroupfs  #cgroups 类型 Plugins:                  #插件  Volume: local            #卷   Network: bridge host ipvlan macvlan null overlay # overlay 跨主机通信  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog  #日志类型 Swarm: inactive    #是否支持 swarm Runtimes: runc     #已安装的容器运行时 Default Runtime: runc   #默认使用的容器运行时 Init Binary: docker-init   #初始化容器的守护进程，即 pid 为 1的进程 containerd version: b34a5c8af56e510852c35414db4c1f4fa6172339 #版本 runc version: 3e425f80a8c931f88e6d94a8c831b9d5aa481657  #runc 版本 init version: fec3683  #init 版本 Security Options:   #安全选项  apparmor     #安全模块，https://docs.docker.com/engine/security/apparmor/  seccomp  #安全计算模块，限制容器操作，https://docs.docker.com/engine/security/seccomp/   Profile: default  #默认的配置文件 Kernel Version: 4.15.0-29-generic  #宿主机内核版本 Operating System: Ubuntu 18.04.1 LTS  #宿主机操作系统 OSType: linux    #宿主机操作系统类型 Architecture: x86_64   #宿主机架构 CPUs: 1    #宿主机 CPU 数量 Total Memory: 962MiB   #宿主机总内存  Name: ubuntu1804.magedu.org #宿主机 hostname ID: IZHJ:WPIN:BRMC:XQUI:VVVR:UVGK:NZBM:YQXT:JDWB:33RS:45V7:SQWJ #宿主机 ID Docker Root Dir: /var/lib/docker  #宿主机关于docker数据的保存目录 Debug Mode: false   #server 端是否开启 debug Registry: https://index.docker.io/v1/  #仓库路径 Labels: Experimental: false  #是否测试版 Insecure Registries:  127.0.0.0/8  : #非安全的镜像仓库 Registry Mirrors:  https://si7y70hh.mirror.aliyuncs.com/   #镜像仓库 Live Restore Enabled: false  #是否开启 活动重启 (重启docker-daemon 不关闭容器 )WARNING: No swap limit support  #系统警告信息 (没有开启swap资源限制 )</code></pre><p>注：VPC是云上私有网络。</p><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. [http://www.yunweipai.com/34721.html](http://www.yunweipai.com/34721.html)  </p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文主要介绍容器化底层实现技术（chroot、namespace、cgroup）、docker安装和卸载、容器管理工具的相关内容。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;Docker基础知</summary>
      
    
    
    
    <category term="云原生" scheme="http://example.com/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux集群基础概念</title>
    <link href="http://example.com/2022/12/04/Linux%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2022/12/04/Linux%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2022-12-04T11:14:41.278Z</published>
    <updated>2022-12-04T11:13:16.142Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><pre><code>LAMP    http,web object简单无状态连接     假设200个并发用户，50个动态请求，150个静态请求（静态进程占据2M空间 动态进程占10M空间）共500+150*2=800M。配置了一个4G内存  2cpu的机器来处理就可以满足。   apache：进程切换，查询mysql， 网络IO，磁盘IO也会影响性能      假设增长至1000个并发用户，200个动态请求，800个静态请求，共1600+2000=3600M。配置了一个4G内存 2cpu无法满足需求 解决方案：    Scale ON  :向上扩展   换更好的硬件，如换主机     注意：Scale On向上扩展，硬件增长比例与性能增长比例是不成线性的。而且相对于成本是高昂的。        Scale Out:  向外扩展 增加服务器。</code></pre><h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><pre><code> Scale Out如何分配调度多台主机     DNS解析：同一个域名解析为多条IP地址。     缺陷：DNS解析比如A用户第一次访问-》DNS解析-》存到缓存-》分配服务器。也就是说A用户经过一次访问,状态被存在缓存里，之后再次访问还是会被分配到同一台服务器。导致不会根据现有的情况时时分发。以及每台主机都必须有独立IP。 解决方案：     在多台机器的上层添加一个调度器。先访问调度器，调度器分配相应的机器处理。     调度方式：        Round Robin: 轮调            同一个客户端请求，并发的资源可能来自多台服务器。                WRR:weight Round Robin 加权轮调；服务器的硬件，性能有所差异.             考虑公平以及效率，权重weight。能者多劳。</code></pre><h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><pre><code>不同服务器之间数据的同步（服务器需要读写MySQL数据库的内容，服务器需要提交相应文件保存以及服务器上某个页面更新）      服务器之间MySQL数据库的内容的同步              独立出来一台主机做为MYSQL服务器使用。不同服务器中的数据保存在同一mysql服务器中，解决数据同步问题。      服务器提交文件同步，例如发帖           发帖中的附件不能保存在数据库中，附件保存在其他存储设备中，数据库里面仅是一个指针指向附件具体存储的位置。为了使附件也能在不同服务器进行访问，数据同步，可以在独立出来一台主机作为NFS服务器使用，附件则保存在NFs中，多台服务器都可以直接访问和存储。      服务器上某个页面更新同步          网页的页面文件不应该放在NFS上，页面文件要放在本地服务器上，这样减少请求响应的时间。每台本地服务器上都存放页面文件的话，页面更新困难。为了解决页面文件的更新困难问题，使用一台作为主的页面文件主机，每次只是更新这一台，并通知其他服务器，让其他主机主动过来参照更新页面文件。            实现 ：rsync 只复制有差异的文件 ，可以远程                  同步复制文件机制：                      例行计划任务+通知机制（更新即通知）                      机制： rsync+inotify 通知机制（更新即通知）                  实时监控，页面一有更新，就通知，从服务器就来复制。</code></pre><h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><pre><code>Cluster     LB:   load Balancing: 负载均衡集群     HA:High Availiable 高可用     注意：负载均衡集群具有高可用的能力，但不是高可用集群。高可用集群的主机之间要进行通信，发送heartbeat，以及宕机后，快速切换服务。    而负载均衡集群的高可用能力是通过上面的调度服务器调度来实现。调度服务器如何知道后端服务器的是否在线或宕机，而进行调度分配？    对后端服务器的健康检查；    health check:健康检查       检查多次，检查在是否可用，不可用，则重新调度，即从集群中移除，如果检查发现，有可用的集群服务器，就将其加入到集群服务器中，接受调度分配。   &#39;检查活到死，死到活&#39;当服务器增多，调度器的资源有限，可能会成为整个系统的瓶颈。       为了解决上述问题，进行功能切分。不同功能进行不同集群。使调度器的效率很高。单一调度器，可能会出现宕机，损坏等，所以要为调度器配备一个备用的调度服务器。        primary-------standby     standy:具备和primary配置一样，IP地址进行切换，自己服务启动。    primary 和 standby时刻通信，发送heartbeat（心跳数）,一旦宕机，立即启动，进行切换。如果有两个服务都要进行高可用。第一个服务需要两台机器，第二个服务也需要两台机器。从而造成资源浪费。    整合起来，web  和 mail 互为高可用 。运行的服务是分开的。        host1：IP1  web       host2:IP2   mail     注意：某个资源只能被某个节点所占用    node：节点   主机 </code></pre><h3 id="高可用集群："><a href="#高可用集群：" class="headerlink" title="高可用集群："></a>高可用集群：</h3><pre><code>负载均衡集群以提高服务的并发处理能力为着眼点的，高可用集群是提高系统始终在线能力为着眼点的。LB：增加处理能力的,并发处理能力。HA：增加系统的服务可用性可用性= 正常在线时间/正常在线时间+故障处理时间    在线时间/（在线时间+故障时间） 99%，99.9%提高了10倍的可用性  99.99% 99.999% 多个服务器互为高可用集群，要设置优先级。连接到同一个交换机上，用组播的方式时时发送heartbeat以及集群事务等信息。 DC：推选的事务协调员，如果挂了，就重新推选。 假如部署了一个web集群，集群中包含一个 primary 和一个 standby。NFS可能是性能瓶颈。    primary：IP，web app, 页面----- standby：IP,web app,页面                        NFS （瓶颈）        共享存储：       1.RAID   DAS   块级别       2.NFS    NAS   文件级别        RAID与NFS         NFS对前端服务器而言，NFS就是文件共享服务器。数据请求是在文件级别上完成的。网络上是以文件         RAID,是磁盘阵列，是通过主板上的总线连接到RAID上，相当于本地存储设备，数据是在块级别上交换的。         NAS:Network Attached Storage 网络附加存储。            NFS自身由于是将数据发送到NFS主机上进行的写操作所以可以锁定两个同时写的操作。阻塞另一台主机的写操作。         DAS：Direct Attached Storage直接附加存储            磁盘：块级别              一个文件包含多个块。            过DAS机制，若两个进程工作在一台主机上同时处理同一个文件，可以通过加锁，防止同时处理同一个文件。 当两个进程工作在两个主机上，都同时处理DAS上的主机同一文件。这时，两个主机同时加载同一个文件到各自内存里，修改后，将文件写回到DAS里，如果交叉，会是存储混乱。</code></pre><p>如果由于没有及时传递heartbear信息，结果切换到备用的调度服务器，而主调度服务器还在写数据到DAS中，而standby也同时写同一个文件。左右就不协调了，称为split-brain:脑裂</p><pre><code> 后果：节点间争夺共享磁盘（即资源）的访问权，都对共享文件系统产生读写操作，从而导致共享磁盘文件系统损坏。                   解决方案：如果切换主机了，进行如下操作。          1.STONITH：(Shoot The Other Node In The Head)通过电源交换机（切断主机的电源）节点级别          2.fencing：隔离 拒绝某一节点访问某一资源的机制，使服务器和存储设备断开。需要共享存储有相应的功能。资源级别 为了防止脑裂,集群分裂，高可用集群至少有3个节点，奇数个节点，仲裁机制，少数服从多数。</code></pre><p>补充：</p><pre><code> 脑裂：本来一个大脑的两半球互相配合，变成了分裂成两个独立的大脑，都认为对方已死。在集群环境中，有这么几种可能造成&quot;Split-Brain&quot;现象： 1、在集群环境中的节点间的心跳线同时断掉后，集群系统所处于的一种特殊状态。例如节点1和2组成一个集群，突然1和2间的心跳同时都断了，如果此前节点1正在运行应用，心跳都断掉后2开始去接管应用，强行加载数据，此时就是split-brain。 2、集群中节点因为处理器忙或者其他原因暂时停止响应时，其他节点可能误认为该节点“已死”。</code></pre><h3 id="HP-高性能集群（HBC）"><a href="#HP-高性能集群（HBC）" class="headerlink" title="HP:高性能集群（HBC）"></a>HP:高性能集群（HBC）</h3><pre><code>并行计算（处理）集群：        分布式文件系统        将大大任务切割为是小任务，分别进行处理的机制。化整为零---&gt;合并整合    每台计算机只处理所有数据的一部分，且每台计算机上只存储一部分数据。    每个节点既是计算节点，也是存储节点。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;场景一&quot;&gt;&lt;a href=&quot;#场景一&quot; class=&quot;headerlink&quot; title=&quot;场景一&quot;&gt;&lt;/a&gt;场景一&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;LAMP 

   http,web object简单无状态连接 
 
   假设200个并发用户，50个动态请求，</summary>
      
    
    
    
    <category term="Linux集群" scheme="http://example.com/categories/Linux%E9%9B%86%E7%BE%A4/"/>
    
    
    <category term="集群" scheme="http://example.com/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>MySQL系列</title>
    <link href="http://example.com/2022/12/04/MySQL/"/>
    <id>http://example.com/2022/12/04/MySQL/</id>
    <published>2022-12-04T09:07:47.746Z</published>
    <updated>2022-12-04T09:07:47.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库基础理论"><a href="#关系型数据库基础理论" class="headerlink" title="关系型数据库基础理论"></a>关系型数据库基础理论</h2><h3 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h3><p>在Linux中新建一个用户时，用户信息会存储于&#x2F;etc&#x2F;password文件中，密码信息则存储到&#x2F;etc&#x2F;shadow文件中。以上两个文件通过用户名进行连接。</p><pre><code>[root@192 blob]# cat /etc/passwd|headroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologin[root@192 blob]# head /etc/shadowroot:md5(passwrod+solt)::0:99999:7:::</code></pre><p>由于Linux中的用户数量往往不多，用文件进行存储也是十分不错的选择。假设随着我们的数据量和数据文件不断增加，这时继续使用文件进行存储将会出现如下问题：</p><blockquote><ol><li><p>数据冗余和不一致性。数据冗余：在每个shell脚本的开头都会出现&#x2F;bin&#x2F;shell，因此冗余量很大；不一致性，比如有一个数据在多个文件中都被使用，那么修改的时候，需要把每个文件都手动修改。</p></li><li><p>数据访问困难。如果数据库有上千万行数据，那么我们使用时，需要把这上千万行数据全部载入内存中，再使用，对硬件的要求会很高而且载入时间很长，但其实我们需要比较的也只是那一行数据而已。</p></li><li><p>数据孤立。由于数据保存在不同的文件里面，所以这些文件之间的格式可能各不相同，所以后续开发一个软件来管理的话非常困难，因为它们不满足某一个规范，使得数据之间是相互孤立的。</p></li><li><p>完整性问题。例如两个转账的用户之间数额的总和应该是一样的，但如果在转账的过程中出现了问题，那么文件就无法解决，除非应用程序设计上解决，但应用程序本身并无法理解数据之间的逻辑问题。</p></li><li><p>原子性问题。类似于完整性问题，数据必须从一个稳定的状态转换为另外一个稳定的状态。</p></li><li><p>并发访问异常问题。按道理来讲，如果一个用户访问数据库文件的前十行，另一个用户访问最后十行，本身他们俩并不会冲突，但如果某个用户需要修改的话，另外一个用户并不能访问。因为为了保证文件的完整性，我们会加锁的，但文件级别的锁安全性太高，并不适合这种访问。</p></li><li><p>安全性问题。部分访问授权很难实现，很难使某一个用户只能看到其中指定的某些字段。</p></li></ol></blockquote><p>因为有了以上问题，所以才出现了关系型数据库。数据库是数据的汇集，它以一定的组织形式存于存储介质上。DBMS是管理数据库的系统软件，它实现数据库系统的各种功能。</p><h3 id="MySQL逻辑结构"><a href="#MySQL逻辑结构" class="headerlink" title="MySQL逻辑结构"></a>MySQL逻辑结构</h3><p>mysql数据库逻辑请求过程如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9a60157dd2104196486269ee6ea92f57?method=download&shareKey=b23584ab250b36b0d557fbbaee576d03" alt="image"></p><ul><li>表管理器：负责创建、读取或修改表定义文件；维护表描述符高速缓存；管理表锁；表结构定义文件  </li><li>表修改模块：表创建、删除、重命名、移除、更新或插入之类的操作；  </li><li>表维护模块：检查、修改、备份、恢复、优化(碎片整理)及解析；  </li><li>缓冲区管理器：缓存置换策略、被钉住的块；</li><li>连接管理器：接受请求、创建线程、认证用户、建立安全连接</li></ul><blockquote><p>mysql是可插拔式的存储引擎。5.5.8之前，默认存储引擎是MyISAM，5.5.8之后，默认存储引擎是InnoDB。其中，MyISAM不支持事务，而InnoDB支持事务。所以InnoDB更适合在线事务处理。</p></blockquote><p>mysql使用的是是单进程多线程。数据库通常是一个系统中最慢的节点所在，那么应该怎样提高数据的交互速度。</p><ol><li>缓存：第一次查询后保存缓存第二次访问时直接使用结果。</li><li>线程重用：当用户退出之后,它的线程空闲下来之后不直接删除该线程，放在空闲线程池中。如果以后用户访问,直接用这个空闲的线程去响应它。</li></ol><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>SQL是专门设计用来进行数据库定义和数据操纵的数据库语言。它由如下部分组成：</p><ul><li><p>DML：数据操作语言，增删改查都是DML语句：INSERT、DELETE、UPDATE、SELECT</p></li><li><p>DDL：数据定义语言，实现数据对象的存储和定义。CREATE、DROP、ALTER</p><ul><li><p>关系数据库RDB的对象基本有：库、表、索引、视图、用户、存储过程、触发器、事件调度器等。</p></li><li><p>实现数据定义时，必须考虑数据的约束关系。数据库需要能够自己检查出来有没有逻辑性的错误，所以建立的时候注意它的有效数据范围。</p><ul><li>域约束：数据类型的约束</li><li>外键约束：引用完整性约束</li><li>主键约束：某字段能唯一标识此字段所属的实体，并且不允许为空,一张表中只能有一个主键</li><li>唯一性约束：每一行的某字段都不允许出现相同值，可以为空，一张表中可以有多个</li><li>检查性约束：比如年龄只能时int型</li></ul></li></ul></li><li><p>DCL：数据控制语言。GRANT、REVOKE，用来定义数据库中用户的访问权限</p></li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>数据库中的行分为定长和变长两种  </p><p>文件中记录组织方式：  </p><pre><code>堆文件组织：一条记录可以放在文件中的任何地方；顺序文件组织：根据“搜索码”值顺序存放；散列文件组织：将记录某个属性或者属性组值，依据散列函数计算出其应该存放的位置：桶号。检索的效率和更新的效率都有一定的提升。</code></pre><p><a href="https://blog.csdn.net/lcl_xiaowugui/article/details/81450770">https://blog.csdn.net/lcl_xiaowugui&#x2F;article&#x2F;details&#x2F;81450770</a></p><h2 id="MySQL的安装"><a href="#MySQL的安装" class="headerlink" title="MySQL的安装"></a>MySQL的安装</h2><p>数据库安装的三种方式</p><pre><code>专用软件管理器包：deb, rpm包安装通用二进制格式包    gcc: x86, x64    [https://www.cnblogs.com/gshelldon/p/13387636.html](https://www.cnblogs.com/gshelldon/p/13387636.html)源代码    5.5, 5.6        cmake</code></pre><h3 id="MySQL-5-5的源代码安装"><a href="#MySQL-5-5的源代码安装" class="headerlink" title="MySQL-5.5的源代码安装"></a>MySQL-5.5的源代码安装</h3><h4 id="安装cmake"><a href="#安装cmake" class="headerlink" title="安装cmake"></a>安装cmake</h4><p>cmake的重要特性之一是其独立于源码(out-of-source)的编译功能，即编译工作可以在另一个指定的目录中而非源码目录中进行，这可以保证源码目录不受任何一次编译的影响，因此在同一个源码上可以进行多次不同的编译，如针对于不同平台编译。  </p><pre><code># tar xf cmake-2.8.8.tar.gz# cd cmake-2.8.8# ./bootstrap# make # make install</code></pre><h4 id="编译安装mysql"><a href="#编译安装mysql" class="headerlink" title="编译安装mysql"></a>编译安装mysql</h4><p>使用cmake编译mysql-5.5  </p><p>cmake指定编译选项的方式不同于make，其实现方式对比如下：</p><pre><code>./configure           cmake ../configure --help    cmake . -LH or ccmake .</code></pre><p>指定安装文件的安装路径时常用的选项：</p><pre><code>-DCMAKE_INSTALL_PREFIX=/usr/local/mysql-DMYSQL_DATADIR=/data/mysql-DSYSCONFDIR=/etc</code></pre><p>默认编译的存储引擎包括：csv、myisam、myisammrg和heap。若要安装其它存储引擎，可以使用类似如下编译选项：</p><pre><code>-DWITH_INNOBASE_STORAGE_ENGINE=1-DWITH_ARCHIVE_STORAGE_ENGINE=1-DWITH_BLACKHOLE_STORAGE_ENGINE=1-DWITH_FEDERATED_STORAGE_ENGINE=1</code></pre><p>若要明确指定不编译某存储引擎，可以使用类似如下的选项：</p><pre><code>-DWITHOUT_&lt;ENGINE&gt;_STORAGE_ENGINE=1比如：-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1-DWITHOUT_FEDERATED_STORAGE_ENGINE=1-DWITHOUT_PARTITION_STORAGE_ENGINE=1</code></pre><p>如若要编译进其它功能，如SSL等，则可使用类似如下选项来实现编译时使用某库或不使用某库：</p><pre><code>-DWITH_READLINE=1-DWITH_SSL=system-DWITH_ZLIB=system-DWITH_LIBWRAP=0</code></pre><p>其它常用的选项：</p><pre><code>-DMYSQL_TCP_PORT=3306-DMYSQL_UNIX_ADDR=/tmp/mysql.sock-DENABLED_LOCAL_INFILE=1-DEXTRA_CHARSETS=all-DDEFAULT_CHARSET=utf8-DDEFAULT_COLLATION=utf8_general_ci-DWITH_DEBUG=0-DENABLE_PROFILING=1</code></pre><p>如果想清理此前的编译所生成的文件，则需要使用如下命令：</p><pre><code>make cleanrm CMakeCache.txt</code></pre><p>安装mysql-5.5</p><pre><code># groupadd -r mysql# useradd -g mysql -r -d /data/mydata mysql# tar xf mysql-5.5.25a.tar.gz # cd mysql-5.5.25a# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \          -DMYSQL_DATADIR=/mydata/data \          -DSYSCONFDIR=/etc \          -DWITH_INNOBASE_STORAGE_ENGINE=1 \          -DWITH_ARCHIVE_STORAGE_ENGINE=1 \          -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \          -DWITH_READLINE=1 \          -DWITH_SSL=system \          -DWITH_ZLIB=system \          -DWITH_LIBWRAP=0 \          -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \          -DDEFAULT_CHARSET=utf8 \          -DDEFAULT_COLLATION=utf8_general_ci# make # make install</code></pre><p><a href="https://www.cnblogs.com/gshelldon/p/13387697.html">https://www.cnblogs.com/gshelldon/p/13387697.html</a></p><h3 id="MySQL的安装设置"><a href="#MySQL的安装设置" class="headerlink" title="MySQL的安装设置"></a>MySQL的安装设置</h3><h4 id="MySQL字符集"><a href="#MySQL字符集" class="headerlink" title="MySQL字符集"></a>MySQL字符集</h4><p>MySQL数据库在存储数据时，默认编码是latin1，存储中文字符时，在显示或者web调用时会显示为乱码，所以需要修改MySQL默认字符集为UTF-8，有两种方法：</p><ul><li><p>编辑vim &#x2F;etc&#x2F;my.cnf配置文件，在相应段中加入相应的参数字符集，修改完毕后，重启MySQL服务器即可，具体内容如下：</p><pre><code>  [client]字段中加入：default-character-set=utf8  [mysqld]字段中加入：character-set-server=utf8  [mysql]字段中加入：default-character-set=utf8</code></pre></li><li><p>MySQL命令行中运行如下指令</p><pre><code>  show variables like &#39;%char%&#39;;  SET character_set_client = utf8;  SET character_set_results = utf8;  SET character_set_connection = utf8;</code></pre></li></ul><p>最终结果如下图所示：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc9afea5993905eaa56f86490f242a050?method=download&shareKey=aa26962a768ed35c90e6e1a61cbaef49" alt="image"></p><h4 id="MySQL忘记密码"><a href="#MySQL忘记密码" class="headerlink" title="MySQL忘记密码"></a>MySQL忘记密码</h4><p>如果有一天忘记了mysql的密码，可以参照如下进行操作（这个需要先关闭数据库）：</p><pre><code>[root@server1 ~]# systemctl stop mariadb[root@server1 ~]# mysqld_safe --user=mysql --skip-grant-tables &amp;[1] 1416[root@server1 ~]# 180805 19:24:38 mysqld_safe Logging to &#39;/var/log/mariadb/mariadb.log&#39;.180805 19:24:38 mysqld_safe Starting mysqld daemon with databases from /var/lib/mysql[root@server1 ~]# mysqlWelcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 1Server version: 5.5.44-MariaDB MariaDB ServerCopyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.MariaDB [(none)]&gt; use mysqlReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [mysql]&gt; update user set password=password(&#39;123456&#39;) where user=&#39;root&#39;;Query OK, 3 rows affected (0.00 sec)Rows matched: 3  Changed: 3  Warnings: 0MariaDB [mysql]&gt; exitBye[root@server1 ~]# systemctl start mariadb[root@server1 ~]# mysql -uroot -p123456Welcome to the MariaDB monitor.  Commands end with ; or \g.Your MariaDB connection id is 3Server version: 5.5.44-MariaDB MariaDB ServerCopyright (c) 2000, 2015, Oracle, MariaDB Corporation Ab and others.Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.MariaDB [(none)]&gt; </code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>MySQL数据库索引可以用来快速寻找某些具有特定值的记录，所有MySQL索引都以B+树的形式保存。如果MySQL查询中没有索引，执行select时会从第一个记录开始扫描整个表的所有记录，直到找到符合要求的记录。如果在需要搜索条件的列上创建了索引，MySQL无须扫描全表记录即可快速得到相应的记录行。</p><p>MySQL数据库常见索引类型包括：普通索引(normal)，唯一索引(unique)，全文索引(full text)，主键索引(primary key)，组合索引等。</p><pre><code>普通索引：normal，使用最为广泛唯一索引：unique，不允许重复的索引，允许有空值全文索引：full text，只能用于MyISAM，full text主要用于大量的内容检索主键索引：primary key又称为特殊的唯一索引，不允许有空值组合索引：为提高MySQL效率可建立组合索引</code></pre><p>MySQL数据库创建、查看、删除各个索引命令(都以t1表为例)</p><pre><code>创建索引：主键索引：ALTER TABLE t1 ADD PRIMARY KEY(&#39;column&#39;);唯一索引：ALTER TABLE t1 ADD UNIQUE(&#39;column&#39;);普通索引：ALTER TABLE t1 ADD INDEX index_name(&#39;column&#39;);全文索引：ALTER TABLE t1 ADD FULETEXT(&#39;column&#39;);组合索引：ALTER TABLE t1 ADD INDEX index_name(column1,column2);查看表索引show index from t1;show keys from t1;删除索引DROP INDEX index_name ON t1;ALTER TABLE t1 DROP INDEX index_name;ALTER TABLE t1 DROP PRIMARY KEY;</code></pre><p>MySQL数据库索引的缺点：</p><blockquote><p>MySQL数据库索引虽然能提高数据库的查询速度，但同时会降低更新、删除、插入表的速度。例如对表进行insert, update, delete时，MySQL不仅要保存数据，还要保存更新索引；建立索引会占用磁盘空间，大表上创建了多种索引组合，索引文件就会占用大量的空间。</p></blockquote><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>慢查询就是将执行时间超过阈值的SQL语句记录到相应日志中，可以帮助我们分析当前系统中那些SQL可能存在问题。MySQL数据库默认没有开启慢查询日志功能，需要手动在配置文件或者MySQL命令行中开启。慢查询日志默认写入磁盘中的文件，也可以将慢查询日志写入到数据库表中。</p><p>看数据库是否开启慢查询,命令如下：</p><pre><code>show variables like &#39;%slow%&#39;;show variables like &#39;%long_query%&#39;;</code></pre><p>MySQL慢查询参数详解</p><ul><li><p>low_query_log：是否开启慢查询日志，1表示开启，0表示关闭。</p></li><li><p>long_query_time：慢查询阈值，当查询时间多于设定的阈值时，记录日志。</p></li><li><p>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。</p></li><li><p>log_output：log_output&#x3D;’FILE’表示将日志存入文件，log_output &#x3D; ‘TABLE’ 表示将日志存入数据库。</p></li><li><p>log-slow-queries：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p></li><li><p>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</p></li></ul><p>开启MySQL慢查询日志方法有以下两种</p><ul><li><p>MySQL数据库命令行执行命令</p><pre><code>  set global slow_query_log = on;  show variables like &#39;%slow%&#39;;</code></pre></li><li><p>编辑my.cnf配置文件</p><pre><code>  [mysqld]  log-slow-queries = /data/mysql/slow.log   log_query_time = 0.01  log-queries-using-indexes</code></pre></li></ul><p>慢查询功能开启之后，数据库会自动将执行时间超过设定时间的SQL语句添加到慢查询日志文件中，可以通过慢查询日志文件定位到执行慢的SQL，从而对其优化。</p><p>通过mysqldumpslow命令行工具分析日志。执行命令mysqldumpslow -h可以查看命令帮助信息。主要参数包括-s 和 -t,其中 -s是排序参数，可选项详解如下：</p><pre><code>-s：排序参数    l：查询锁的总时间    r：返回记录数    t：查询总时间排序    al：平均锁定时间    ar：平均返回记录数    at：平均查询时间    c：计数-t n :显示头n条记录-g ：过滤</code></pre><p>MySQL慢查询按照返回的行数从大到小，查看前两行：</p><pre><code>mysqldumpslow -s r -t 2 slow.log</code></pre><p>按照查询总时间从大到小，查看前5行，同时过滤select的SQL语句</p><pre><code>mysqldumpslow -s t -t 5 -g &quot;select&quot; slow.log</code></pre><h4 id="mysql引擎"><a href="#mysql引擎" class="headerlink" title="mysql引擎"></a>mysql引擎</h4><blockquote><p>MyISAM是MySQL 5.0之前的默认数据库引擎。拥有较高的插入、查询速度，但不支持事务。</p><p>InnoDB事务型数据库的首选引擎，支持ACID事务。ACID包括原子性、一致性、隔离性、持久性。一个支持事务的数据库，必须具有这四个特性，否则在执行事务的过程中无法保证数据的正确性。MySQL 5.5之后默认引擎为InnoDB，InnoDB支持行级锁定，支持事务、外键等功能。</p><p>BDB源自Berkeley DB，事务型数据库的另一种选择，支持Commit和Rollback等其他事务特性。</p><p>Memory所有数据置于内存的存储引擎，拥有极高的插入、更新和查询效率。但是会占用和数据量成正比的内存空间，并且其内容会在MySQL重新启动时丢失。</p></blockquote><p>MyISAM类型的数据库表强调的是性能，其执行速度比InnoDB类型更快，但不支持事务和外键。如果执行大量的select操作，MyISAM是更好的选择，支持表锁。 InnoDB提供事务、外键、行锁等功能。当执行大量的insert或update操作，出于性能方面的考虑可以使用InnoDB引擎。</p><p>存储引擎，也被称为表类型：</p><p>MyISAM:</p><pre><code>无事务、表锁不支持外键B树索引、FULLTEXT索引、空间索引    支持表压缩    每表三个文件：            .frm: 表结构            .MYD：表数据            .MYI：表索引</code></pre><p>InnoDB：</p><pre><code>事务，行锁B树索引、聚簇索引、自适应hash索引表空间，raw磁盘设备；所有表共享一个表空间文件；建议：每表一个独立的表空间文件；      .frm: 表结构      .ibd: 表空间（表数据和表索引）</code></pre><p>查看存储引擎</p><pre><code>    SHOW ENGINES    SHOW TABLE STATUS [LIKE ...]</code></pre><h4 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h4><p>MySQL用户密码修改：</p><pre><code># mysqladmin -u USERNAME -h HOSTNAME password &#39;NEW_PASS&#39; -pmysql&gt; SET PASSWORD FOR &#39;USERNAME&#39;@&#39;HOST&#39;=PASSWORD(&#39;new_pass&#39;); mysql&gt; UPDATE mysql.user SET PASSWORD=PASSWORD(&#39;new_pass&#39;) WHERE CONDITION;</code></pre><p>MySQL自动登录</p><pre><code>读取配置文件的顺序/etc/my.cnf --&gt; /etc/mysql/my.cnf --&gt; $MYSQL_HOME/my.cnf --&gt; --default-extra-file=/path/to/somefile --&gt; ~/.my.cnf配置文件内容：    [client]        host =         user =         passwd = 手动指定配置：mysql --default-extra-file=/path/to/somefile</code></pre><p>MySQL编码和排序</p><pre><code>mysql&gt; SHOW CHARACTER SET;mysql&gt; SHOW COLLATION;</code></pre><p>MySQL服务器变量</p><pre><code>作用域，分为两类：    全局变量        SHOW GLOBAL VARIABLES    会话变量        SHOW [SESSION] VARIABLES生效时间，分为两类：    动态：可即时修改    静态：        写在配置文件中        通过参数传递给mysqld动态调整参数的生效方式：    全局：对当前会话无效，只对新建立会话有效；    会话：即时生效，但只对当前会话有效；服务器变量：@@变量名    显示：SELECT    设定：SET GLOBAL|SESSION 变量名=&#39;value&#39;</code></pre><p><a href="https://blog.csdn.net/lcl_xiaowugui/article/details/81451571?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165796763116782184645360%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165796763116782184645360&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-3-81451571-null-null.185%5Ev2%5Econtrol&utm_term=MYSQL%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4450">https://blog.csdn.net/lcl_xiaowugui&#x2F;article&#x2F;details&#x2F;81451571?ops_request_misc&#x3D;%257B%2522request%255Fid%2522%253A%2522165796763116782184645360%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id&#x3D;165796763116782184645360&amp;biz_id&#x3D;0&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>blog</del>first_rank_ecpm_v1~rank_v31_ecpm-3-81451571-null-null.185^v2^control&amp;utm_term&#x3D;MYSQL%E5%AE%89%E8%A3%85&amp;spm&#x3D;1018.2226.3001.4450</a></p><h2 id="MySQL的客户端工具"><a href="#MySQL的客户端工具" class="headerlink" title="MySQL的客户端工具"></a>MySQL的客户端工具</h2><p><a href="https://blog.csdn.net/miner_k/article/details/80768181">https://blog.csdn.net/miner_k&#x2F;article&#x2F;details&#x2F;80768181</a>  </p><p>mysql命令中的protocol选项（客户端程序如何连接服务端）：</p><pre><code>tcp：TCP/IP连接本地和远程服务，支持所有操作系统socket：Unix socket文件连接本地服务，仅Unix操作系统支持  pipe：Named-pipe方式连接本地服务，仅Windows操作系统支持memory：Shared-memory方式连接本地服务，仅Windows操作系统支持</code></pre><h2 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h2><p>mysql中的数据类型如下：详情可以参照如下博客</p><p><img src="https://img-blog.csdnimg.cn/35181d3e526046938b0febfce0346ea0.png#pic_center" alt="image"></p><p><a href="https://blog.csdn.net/qq_44111805/article/details/124643227">https://blog.csdn.net/qq_44111805&#x2F;article&#x2F;details&#x2F;124643227</a></p><h2 id="MySQL管理表"><a href="#MySQL管理表" class="headerlink" title="MySQL管理表"></a>MySQL管理表</h2><p><a href="https://blog.csdn.net/qq_41684621/article/details/123227106">https://blog.csdn.net/qq_41684621&#x2F;article&#x2F;details&#x2F;123227106</a></p><p>通过select查询语句创建表时，创建的表可能和被查询表的格式定义不太一样。可以使用如下方式：</p><pre><code>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name    &#123; LIKE old_tbl_name | (LIKE old_tbl_name) &#125; </code></pre><p>创建索引时，字段名(长度)  中”(长度)”表示只索引最左边的几个字符</p><pre><code>create  index 索引名  on 表名 (字段名(长度)     aes|desc)</code></pre><p>获取最后插入的ID值：</p><pre><code>mysql&gt; SELECT LAST_INSERT_ID();</code></pre><h2 id="MySQL查询"><a href="#MySQL查询" class="headerlink" title="MySQL查询"></a>MySQL查询</h2><p><a href="https://www.cnblogs.com/eaoo/p/9757176.html">https://www.cnblogs.com/eaoo/p/9757176.html</a></p><h2 id="MySQL视图"><a href="#MySQL视图" class="headerlink" title="MySQL视图"></a>MySQL视图</h2><p><a href="https://blog.csdn.net/qq_54169998/article/details/122714342">https://blog.csdn.net/qq_54169998&#x2F;article&#x2F;details&#x2F;122714342</a></p><h2 id="MySQL事务和隔离级别"><a href="#MySQL事务和隔离级别" class="headerlink" title="MySQL事务和隔离级别"></a>MySQL事务和隔离级别</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>事务：由一个有限的数据库操作序列构成，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单元。</p><blockquote><p>假如A转账给B 100 元，先从A的账户里扣除 100 元，再在 B 的账户上加上 100 元。如果扣完A的100元后，还没来得及给B加上，银行系统异常了，最后导致A的余额减少了，B的余额却没有增加。所以就需要事务，将A的钱回滚回去。</p></blockquote><p>事务的四大特性：</p><ul><li>原子性：指事务中的操作要么全部执行，要么全部不执行。</li><li>隔离性：多个事务并发访问时，事务之间互不影响。</li><li>持久性：指一个事务一旦提交，它对数据库中的数据改变就是永久性的，接下来即便数据库崩溃也不应该对其有影响。</li><li>一致性：一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关。</li></ul><blockquote><p>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。</p></blockquote><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p>我们接下来看一下多个事务并发执行时可能存在的问题</p><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>建表：</p><pre><code>CREATE TABLE student (    studentno INT,    name VARCHAR(20),    class varchar(20),    PRIMARY KEY (studentno)) Engine=InnoDB CHARSET=utf8;</code></pre><p>插入语句：</p><pre><code>INSERT INTO student VALUES(1, &#39;小谷&#39;, &#39;1班&#39;);</code></pre><p>示例数据：</p><pre><code>mysql&gt; select * from student;+-----------+--------+-------+| studentno | name | class |+-----------+--------+-------+| 1         | 小谷  | 1班   |+-----------+--------+-------+1 row in set (0.00 sec)</code></pre><h4 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h4><p>启动A、B两个事务开始操作数据。如果事务A修改了另一个未提交的事务B修改过的数据，则意味着发生了脏写。</p><table><thead><tr><th>1</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>Begin</td><td></td></tr><tr><td>2</td><td></td><td>Begin</td></tr><tr><td>3</td><td></td><td>update student set name&#x3D;’张三’ where studentno&#x3D;1</td></tr><tr><td>4</td><td>update student set name&#x3D;’李四’ where studentno&#x3D;1</td><td></td></tr><tr><td>5</td><td>commit</td><td></td></tr><tr><td>5</td><td></td><td>rollback</td></tr></tbody></table><p>首先事务B将name修改为张三，之后事务A又将数据修改为了李四并提交。如果事务B之后进行了回滚操作，则name值将变为初始值小谷。这时事务A明明修改数据并进行了提交，但是数据却没有什么变化。试想一下，如果是两个人同时给一个账号转钱的情况下，脏写将可能出现什么后果？在现实中，由于数据库中的锁机制，我们会发现当事务A更新事务B未提交的数据时将会处于等待状态直到事务B提交或者回退之后。</p><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>启动A、B两个事务开始操作数据。如果事务A读取到了另一个未提交事务B修改过的值。</p><table><thead><tr><th>1</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>Begin</td><td></td></tr><tr><td>2</td><td></td><td>Begin</td></tr><tr><td>3</td><td></td><td>update student set name&#x3D;’张三’ where studentno&#x3D;1</td></tr><tr><td>4</td><td>select * from student  where studentno&#x3D;1(读取到的结果为张三)</td><td></td></tr><tr><td>5</td><td>commit</td><td></td></tr><tr><td>5</td><td></td><td>rollback</td></tr></tbody></table><p>事务B先将name修改为了张三，之后事务A获取该name并进行后续操作以及提交。如果事务B在之后的阶段执行了回滚操作，则事务A相当于读取了一个不存在的数据进行操作。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>启动A、B两个事务开始操作数据。如果事务A读取一条记录，之后事务B更新了该条记录。然后事务A读取同一条记录，却返回了不同的数据。</p><table><thead><tr><th>1</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>Begin</td><td></td></tr><tr><td>2</td><td></td><td>Begin</td></tr><tr><td>3</td><td>select * from student  where studentno&#x3D;1(读取到的结果为小谷)</td><td></td></tr><tr><td>4</td><td></td><td>update student set name&#x3D;’张三’ where studentno&#x3D;1</td></tr><tr><td>5</td><td></td><td>commit</td></tr><tr><td>6</td><td>select * from student  where studentno&#x3D;1(读取到的结果为张三)</td><td></td></tr><tr><td>7</td><td>commit</td><td></td></tr></tbody></table><p>不可重复读和脏读区别在于脏读可以读取到未提交事务所修改的数据，而不可重复读取到的为已提交事务的数据。</p><p><a href="https://juejin.cn/post/7062589784190877709#heading-6">https://juejin.cn/post/7062589784190877709#heading-6</a><br><a href="https://juejin.cn/post/6844904115353436174">https://juejin.cn/post/6844904115353436174</a></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>启动A、B两个事务开始操作数据。如果事务A查询了一个范围内的数据集。之后，事务B在上述查询范围内增加了一些新的记录。然后事务A再次执行上述同一个查询，发现结果记录比上次多出了我们新插入的条目。</p><table><thead><tr><th>1</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>Begin</td><td></td></tr><tr><td>2</td><td></td><td>Begin</td></tr><tr><td>3</td><td>select * from student  where studentno&gt;0(读取到的记录只有小谷一条)</td><td></td></tr><tr><td>4</td><td></td><td>insert into student vaules(2,张三，2班)</td></tr><tr><td>5</td><td></td><td>commit</td></tr><tr><td>6</td><td>select * from student  where studentno&gt;1(读取到的记录有小谷和张三两条)</td><td></td></tr><tr><td>7</td><td>commit</td><td></td></tr></tbody></table><blockquote><p>那如果Session B中删除了-些符合studentno &gt; 0 的记录而不是插入新记录，那Session A之后再根据studentno &gt; 0的条件读取的记录变少了，这种现象算不算幻读呢?这种现象不属于幻读，幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢?这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。</p></blockquote><p>上述问题按照严重性可以按照如下进行排序：</p><p>脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p><p><a href="https://juejin.cn/post/7062589784190877709#heading-6">https://juejin.cn/post/7062589784190877709#heading-6</a><br><a href="https://juejin.cn/post/6844904115353436174">https://juejin.cn/post/6844904115353436174</a></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>事务具有隔离性。即数据库中一个事务执行期间，其它事务应该处于等待状态。当该事务执行完毕，其它事务才能够继续执行。这样的话对数据库的性能影响太大，因此我们设立了4个隔离级别在隔离性和性能之间进行了折中。以下隔离性越来越强，性能越来越低。</p><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17148fd0f161aea8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>READ UNCOMMITTED ：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。</p><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/5/17148c908b12084b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>READ COMMITTED ：读已提交，它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。可以避免脏读，但不可重复读、幻读问题仍然存在。</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/4/17144b324064255a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>REPEATABLE READ ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在。这是MySQL的默认隔离级别。</p><h4 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/4/1714282f3cb7f7fa~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>SERIALIZABLE ：可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避免脏读、不可重复读和幻读。</p><h3 id="如何使用事务"><a href="#如何使用事务" class="headerlink" title="如何使用事务"></a>如何使用事务</h3><p>使用事务有两种方式，分别为显示事务和隐式事务。详情见以下博客<br><a href="https://juejin.cn/post/7062589784190877709#heading-9">https://juejin.cn/post/7062589784190877709#heading-9</a></p><p>MySQL启动事务：</p><pre><code>START TANSACTION：启动    SQL    SQL    ...    ...COMMIT： 提交ROLLBACK: 回滚保存点：SAVEPOINT sid回滚至保存点：ROLLBACK TO sid </code></pre><p>查看隔离级别：</p><pre><code># 查看隔离级别，MySQL 5.7.20的版本之前：mysql&gt; SHOW VARIABLES LIKE &#39;tx_isolation&#39;;+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| tx_isolation | REPEATABLE-READ |+---------------+-----------------+1 row in set (0.00 sec)# MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation# 查看隔离级别，MySQL 5.7.20的版本及之后：mysql&gt; SHOW VARIABLES LIKE &#39;transaction_isolation&#39;;+-----------------------+-----------------+| Variable_name | Value |+-----------------------+-----------------# 或者使用select @@tx_isolute</code></pre><p>设置隔离级别：</p><pre><code>SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别;#其中，隔离级别格式：&gt; READ UNCOMMITTED&gt; READ COMMITTED&gt; REPEATABLE READ&gt; SERIALIZABLE</code></pre><p>如果没有明确启动事务：</p><pre><code>autocommit：能实现自动提交，每一个操作都直接提交；建议：明确使用事务，并且关闭自动提交；</code></pre><h3 id="隔离级别原理"><a href="#隔离级别原理" class="headerlink" title="隔离级别原理"></a>隔离级别原理</h3><p>MySQL使用不同的锁策略和MVCC来实现不同的隔离级别。其中，读未提交和串行化跟锁有关。读已提交和可重复读和MVCC有关。</p><h4 id="读未提交-1"><a href="#读未提交-1" class="headerlink" title="读未提交"></a>读未提交</h4><p>读未提交采取的是读不加锁原理。</p><ul><li>事务读不加锁，不阻塞其它事务的读和写</li><li>事务写阻塞其它事务写，但不阻塞其它事务读</li></ul><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><ul><li>所有select语句会隐式化转化为select … fro share,即加共享锁</li><li>读加共享锁，写加排他锁，读写互斥。如果有未提交的事务正在修改某些行，所有select这些行的语句都会阻塞。</li></ul><blockquote><p>读已提交和可重复读实现依赖于MVCC</p></blockquote><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><blockquote><p>MVCC:即多版本并发控制。它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。它的实现依赖于隐式字段、undo日志、快照读&amp;当前读、Read View实现。</p></blockquote><p>事务版本号</p><blockquote><p>事务每次开启前，都会从数据库获得一个自增长的事务ID。可以从事务ID判断事务的执行先后顺序。这就是事务版本号。</p></blockquote><h4 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h4><p>对于InnoDB存储引擎，每一行都有两个隐藏列DB_TRX_ID、DB_ROLL_PTR,如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列DB_ROW_ID。</p><ul><li>DB_ROW_ID: 记录每一行最近一次修改它的事务ID，大小为6字节。</li><li>DB_ROLL_PTR：这个隐藏列就相当于一个指针，指向回滚段的undo日志，大小为7字节。</li><li>DB_ROW_ID: 单调递增的行ID，大小为6字节</li></ul><h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><p>事务未提交的时候，修改数据的镜像（修改前的旧版本），存到undo日志里。以便事务回滚时，恢复旧版本数据，撤销未提交事务数据对数据库的影响。</p><p>undo日志是逻辑日志。可以这样认为，当delete一条记录时，undo log中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。</p><p>存储undo日志的地方，就是回滚段。</p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>多个事务并行操作某一行数据时，不同事务对改行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer),连成一条链表，这个链表就被成为版本链。如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4c9c0dac6693070e8503e64fd4affb82?method=download&shareKey=31d06de931ac43c0d1b73bad734a3a23" alt="image"></p><p>上面只是一个例子，在读已提交和可重复读模式下两个事务修改同一条记录，后一条修改会一直处于等待状态。</p><p>我们实操一下：</p><ol><li><p>假设现在有一张core_user表，表里面有一条数据,id为1，名字为孙权：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB32403ecaf472736fae0234219112cade?method=download&shareKey=11706be4261a5473bf9fd78d512fcc63" alt="image"></p></li><li><p>现在开启一个事务A：对core_user表执行update core_user set name &#x3D;”曹操” where id&#x3D;1,会进行如下操作</p></li></ol><ul><li>首先获得一个事务ID&#x3D;101</li><li>把core_user表修改前的数据,拷贝到undo log</li><li>修改core_user表中，id&#x3D;1的数据，名字改为曹操</li><li>把id&#x3D;1记录中的trx_id改成当前事务版本号，并把roll_pointer指向undo log数据地址。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc3fc5fb6004d341af8e02ca394b71457?method=download&shareKey=0ec2cfe56f9339a00b41bac6e460d9ac" alt="image"></p><h4 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h4><p>快照读： 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读,如</p><pre><code>select * from core_user where id &gt; 2;</code></pre><p>当前读：读取的是当前记录的最新版本，显示加锁的都是当前读</p><pre><code>select * from core_user where id &gt; 2 for update;select * from account where id&gt;2 lock in share mode;</code></pre><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><ul><li>Read View是什么呢？ 它就是事务执行SQL语句时，产生的读视图。实际上在innodb中，每个SQL语句执行前都会得到一个Read View。</li><li>Read View有什么用呢？ 它主要是用来做可见性判断的，即判断当前事务对记录中哪个版本的数据可见~</li></ul><p>Read View是如何保证可见性判断的呢？我们先看看Read view 的几个重要属性</p><ul><li>m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。</li><li>min_limit_id:表示在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</li><li>max_limit_id:表示生成ReadView时，系统中应该分配给下一个事务的id值。（这个不是m_ids中最大的，而是下一个事务的id值）</li><li>creator_trx_id: 创建当前read view的事务ID</li></ul><p>Read view 匹配条件规则如下：</p><ul><li><p>如果数据事务ID trx_id &lt; min_limit_id，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</p></li><li><p>如果trx_id&gt;&#x3D; max_limit_id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</p></li><li><p>如果 min_limit_id &#x3D;&lt;trx_id&lt; max_limit_id,需腰分3种情况讨论</p><ul><li><p>如果m_ids包含trx_id,则代表Read View生成时刻，这个事务还未提交，但是如果数据的trx_id等于creator_trx_id的话，表明数据是自己生成的，因此是可见的。</p></li><li><p>如果m_ids包含trx_id，并且trx_id不等于creator_trx_id，则Read   View生成时，事务未提交，并且不是自己生产的，所以当前事务也是看不见的；</p></li><li><p>如果m_ids不包含trx_id，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</p></li></ul></li></ul><blockquote><p>注意啦！！ RR跟RC隔离级别，最大的区别就是：RC每次读取数据前都生成一个ReadView，而RR只在第一次读取数据时生成一个ReadView。</p></blockquote><h4 id="实操：读已提交隔离级别，存在不可重复读的分析"><a href="#实操：读已提交隔离级别，存在不可重复读的分析" class="headerlink" title="实操：读已提交隔离级别，存在不可重复读的分析"></a>实操：读已提交隔离级别，存在不可重复读的分析</h4><ol><li><p>创建core_user表，插入一条初始化数据,如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB4c9c0dac6693070e8503e64fd4affb82?method=download&shareKey=31d06de931ac43c0d1b73bad734a3a23" alt="image"></p></li><li><p>隔离级别设置为读已提交（RC），事务A和事务B同时对core_user表进行查询和修改操作。</p></li></ol><table><thead><tr><th>1</th><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>Begin</td><td></td></tr><tr><td>2</td><td></td><td>Begin</td></tr><tr><td>3</td><td>select * from core_user  where id&#x3D;1</td><td></td></tr><tr><td>4</td><td></td><td>update core_user set name &#x3D; ‘曹操’ where id &#x3D;1</td></tr><tr><td>5</td><td></td><td>commit</td></tr><tr><td>6</td><td>select * from core_user  where id&#x3D;1</td><td></td></tr><tr><td>7</td><td>commit</td><td></td></tr></tbody></table><p>最后事务A查询到的结果是，name&#x3D;曹操的记录。过程如下：</p><ol><li>A开启事务，首先得到一个事务ID为101</li><li>B开启事务，得到事务ID为102</li><li>事务A生成一个Read View,Read View 对应的值如下</li></ol><table><thead><tr><th>变量</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>101,102</td></tr><tr><td>max_limit_id</td><td>103</td></tr><tr><td>min_limit_id</td><td>101</td></tr><tr><td>creator_trx_id</td><td>101</td></tr></tbody></table><p>然后回到版本链：开始从版本链中挑选可见的记录</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4c9c0dac6693070e8503e64fd4affb82?method=download&shareKey=31d06de931ac43c0d1b73bad734a3a23" alt="image"></p><p>由图可以看出，最新版本的列name的内容是孙权，该版本的trx_id值为100。开始执行read view可见性规则校验：</p><pre><code>100 &lt; min_limit_id(101)</code></pre><p>根据上述的第一个条件，这个值对当前事务是可见的。所以查到的name为孙权。</p><ol start="4"><li>事务B进行修改操作，把名字改为了曹操。把原数据拷贝到undo log,然后对数据进行修改，标记事务ID和上一个数据版本在undo log的地址。</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/WEB50426ceaabec112246be9aa8603b3f1d?method=download&shareKey=3f88296ed3ab1c09b75ddc9d8f6d9537" alt="image"></p><ol start="5"><li><p>提交事务</p></li><li><p>事务A再次执行查询操作，新生成一个Read View，Read View对应的值如下</p><table><thead><tr><th>变量</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>101</td></tr><tr><td>max_limit_id</td><td>103</td></tr><tr><td>min_limit_id</td><td>101</td></tr><tr><td>creator_trx_id</td><td>101</td></tr></tbody></table></li><li><p>从图可得，最新版本的列name的内容是曹操，该版本的trx_id值为102。开始执行Read View可见性规则校验：</p><pre><code> min_limit_id(101)=&lt;trx_id（102）&lt;max_limit_id（103); 但是,trx_id=101，不属于m_ids集合 因此，trx_id=102这个记录，对于当前事务是可见的。所以SQL查询到的是name为曹操。</code></pre></li></ol><h4 id="实操：可重复读隔离级别，存在不可重复读的分析"><a href="#实操：可重复读隔离级别，存在不可重复读的分析" class="headerlink" title="实操：可重复读隔离级别，存在不可重复读的分析"></a>实操：可重复读隔离级别，存在不可重复读的分析</h4><p>RR跟RC隔离级别，最大的区别就是：RC每次读取数据前都生成一个ReadView，而RR只在第一次读取数据时生成一个ReadView。因此上述第6步还是使用第一次生成的ReadView</p><table><thead><tr><th>变量</th><th>值</th></tr></thead><tbody><tr><td>m_ids</td><td>101,102</td></tr><tr><td>max_limit_id</td><td>103</td></tr><tr><td>min_limit_id</td><td>101</td></tr><tr><td>creator_trx_id</td><td>101</td></tr></tbody></table><p><img src="https://note.youdao.com/yws/api/personal/file/WEB50426ceaabec112246be9aa8603b3f1d?method=download&shareKey=3f88296ed3ab1c09b75ddc9d8f6d9537" alt="image"></p><p>这时，最新版本的列name的内容是曹操，该版本的trx_id值为102。开始执行read view可见性规则校验：</p><pre><code>min_limit_id(101)=&lt;trx_id（102）&lt;max_limit_id（103);因为m_ids&#123;101,102&#125;包含trx_id（102），并且creator_trx_id (101) 不等于trx_id（102）</code></pre><p>所以trx_id&#x3D;102这个记录，对于当前事务是不可见的。这时候呢，版本链roll_pointer跳到下一个版本，trx_id&#x3D;100这个记录，再次校验是否可见</p><pre><code>100 &lt; min_limit_id(101)</code></pre><p>根据上述的第一个条件，这个值对当前事务是可见的。所以查到的name为孙权。</p><blockquote><p>以上内容来源于如下博客，我只进行了相应的一些修改：<a href="https://juejin.cn/post/7016165148020703246#heading-15">https://juejin.cn/post/7016165148020703246#heading-15</a></p></blockquote><p>聚簇索引和二级索引介绍：<br><a href="https://blog.csdn.net/Bronze5/article/details/107792063">https://blog.csdn.net/Bronze5/article/details/107792063</a></p><h2 id="MySQL锁相关概念补充"><a href="#MySQL锁相关概念补充" class="headerlink" title="MySQL锁相关概念补充"></a>MySQL锁相关概念补充</h2><p>意向锁是一种表级锁，在对表中记录添加共享&#x2F;排它锁之前会先对表添加相应意向锁。它和表级的共享和排它锁会冲突，不会和行级的共享&#x2F;排它锁冲突。</p><p>意向锁解决的是当需要给表级别加锁时需要确定该表和该表中的记录是否含有相冲突的锁。没有意向锁的话，需要对表逐行进行排查。有了意向锁之后，只需要查找该表是否含有意向锁就可以确定该表中的记录上是否有相应锁存在。</p><p>意向锁之间不互斥，这样的话意向锁并不会影响到多个事务对不同数据行加锁时的并发性。（要不然直接使用普通的表锁就可以了)</p><p>意向锁详细内容可以参照如下文章：</p><p><a href="https://juejin.cn/post/6844903666332368909">https://juejin.cn/post/6844903666332368909</a></p><p>MySQL相关锁机制可以参照如下文章：</p><p><a href="https://juejin.cn/post/7094049650428084232">https://juejin.cn/post/7094049650428084232</a></p><p>示例：</p><p>创建表：</p><pre><code>MariaDB [demo]&gt; create table t1 (id int,name varchar(16), age int ,primary key ( id), index (age));Query OK, 0 rows affected (0.00 sec)MariaDB [demo]&gt; insert into t1 values(1,&#39;a&#39;,18),(3,&#39;c&#39;,20),(6,&#39;b&#39;,18),(9,&#39;a&#39;,17),(10,&#39;d&#39;,22);MariaDB [demo]&gt; select * from t1;+----+------+------+| id | name | age  |+----+------+------+|  1 | a    |   18 ||  3 | c    |   20 ||  6 | b    |   18 ||  9 | a    |   17 || 10 | d    |   22 |</code></pre><p>事务A执行：</p><pre><code>MariaDB [demo]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [demo]&gt; select * from  t1 where id = 6 for update    -&gt; ;+----+------+------+| id | name | age  |+----+------+------+|  6 | b    |   18 |+----+------+------+1 row in set (0.00 sec)</code></pre><p>事务B执行：</p><pre><code>MariaDB [demo]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [demo]&gt; select age,name from t1 where age=18 lock in share mode;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionMariaDB [demo]&gt; select age from t1 where age=18 for update;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transactionMariaDB [demo]&gt; select age from t1 where age=18 lock in share mode;+------+| age  |+------+|   18 ||   18 |+------+2 rows in set (0.00 sec)</code></pre><p>为什么select age,name from t1 where age&#x3D;18 lock in share mode不可以执行，而select age from t1 where age&#x3D;18 lock in share mode可以执行呢？提示：根据前文的加锁原则以及聚簇索引和二级索引进行分析。</p><p>锁表操作：</p><pre><code>LOCK TABLES tb_name &#123;READ|WRITE&#125;;UNLOCK TABLES</code></pre><h2 id="MySQL用户和权限管理"><a href="#MySQL用户和权限管理" class="headerlink" title="MySQL用户和权限管理"></a>MySQL用户和权限管理</h2><p><a href="https://cloud.tencent.com/developer/article/1656008">https://cloud.tencent.com/developer/article/1656008</a></p><p>用户名的主机名格式可以如下：</p><pre><code>主机名：www.magedu.com, mysqlIP: 172.16.10.177网络地址:    172.16.0.0/255.255.0.0通配符：%，_    172.16.%.%    %.magedu.com</code></pre><p>查看用户权限：</p><pre><code>SHOW GRANTS FOR &#39;username@host&#39;;</code></pre><p>MySQL选项</p><pre><code>--skip-grant-tables：跳过权限验证--skip-name-resolve：禁止域名解析[https://blog.csdn.net/yabingshi_tech/article/details/72677377](https://blog.csdn.net/yabingshi_tech/article/details/72677377)</code></pre><h2 id="MySQL日志管理"><a href="#MySQL日志管理" class="headerlink" title="MySQL日志管理"></a>MySQL日志管理</h2><p><a href="https://juejin.cn/post/7157956679932313608">https://juejin.cn/post/7157956679932313608</a><br><a href="https://juejin.cn/post/7105593289591488526">https://juejin.cn/post/7105593289591488526</a> </p><p>其它参数：</p><pre><code>binlog_rows_query_log_events主要针对当binlog_format=row格式 下的设置，如果基于row记录binlog日志，默认是只记录变化的行数据，不记录涉及执行的SQL语句，如果开启此参数，则会一同记录执行的SQL语句默认falseinnodb_flush_log_at_trx_commit：0：Innodb 中的Log Thread 每隔1 秒钟会将log buffer中的数据写入到文件，同时还会通知文件系统进行文件同步的flush操作，保证数据确实已经写入到磁盘上面的物理文件。但是，每次事务的结束（commit 或者是rollback）并不会触发Log Thread将log buffer 中的数据写入文件。1：这也是Innodb 的默认设置。我们每次事务的结束都会触发Log Thread 将log buffer中的数据写入文件并通知文件系统同步文件。2：Log Thread会在我们每次事务结束的时候将数据写入事务日志，但是这里的写入仅仅是调用了文件系统的文件写入操作。而我们的文件系统都是有缓存机制的，所以Log Thread的这个写入并不能保证内容真的已经写入到物理磁盘上面完成持久化的动作。文件系统什么时候会将缓存中的这个数据同步到物理磁盘文件Log Thread 就完全不知道了。各种文件系统对于自己缓存的刷新机制各不一样，大家可以自行参阅相关的手册。该模式下，MySQL会每秒执行一次刷新磁盘操作。当设置为0，该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失；当设置为1，该模式是最安全的，但也是最慢的一种方式。在mysqld服务崩溃或者服务器主机宕机的情况下，日志缓存区只有可能丢失最多一个语句或者一个事务；当设置为2，该模式速度较快，较取值为0情况下更安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失；</code></pre><h2 id="MySQL的备份与还原"><a href="#MySQL的备份与还原" class="headerlink" title="MySQL的备份与还原"></a>MySQL的备份与还原</h2><p><a href="http://www.yunweipai.com/34246.html">http://www.yunweipai.com/34246.html</a></p><p>备份类型：</p><pre><code>热备份、温备份和冷备份    热备份：读、写不受影响；    温备份：仅可以执行读操作；    冷备份：离线备份；读、写操作均中止；物理备份和逻辑备份    物理备份：复制数据文件；    逻辑备份：将数据导出至文本文件中；完全备份、增量备份和差异备份；    完全备份：备份全部数据；    增量备份：仅备份上次完全备份或增量备份以后变化的数据；    差异备份：仅备份上次完全备份以来变化的数据；物理备份：速度快逻辑备份：速度慢、丢失浮点数精度；方便使用文本处理工具直接对其处理、可移植能力强；</code></pre><p>备份内容：</p><pre><code>数据、配置文件、二进制日志、事务日志</code></pre><p>备份工具比较：</p><table>  <tr>    <th>Backup Method</th>    <th>Storage Engines</th>    <th>Impact</th>    <th>Backup Speed</th>    <th>Recovery Speed</th>    <th>Recovery Granularity</th>  </tr>  <tr>    <td>mysqldump</td>    <td>ALL</td>    <td>WARM</td>    <td>MEDIUM</td>    <td>SLOWEST</td>    <td>MOST FIEXIBLE</td>  </tr>  <tr>    <td>mysqldump</td>    <td>INNODB</td>    <td>HOT</td>    <td>MEDIUM</td>    <td>SLOWEST</td>    <td>MOST FIEXIBLE</td>  </tr>  <tr>    <td>SELECT INFO OUTFILE</td>    <td>ALL</td>    <td>WARM</td>    <td>SLOW</td>    <td>SLOW</td>    <td>MOST FIEXIBLE</td>  </tr>  <tr>    <td>ibbackup</td>    <td>ALL</td>    <td>WARM</td>    <td>FAST</td>    <td>FAST</td>    <td>FIEXIBLE</td>   </tr>  <tr>    <td>ibbackup</td>    <td>INNODB</td>    <td>HOT</td>    <td>FAST</td>    <td>FAST</td>    <td>FIEXIBLE</td>   </tr>  <tr>    <td>FileSystem(copy files)</td>    <td>ALL</td>    <td>COLD</td>    <td>FASTEST</td>    <td>FASTEST</td>    <td>NOT FIEXIBLE</td>   </tr>   <tr>    <td>Snapshot(this is with LVM,ZFS)</td>    <td>ALL</td>    <td>ALMOST HOT</td>    <td>FAST</td>    <td>FAST</td>    <td>LEAST FIEXIBLE</td>   </tr>   <tr>    <td>MysqlHotCopy</td>    <td>MyISAM</td>    <td>MOSTLY COLD</td>    <td>FAST</td>    <td>FAST</td>    <td>FIEXIBLE</td>   </tr></table><p>mysqldump: 逻辑备份工具、MyISAM(温)、InnoDB(热备份)</p><pre><code>该工具在备份MyISAM表类型的数据时，需要先在加锁然后执行备份命令。加锁命令可以通过SQL命令或者mysqldump相关参数。    mysql&gt;FLASH TABLES WITH READ LOCK；    --lock-all-tables：锁定所有表    如果指定库中的表类型均为InnoDB，可使用--single-transaction启动热备；该选项不要和lock-all-tables一起使用。其它参数--master-data=&#123;0|1|2&#125;     0: 不记录二进制日志文件及路位置；     1：以CHNAGE MASTER TO的方式记录位置，可用于恢复后直接启动从服务器；     2：以CHANGE MASTER TO的方式记录位置，但默认为被注释；--flush-logs: 执行日志flush；--events：--routines：导出存储过程或存储函数定义--triggers：导出触发器定义在恢复的时候注意关闭二进制日志功能： mysql&gt;SET SQL_LOG_BIN=0;</code></pre><p>二进制相关选项：</p><pre><code>innodb_support_xa=&#123;TRUE|FLASE&#125;存储引擎事务在存储引擎内部被赋予了ACID属性，分布式(XA)事务是一种高层次的事务，它利用“准备”然后“提交”(prepare-then-commit)两段式的方式将ACID属性扩展到存储引擎外部，甚至是数据库外部。然而，“准备”阶段会导致额外的磁盘刷写操作。XA需要事务协调员，它会通知所有的参与者准备提交事务(阶段1)。当协调员从所有参与者那里收到“就绪”信息时，它会指示所有参与者进行真正的“提交”操作。此变量正是用于定义InnoDB是否支持两段式提交的分布式事务，默认为启用。事实上，所有启用了二进制日志的并支持多个线程同时向二进制日志写入数据的MySQL服务器都需要启用分布式事务，否则，多个线程对二进制日志的写入操作可能会以与原始次序不同的方式完成，这将会在基于二进制日志的恢复操作中或者是从服务器上创建出不同原始数据的结果。因此，除了仅有一个线程可以改变数据以外的其它应用场景都不应该禁用此功能。而在仅有一个线程可以修改数据的应用中，禁用此功能是安全的并可以提升InnoDB表的性能。作用范围为全局和会话级别，可用于选项文件，属动态变量。sync_binlog = 1：二进制日志同步磁盘文件SQL_LOG_BIN：是否开启二进制</code></pre><p>mysqlhotcopy：</p><pre><code>物理备份工具、温备份。其使用 LOCK TABLES、FLUSH TABLES 和 CP 来进行快速备份,占用资源和备份速度比 mysqldump 快很多很多。特别适合大的数据库，但需要注意的是：mysqlhotcopy 只支持 MyISAM 引擎</code></pre><p>SELECT INFO OUTFILE</p><pre><code>备份：    SELECT * INTO OUTFILE &#39;/path/to/somefile.txt&#39; FROM tb_name [WHERE clause];还原：    LOAD DATA INFILE &#39;/path/to/somefile.txt&#39; INTO TABLE tb_name;</code></pre><p>注：二进制日志和数据文件建议不要放在同一个磁盘中。一：由于两种文件都会产生磁盘IO从而造成竞争。二：防止磁盘损坏造成数据文件和日志同时损坏导致数据无法恢复。数据和事务日志可以放到同一个磁盘上。</p><h2 id="xtrabackup备份原理"><a href="#xtrabackup备份原理" class="headerlink" title="xtrabackup备份原理"></a>xtrabackup备份原理</h2><p><a href="https://opensource.actionsky.com/20190505-xtrabackup/">https://opensource.actionsky.com/20190505-xtrabackup/</a><br><a href="https://opensource.actionsky.com/20190509-mysql-xtrabackup/">https://opensource.actionsky.com/20190509-mysql-xtrabackup/</a><br><a href="https://www.actionsky.com/2522.html">https://www.actionsky.com/2522.html</a></p><h2 id="MySQL相关配置参数"><a href="#MySQL相关配置参数" class="headerlink" title="MySQL相关配置参数"></a>MySQL相关配置参数</h2><p>expire_logs_days&#x3D;{0..99}  </p><pre><code>设定二进制日志的过期天数，超出此天数的二进制日志文件将被自动删除。默认为0，表示不启用过期自动删除功能。如果启用此功能，自动删除工作通常发生在MySQL启动时或FLUSH日志时。作用范围为全局，可用于配置文件，属动态变量。</code></pre><p>general_log&#x3D;{ON|OFF}  </p><pre><code>设定是否启用查询日志，默认值为取决于在启动mysqld时是否使用了--general_log选项。如若启用此项，其输出位置则由--log_output选项进行定义，如果log_output的值设定为NONE，即使用启用查询日志，其也不会记录任何日志信息。作用范围为全局，可用于配置文件，属动态变量。</code></pre><p>general_log_file&#x3D;FILE_NAME  </p><pre><code>查询日志的日志文件名称，默认为“hostname.log&quot;。作用范围为全局，可用于配置文件，属动态变量。</code></pre><p>binlog-format&#x3D;{ROW|STATEMENT|MIXED}  </p><pre><code>指定二进制日志的类型，默认为STATEMENT。如果设定了二进制日志的格式，却没有启用二进制日志，则MySQL启动时会产生警告日志信息并记录于错误日志中。作用范围为全局或会话，可用于配置文件，且属于动态变量。</code></pre><p>log&#x3D;{YES|NO}  </p><pre><code>是否启用记录所有语句的日志信息于一般查询日志(general query log)中，默认通常为OFF。MySQL 5.6已经弃用此选项。</code></pre><p>log-bin&#x3D;{YES|NO}  </p><pre><code>是否启用二进制日志，如果为mysqld设定了--log-bin选项，则其值为ON，否则则为OFF。其仅用于显示是否启用了二进制日志，并不反应log-bin的设定值。作用范围为全局级别，属非动态变量。</code></pre><p>log_bin_trust_function_creators&#x3D;{TRUE|FALSE}  </p><pre><code>此参数仅在启用二进制日志时有效，用于控制创建存储函数时如果会导致不安全的事件记录二进制日志条件下是否禁止创建存储函数。默认值为0，表示除非用户除了CREATE ROUTING或ALTER ROUTINE权限外还有SUPER权限，否则将禁止创建或修改存储函数，同时，还要求在创建函数时必需为之使用DETERMINISTIC属性，再不然就是附带READS SQL DATA或NO SQL属性。设置其值为1时则不启用这些限制。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>log_error&#x3D;&#x2F;PATH&#x2F;TO&#x2F;ERROR_LOG_FILENAME  </p><pre><code>定义错误日志文件。作用范围为全局或会话级别，可用于配置文件，属非动态变量。</code></pre><p>log_output&#x3D;{TABLE|FILE|NONE}  </p><pre><code>定义一般查询日志和慢查询日志的保存方式，可以是TABLE、FILE、NONE，也可以是TABLE及FILE的组合(用逗号隔开)，默认为TABLE。如果组合中出现了NONE，那么其它设定都将失效，同时，无论是否启用日志功能，也不会记录任何相关的日志信息。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>log_query_not_using_indexes&#x3D;{ON|OFF}  </p><pre><code>设定是否将没有使用索引的查询操作记录到慢查询日志。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>log_slave_updates  </p><pre><code>用于设定复制场景中的从服务器是否将从主服务器收到的更新操作记录进本机的二进制日志中。本参数设定的生效需要在从服务器上启用二进制日志功能。</code></pre><p>log_slow_queries&#x3D;{YES|NO}  </p><pre><code>是否记录慢查询日志。慢查询是指查询的执行时间超出long_query_time参数所设定时长的事件。MySQL 5.6将此参数修改为了slow_query_log。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>log_warnings&#x3D;#  </p><pre><code>设定是否将警告信息记录进错误日志。默认设定为1，表示启用；可以将其设置为0以禁用；而其值为大于1的数值时表示将新发起连接时产生的“失败的连接”和“拒绝访问”类的错误信息也记录进错误日志。</code></pre><p>long_query_time&#x3D;#  </p><pre><code>设定区别慢查询与一般查询的语句执行时间长度。这里的语句执行时长为实际的执行时间，而非在CPU上的执行时长，因此，负载较重的服务器上更容易产生慢查询。其最小值为0，默认值为10，单位是秒钟。它也支持毫秒级的解析度。作用范围为全局或会话级别，可用于配置文件，属动态变量。</code></pre><p>max_binlog_cache_size{4096 .. 18446744073709547520}  </p><pre><code>二进定日志缓存空间大小，5.5.9及以后的版本仅应用于事务缓存，其上限由max_binlog_stmt_cache_size决定。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>max_binlog_size&#x3D;{4096 .. 1073741824}  </p><pre><code>设定二进制日志文件上限，单位为字节，最小值为4K，最大值为1G，默认为1G。某事务所产生的日志信息只能写入一个二进制日志文件，因此，实际上的二进制日志文件可能大于这个指定的上限。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>max_relay_log_size&#x3D;{4096..1073741824}  </p><pre><code>设定从服务器上中继日志的体积上限，到达此限度时其会自动进行中继日志滚动。此参数值为0时，mysqld将使用max_binlog_size参数同时为二进制日志和中继日志设定日志文件体积上限。作用范围为全局级别，可用于配置文件，属动态变量。</code></pre><p>innodb_log_buffer_size&#x3D;{262144 .. 4294967295}  </p><pre><code>设定InnoDB用于辅助完成日志文件写操作的日志缓冲区大小，单位是字节，默认为8MB。较大的事务可以借助于更大的日志缓冲区来避免在事务完成之前将日志缓冲区的数据写入日志文件，以减少I/O操作进而提升系统性能。因此，在有着较大事务的应用场景中，建议为此变量设定一个更大的值。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>innodb_log_file_size&#x3D;{108576 .. 4294967295}  </p><pre><code>设定日志组中每个日志文件的大小，单位是字节，默认值是5MB。较为明智的取值范围是从1MB到缓存池体积的1/n，其中n表示日志组中日志文件的个数。日志文件越大，在缓存池中需要执行的检查点刷写操作就越少，这意味着所需的I/O操作也就越少，然而这也会导致较慢的故障恢复速度。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>innodb_log_files_in_group&#x3D;{2 .. 100}  </p><pre><code>设定日志组中日志文件的个数。InnoDB以循环的方式使用这些日志文件。默认值为2。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>innodb_log_group_home_dir&#x3D;&#x2F;PATH&#x2F;TO&#x2F;DIR</p><pre><code>设定InnoDB重做日志文件的存储目录。在缺省使用InnoDB日志相关的所有变量时，其默认会在数据目录中创建两个大小为5MB的名为ib_logfile0和ib_logfile1的日志文件。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>relay_log&#x3D;file_name</p><pre><code>设定中继日志的文件名称，默认为host_name-relay-bin。也可以使用绝对路径，以指定非数据目录来存储中继日志。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>relay_log_index&#x3D;file_name</p><pre><code>设定中继日志的索引文件名，默认为为数据目录中的host_name-relay-bin.index。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>relay-log-info-file&#x3D;file_name</p><pre><code>设定中继服务用于记录中继信息的文件，默认为数据目录中的relay-log.info。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>relay_log_purge&#x3D;{ON|OFF}</p><pre><code>设定对不再需要的中继日志是否自动进行清理。默认值为ON。作用范围为全局级别，可用于选项文件，属动态变量。</code></pre><p>relay_log_space_limit&#x3D;#</p><pre><code>设定用于存储所有中继日志文件的可用空间大小。默认为0，表示不限定。最大值取决于系统平台位数。作用范围为全局级别，可用于选项文件，属非动态变量。</code></pre><p>slow_query_log&#x3D;{ON|OFF}</p><pre><code>设定是否启用慢查询日志。0或OFF表示禁用，1或ON表示启用。日志信息的输出位置取决于log_output变量的定义，如果其值为NONE，则即便slow_query_log为ON，也不会记录任何慢查询信息。作用范围为全局级别，可用于选项文件，属动态变量。</code></pre><p>slow_query_log_file&#x3D;&#x2F;PATH&#x2F;TO&#x2F;SOMEFILE</p><pre><code>设定慢查询日志文件的名称。默认为hostname-slow.log，但可以通过--slow_query_log_file选项修改。作用范围为全局级别，可用于选项文件，属动态变量。</code></pre><p>sql_log_bin&#x3D;{ON|OFF}</p><pre><code>用于控制二进制日志信息是否记录进日志文件。默认为ON，表示启用记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。作用范围为全局和会话级别，属动态变量。</code></pre><p>sql_log_off&#x3D;{ON|OFF}</p><pre><code>用于控制是否禁止将一般查询日志类信息记录进查询日志文件。默认为OFF，表示不禁止记录功能。用户可以在会话级别修改此变量的值，但其必须具有SUPER权限。作用范围为全局和会话级别，属动态变量。</code></pre><p>sync_binlog&#x3D;#</p><pre><code>设定多久同步一次二进制日志至磁盘文件中，0表示不同步，任何正数值都表示对二进制每多少次写操作之后同步一次。当autocommit的值为1时，每条语句的执行都会引起二进制日志同步，否则，每个事务的提交会引起二进制日志同步。</code></pre><h2 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h2><p><a href="https://www.cnblogs.com/loveaviva/p/4142254.html">https://www.cnblogs.com/loveaviva/p/4142254.html</a></p><p><a href="http://www.yunweipai.com/34252.html">http://www.yunweipai.com/34252.html</a></p><p><a href="https://juejin.cn/post/7070290856967667742">https://juejin.cn/post/7070290856967667742</a>  </p><p><a href="https://blog.51cto.com/zhangfengzhe/1563032">https://blog.51cto.com/zhangfengzhe/1563032</a></p><p>mysql 过滤复制：</p><pre><code>方式一：master:binlog-do-db=mydbbinlog-ignore-db=mysql方式二：slave:replicate_do_dbrpplicate_ignore_dbreplicate_do_tablereplicate_ignore_tablereplicate_wild_do_tablereplicate_wild_ignore_table注：建议使用方式二。方式一会导致主库二进制日志文件不完整，无法进行完整的库恢复。</code></pre><h2 id="MySQL基于GTID及多线程的复制"><a href="#MySQL基于GTID及多线程的复制" class="headerlink" title="MySQL基于GTID及多线程的复制"></a>MySQL基于GTID及多线程的复制</h2><p><a href="https://blog.51cto.com/freeloda/1282879">https://blog.51cto.com/freeloda/1282879</a></p><h2 id="MySQL-Proxy实现MySQL读写分离"><a href="#MySQL-Proxy实现MySQL读写分离" class="headerlink" title="MySQL-Proxy实现MySQL读写分离"></a>MySQL-Proxy实现MySQL读写分离</h2><p><a href="https://blog.51cto.com/freeloda/1283213">https://blog.51cto.com/freeloda/1283213</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系型数据库基础理论&quot;&gt;&lt;a href=&quot;#关系型数据库基础理论&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库基础理论&quot;&gt;&lt;/a&gt;关系型数据库基础理论&lt;/h2&gt;&lt;h3 id=&quot;数据库原理&quot;&gt;&lt;a href=&quot;#数据库原理&quot; class=&quot;he</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统启动流程(参考)</title>
    <link href="http://example.com/2022/11/29/Linux-start/"/>
    <id>http://example.com/2022/11/29/Linux-start/</id>
    <published>2022-11-29T07:45:07.822Z</published>
    <updated>2022-11-29T07:45:07.821Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>我们在计算机基础中简单介绍了一下计算机是如何进行启动。下面则是详细的介绍一台Linux操作系统是如何进行相应启动的。本内容目前只是初版，只供参考，后期还需要进行优化。</p></div><h1 id="CentOS-6"><a href="#CentOS-6" class="headerlink" title="CentOS 6"></a>CentOS 6</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><div class="note orange icon-padding flat"><p>POST-->BIOS(Boot Sequence)-->MBR(bootloader,446)-->Kernel-->initrd-->(ROOTFS)/sbin/init(/etc/inittab)</p></div>    <ul><li><p>通电：计算机最重要的设备是CPU和内存，CPU从内存中获取指令或数据进行相关操作。但计算机内存是易失性存储，即断电后内存内容将会清空。故计算机中内嵌了一个ROM（存储了BIOS程序），开机后会将ROM中的内容复制到内存中.</p></li><li><p>BIOS：基本输入输出系统。首先进行硬件检测（POST阶段）、然后按照BIOS中设置的启动设备顺序（通常是硬盘）查找MBR。</p></li><li><p>MBR：主引导记录。查找硬盘上的活动分区，然后加载该分区的内核（Kernel）和虚根（initrd）。硬盘小于2T使用的是MBR，大于2T使用的是其它格式。</p><pre><code>  引导加载程序类型：      LILO: LInux Loader，分区小于8G时使用      GRUB: GRand Unified Bootloader          Stage1: MBR，该阶段位于MBR中的Bootloader区域。目的是跳转到stage1_5或者stage2的第一个扇区上。          Stage1_5: 识别/boot的文件系统类型，使grub可以从文件系统中读取体积更大功能更复杂的stage2文件。该阶段一般安装在MBR后、第一个分区前的那段空闲空间中。也就是MBR gap空间，它的作用是跳转到stage2的第一个扇区。          Stage2: /boot/grub/，该阶段是根据配置文件加载内核和虚根文件系统。      GRUB2：  GRUB配置文件：      grub.conf            default=0  # 设定默认启动的title的编号，从0开始      timeout=5  # 等待用户选择的超时时长，单位是秒      splashimage=(hd0,0)/grub/splash.xpm.gz  # grub的背景图片      hiddenmenu # 隐藏菜单      password redhat      password --md5 $1$HKXJ51$B9Z8A.X//XA.AtzU1.KuG.（在开机的GRUB界面修改配置时的密码）      title Red Hat Enterprise Linux Server (2.6.18-308.el5)  # 内核标题，或操作系统名称，字符串，可自由修改          root (hd0,0)  # 内核文件所在的设备；对grub而言，所有类型硬盘一律hd，格式为(hd#,N)；hd#, #表示第几个磁盘；最后的N表示对应磁盘的分区；          kernel /vmlinuz-2.6.18-308.el5 ro root=/dev/vol0/root rhgb quiet   # 内核文件路径，及传递给内核的参数          initrd /initrd-2.6.18-308.el5.img # ramdisk文件路径          password --md5 $1$HKXJ51$B9Z8A.X//XA.AtzU1.KuG.（登陆该内核的密码）      title Install Red Hat Enterprise Linux 5          root (hd0,0)          kernel /vmlinuz-5 ks=http://172.16.0.1/workstation.cfg ksdevice=eth0 noipv6          initrd /initrd-5          password --md5 $1$FSUEU/$uhUUc8USBK5QAXc.BfW4m.      注：password密码可以使用grub-md5-crypt生成        </code></pre></li><li><p>Kernel：Linux内核。</p><pre><code>  内核设计风格：      单内核：Linux (LWP)，将操作系统所有功能都做入内核。          核心库：ko(kernel object)          共享库：so(share object)                微内核：Windows, Solaris (线程)：内核很小只是一个核心，将文件管理、进程管理      等功能做成内核的子系统。当需要时内核再加载相关子系统。  Linux中的内核是单内核加模块化风格。    当Linux内核加载完成后，它需要读取根目录下的/sbin/init进行初始化。但是操作系统读取  磁盘需要加载相应驱动，要加载驱动也需要读取磁盘。由于不同电脑根分区所在硬盘设备并不  一致。为了避免将所有硬盘驱动都做到内核中，在开始的时候。在内核和根目录之间先建立一  个initrd中间层（虚根）。该文件是在安装操作系统的过程中动态生成的。最后，挂载根文件  系统并再将虚根中的内容复制到根文件系统中。  </code></pre></li><li><p>initrd：虚根（获取内存中的一段空间当作硬盘使用）。和根目录的结构类似。RedHat5中名称: ramdisk–&gt;initrd，RedHat6中名称: ramfs–&gt;initramfs</p></li><li><p>&#x2F;sbin&#x2F;init: 启动init程序进入初始化阶段。用户空间的主导进程，所有在用户空间的进程都由init进行管理。</p><pre><code>  启动的服务不同：      运行级别：0-6          0：halt（关机）          1: single user mode（单用户模式）, 直接以管理员身份切入， s,S,single，忘记管理员密码使用。直接使用管理员用户登录，修改密码。          2：multi user mode, no NFS（多用户模式，没有网络服务）          3: multi user mode, text mode（多用户模型，命令行）          4：reserved（保留）          5: multi user mode, graphic mode（多用户，图形界面）          6: reboot（重启）  查看运行级别：      runlevel:       who -r  查看内核release号：      uname -r  [demo@localhost ~]$ runlevel  N 5  注：N代表前一个运行级别（即从那个运行级别切换而来），如果没有则是N。  [demo@localhost ~]$ who -r           run-level 5  2022-01-22 02:53  [demo@localhost ~]$ uname -r  3.10.0-1062.el7.x86_64</code></pre></li></ul><p>注：目前电脑中一般将BIOS和MBR的组合升级为了UEFI(相当于BIOS)和GPT（GPT为了兼容，开头也存储了一份MBR。这里也用于存储第一阶段的启动代码，并且这个MBR只有一个标识为0xEE的分区）</p><h2 id="grub安装"><a href="#grub安装" class="headerlink" title="grub安装"></a>grub安装</h2><p>安装grub stage1:</p><pre><code># grubgrub&gt; root (hd0,0) // 指定boot所在分区grub&gt; set (hd0) // 在hd0硬盘上安装grub stage1注：grub2的grub命令只有在开机时才能进入</code></pre><p>安装grub stage2：</p><pre><code># grub-install --root-directory=/path/to/boot&#39;s_parent_dir  /PATH/TO/DEVICE</code></pre><p>grub命令：</p><pre><code>grub&gt; find grub&gt; root (hd#,N)grub&gt; kernel /PATH/TO/KERNEL_FILEgrub&gt; initrd /PATH/TO/INITRD_FILEgrub&gt; boot</code></pre><p>具体参照：<a href="https://www.cnblogs.com/walk1314/p/9018919.html">https://www.cnblogs.com/walk1314/p/9018919.html</a></p><h2 id="Kernel初始化的过程"><a href="#Kernel初始化的过程" class="headerlink" title="Kernel初始化的过程"></a>Kernel初始化的过程</h2><ul><li><p>1、设备探测</p></li><li><p>2、驱动初始化（可能会从initrd（initramfs）文件中装载驱动模块）</p></li><li><p>3、以只读挂载根文件系统；</p></li><li><p>4、装载第一个进程init（PID：1）</p><pre><code>  /sbin/init：（/etc/inittab）      sysvinit：串行：先启动一个服务之后，再启动另一个服务。      upstart: ubuntu, d-bus, event-driven（红帽6.0：采用基于事件的方式，并行）      systemd:（并行,红帽7.0）</code></pre></li></ul><h2 id="sysvinit"><a href="#sysvinit" class="headerlink" title="sysvinit"></a>sysvinit</h2><p>&#x2F;etc&#x2F;inittab配置文件：</p><pre><code>/etc/inittab作用:    1、设定默认运行级别；    2、运行系统初始化脚本；    3、运行指定运行级别对应的目录下的脚本；    4、设定Ctrl+Alt+Del组合键的操作；    5、定义UPS电源在电源故障/恢复时执行的操作；    6、启动虚拟终端(2345级别)；    7、启动图形终端(5级别)；/etc/inittab格式：    id:runlevels:action:process        id: 标识符，不重复即可        runlevels: 在哪个级别运行此行；        action: 在什么情况下执行此行；        process: 要运行程序;     action:        initdefault: 设定默认运行级别        sysinit: 系统初始化        wait: 等待级别切换至此级别时执行        respawn: 一旦程序终止，会重新启动                例：        id:3:initdefault:                si::sysinit:/etc/rc.d/rc.sysinit        l0:0：wait：/etc/rc.d/rc 0/etc/rc.d/rc.sysinit完成的任务：    1、激活udev和selinux；    2、根据/etc/sysctl.conf文件，来设定内核参数；    3、设定时钟时钟；    4、装载键盘映射；    5、启用交换分区；    6、设置主机名；    7、根文件系统检测，并以读写方式重新挂载；    8、激活RAID和LVM设备；    9、启用磁盘配额；    10、根据/etc/fstab，检查并挂载其它文件系统；    11、清理过期的锁和PID文件；/etc/rc.d/rc # 完成任务：    for I in /etc/rc#.d/K*; do      $I stop    done            for I in /etc/rc#.d/S*; do      $I start    done        ##: 关闭或启动的优先次序，数据越小越优先被选定        先关闭以K开头的服务，后启动以S开头的服务；</code></pre><p>sysvinit服务脚本制作：</p><p>&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;服务脚本<br>服务脚本支持配置文件：&#x2F;etc&#x2F;sysconfig&#x2F;服务脚本同名的配置文件</p><p>脚本相关规范：  </p><ul><li><p>脚本位置:&#x2F;etc&#x2F;rc.d&#x2F;init.d   </p></li><li><p>脚本接受参数：start|stop|restart|status</p></li><li><p>脚本中的特殊内容：</p><pre><code>  # chkconfig: runlevels SS KK  当chkconfig命令来为此脚本在rc#.d目录创建链接时，runlevels表示默认为runlevels级别创建为S*开头的链接，-表示没有级别默认为所有级别创建S*开头的链接；除此之外的级别默认创建为K*开头的链接；S后面的启动优先级为SS所表示的数字；K后面关闭优先次序为KK所表示的数字；  # description: 用于说明此脚本的简单功能； \, 续行</code></pre></li></ul><p>样例脚本：</p><pre><code>#!/bin/bash## chkconfig: 2345 77 22# description: Test Service# LOCKFILE=/var/lock/subsys/myservicestatus() &#123;  if [ -e $LOCKFILE ]; then    echo &quot;Running...&quot;  else    echo &quot;Stopped.&quot;  fi&#125;usage() &#123;  echo &quot;`basename $0` &#123;start|stop|restart|status&#125;&quot;&#125;case $1 instart)  echo &quot;Starting...&quot;   touch $LOCKFILE ;;stop)  echo &quot;Stopping...&quot;   rm -f $LOCKFILE &amp;&gt; /dev/null  ;;restart)  echo &quot;Restarting...&quot; ;;status)  status ;;*)  usage ;;esac</code></pre><p>相关命令：</p><pre><code>chkconfig --list： 查看所有独立守护服务的启动设定；独立守护进程！    chkconfig --list SERVICE_NAME    chkconfig --add SERVICE_NAMEchkconfig --del SERVICE_NAMEchkconfig [--level RUNLEVELS] SERVICE_NAME &#123;on|off&#125;    如果省略级别指定，默认为2345级别；</code></pre><p>&#x2F;etc&#x2F;rc.d&#x2F;rc.local：系统最后启动的一个服务，准确说，执行的最后一个脚本；   </p><p>守护进程的类型：</p><ul><li><p>独立守护进程:可以自定义在哪些级别上启动和关闭</p></li><li><p>xinetd：超级守护进程，代理人。需要关联至运行级别</p><pre><code>  瞬时守护进程：不需要关联至运行级别，当需要时启动。  超级守护进程使用：      1. 配置yum源            2. 安装xinetd      [root@localhost yum.repos.d]# yum install xinetd      3. 查看xinetd进程      [root@localhost init.d]# chkconfig --list      Note: This output shows SysV services only and does not include native            systemd services. SysV configuration data might be overridden by native            systemd configuration.                  If you want to list systemd services use &#39;systemctl list-unit-files&#39;.            To see services enabled on particular target use            &#39;systemctl list-dependencies [target]&#39;.            netconsole     0:off1:off2:off3:off4:off5:off6:off      network        0:off1:off2:on3:on4:on5:on6:off            xinetd based services:          chargen-dgram: off          chargen-stream:off          daytime-dgram: off          daytime-stream:off          discard-dgram: off          discard-stream:off          echo-dgram:    off          echo-stream:   off          tcpmux-server: off          time-dgram:    off          time-stream:   off            4.重启xinetd服务      [root@localhost init.d]# service xinetd restart      Redirecting to /bin/systemctl restart xinetd.service      5.重启xinetd下的某个服务      [root@localhost init.d]# chkconfig echo-dgram on</code></pre></li></ul><p><a href="https://www.cnblogs.com/diantong/p/10734202.html#:~:text=CentOS6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E5%90%AB%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%89%201%20%281%29.Stage1%E9%98%B6%E6%AE%B5%20%E8%BF%99%E4%B8%80%E9%98%B6%E6%AE%B5%E5%85%B6%E5%AE%9E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B0%B1%E6%98%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%97%B6%E9%A2%84%E5%85%88%E5%86%99%E5%85%A5%E5%88%B0MBR%E7%9A%84Bootloader%E7%A8%8B%E5%BA%8F%E3%80%82%20%E5%AE%83%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%BB%85%E6%98%AF%E8%AF%BB%E5%8F%96%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E7%A1%AC%E7%9B%98%E7%9A%840%E6%9F%B1%E9%9D%A2%EF%BC%8C0%E7%A3%81%E9%81%93%EF%BC%8C2%E6%89%87%E5%8C%BA%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%88%2Fboot%2Fgrub%2Fstage1%EF%BC%89%E5%B9%B6%E6%89%A7%E8%A1%8C%E3%80%82%201%202%20%5Broot%40CentOS6,2018%20%2Fboot%2Fgrub%2Fstage1%20...%202%20%282%29.Stage1.5%E9%98%B6%E6%AE%B5%20%E8%BF%99%E4%B8%80%E9%98%B6%E6%AE%B5%E6%98%AFStage1%E9%98%B6%E6%AE%B5%E5%92%8CStage2%E9%98%B6%E6%AE%B5%E7%9A%84%E6%A1%A5%E6%A2%81%EF%BC%8C%E5%85%B7%E6%9C%89%E8%AF%86%E5%88%AB%E5%88%86%E5%8C%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%8C%E6%AD%A4%E5%90%8Egrub%E7%A8%8B%E5%BA%8F%E4%BE%BF%E6%9C%89%E8%83%BD%E5%8A%9B%E5%8E%BB%E8%AE%BF%E9%97%AE%2Fboot%2Fgrub%2Fstage2%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%AF%BB%E5%8F%96%E5%88%B0%E5%86%85%E5%AD%98%E6%89%A7%E8%A1%8C%E3%80%82%203%20%283%29.Stage2%E9%98%B6%E6%AE%B5">https://www.cnblogs.com/diantong/p/10734202.html#:~:text&#x3D;CentOS6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E5%90%AB%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%89%201%20%281%29.Stage1%E9%98%B6%E6%AE%B5%20%E8%BF%99%E4%B8%80%E9%98%B6%E6%AE%B5%E5%85%B6%E5%AE%9E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B0%B1%E6%98%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%97%B6%E9%A2%84%E5%85%88%E5%86%99%E5%85%A5%E5%88%B0MBR%E7%9A%84Bootloader%E7%A8%8B%E5%BA%8F%E3%80%82%20%E5%AE%83%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%BB%85%E6%98%AF%E8%AF%BB%E5%8F%96%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E7%A1%AC%E7%9B%98%E7%9A%840%E6%9F%B1%E9%9D%A2%EF%BC%8C0%E7%A3%81%E9%81%93%EF%BC%8C2%E6%89%87%E5%8C%BA%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%88%2Fboot%2Fgrub%2Fstage1%EF%BC%89%E5%B9%B6%E6%89%A7%E8%A1%8C%E3%80%82%201%202%20%5Broot%40CentOS6,2018%20%2Fboot%2Fgrub%2Fstage1%20…%202%20%282%29.Stage1.5%E9%98%B6%E6%AE%B5%20%E8%BF%99%E4%B8%80%E9%98%B6%E6%AE%B5%E6%98%AFStage1%E9%98%B6%E6%AE%B5%E5%92%8CStage2%E9%98%B6%E6%AE%B5%E7%9A%84%E6%A1%A5%E6%A2%81%EF%BC%8C%E5%85%B7%E6%9C%89%E8%AF%86%E5%88%AB%E5%88%86%E5%8C%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E5%8A%9B%EF%BC%8C%E6%AD%A4%E5%90%8Egrub%E7%A8%8B%E5%BA%8F%E4%BE%BF%E6%9C%89%E8%83%BD%E5%8A%9B%E5%8E%BB%E8%AE%BF%E9%97%AE%2Fboot%2Fgrub%2Fstage2%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%AF%BB%E5%8F%96%E5%88%B0%E5%86%85%E5%AD%98%E6%89%A7%E8%A1%8C%E3%80%82%203%20%283%29.Stage2%E9%98%B6%E6%AE%B5</a></p><h1 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h1><div class="note orange icon-padding flat"><p>上面讲解的内容是基于bios和mbr，目前的话大部分使用UEFT+GPT的方式加载bootloader。CentOS6使用的引导程序为GRUB1，CentOS7使用的引导程序为GRUB2。CentOS6使用的初始化程序为init，CentOS7使用的初始化程序为systemd。</p></div><h2 id="BIOS和UEFI"><a href="#BIOS和UEFI" class="headerlink" title="BIOS和UEFI"></a>BIOS和UEFI</h2><p>bios是计算机启动固件。bios只认识设备，不认识分区，不认识文件并且运行在16位模式下。UEFI可以认为是bios的升级版，它可以在32位或64位模式下运行。UEFI本质上就是一个运行在PC固件上微型操作系统同时以驱动方式识别设备。不同于BIOS只能识别MBR，UEFI系统默认能识别FAT32。这就意味着只要将引导程序放到FAT32分区里，UEFI系统就能通过分区表的指引找到这个保存着引导程序的FAT32。</p><p><a href="https://blog.csdn.net/Linuxprobe18/article/details/124768818">https://blog.csdn.net/Linuxprobe18/article/details/124768818</a></p><p>vmvare如何打开UEFI？</p><p><a href="https://www.cnblogs.com/5201351/p/12856950.html#:~:text=%E4%BD%BF%E7%94%A8VMware%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%BF%98%E6%98%AF%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E7%9A%84BIOS%E5%9B%BA%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%BD%BF%E7%94%A8%20EFI,%E5%9B%BA%E4%BB%B6%E9%80%89%E9%A1%B9%E5%BC%95%E5%AF%BC%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E6%96%B9%E5%BC%8F%EF%BC%8C%201%E3%80%81%E5%85%88%E5%88%9B%E5%BB%BA%E5%A5%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%9C%A8%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%89%8D%EF%BC%8C">https://www.cnblogs.com/5201351/p/12856950.html#:~:text&#x3D;%E4%BD%BF%E7%94%A8VMware%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E9%BB%98%E8%AE%A4%E8%BF%98%E6%98%AF%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E7%9A%84BIOS%E5%9B%BA%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%BD%BF%E7%94%A8%20EFI,%E5%9B%BA%E4%BB%B6%E9%80%89%E9%A1%B9%E5%BC%95%E5%AF%BC%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E6%96%B9%E5%BC%8F%EF%BC%8C%201%E3%80%81%E5%85%88%E5%88%9B%E5%BB%BA%E5%A5%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%9C%A8%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%89%8D%EF%BC%8C</a></p><p>fdisk查看分区类型为EFI System，然后该目录下的efi文件为引导文件。<br><a href="https://blog.csdn.net/u010875635/article/details/74289971">https://blog.csdn.net/u010875635/article/details/74289971</a></p><h2 id="grub2"><a href="#grub2" class="headerlink" title="grub2"></a>grub2</h2><p>grub2使用img文件，不再使用grub中的stage1、stage1.5和stage2。grub2的组成如下：</p><p>boot.img：这个镜像相当于stage1阶段<br>core.img：这个镜像相当于stage1_5和stage2阶段。core.img的安装位置随MBR磁盘和GPT磁盘而不同，在GPT磁盘中则位于一个独立的分区中。该分区标识为bios。</p><p>在UEFI架构中，boot.img和core.img应该合并成了一个即BOOTX64.EFI。</p><p>GRUB2介绍：<a href="https://www.cnblogs.com/f-ck-need-u/p/7094693.html">https://www.cnblogs.com/f-ck-need-u/p/7094693.html</a></p><p>CentOS中UEFI中引导文件来源：</p><pre><code>[root@192 Packages]# rpm -pql grub2-efi-x64-2.02-0.80.el7.centos.x86_64.rpmwarning: grub2-efi-x64-2.02-0.80.el7.centos.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY/boot/efi/EFI/centos/boot/efi/EFI/centos/fonts/boot/efi/EFI/centos/fonts/unicode.pf2/boot/efi/EFI/centos/grub.cfg/boot/efi/EFI/centos/grubenv/boot/efi/EFI/centos/grubx64.efi/boot/grub2/grubenv/etc/grub2-efi.cfg</code></pre><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>systemd配置文件和init的差别：</p><pre><code>（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。/etc/systemd/system/都是链接的/lib/systemd/system下的文件。（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置</code></pre><p>CentOS7 的启动过程：</p><pre><code>（1）UEFi或BIOS初始化，运行POST开机自检（2）选择启动设备（3）引导装载程序, centos7是grub2（4）加载装载程序的配置文件：/etc/grub.d/ /etc/default/grub /boot/grub2/grub.cfg（5）加载initramfs驱动模块（6）加载内核选项（7）内核初始化，centos7使用systemd代替init（8）执行initrd.target所有单元，包括挂载/etc/fstab（9) 从initramfs根文件系统切换到磁盘根目录(10) systemd执行default.target配置，配置文件/etc/systemd/system/default.target，其实这一个链接到graphical.target的软连接。这阶段层层依赖到 graphical.target–&gt;multi-user.target–&gt;basic.target–&gt;sysinit.target–&gt;/etc/rc.d/rc.local：系统最后启动的一个服务，准确说，应该执行的一个脚本；-fs.target 必须在依赖启动后才能启动(11)local-fs.target 所有的用户服务都不启动，这阶段只处理核心底层的服务。扮演的是 /etc/fstab 和 /etc/inittab 这样的角色。（12）sysinit.target 这阶段启动重要的系统服务，像文件系统挂载，swap，设备，内核补充选项（13）basic.target 这阶段启动普通服务，特别是图形管理服务（14）multi-user.target 这一阶段启动非root用户进程，防火墙相关的服务也是这时启动的。（15）systemd启动multi-user.target下的本机与服务器服务（16）systemd执行multi-user.target下的/etc/rc.d/rc.local（17）Systemd执行multi-user.target下的getty.target及登录服务，如果不启动graphical则到此为止。（18）systemd执行graphical需要的服务</code></pre><p>graphical.target文件内容：</p><pre><code>[Unit]Description=Graphical Interface  //简短描述Documentation=man:systemd.special(7) //文档地址Requires=multi-user.target  //当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败Wants=display-manager.service //当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败Conflicts=rescue.service rescue.target //这里指定的 Unit 不能与当前 Unit 同时运行After=multi-user.target rescue.service rescue.target display-manager.service   //After表示multi-user.target在basic.target rescue.service rescue.target之后启动，如果有他们的话。显然，如果启动了 rescue.service rescue.target则表示进入rescue状态，则必然无法启动multi-user.target，从而就不可能进入multi-user状态了 AllowIsolate=yes 允许使用systemctl isolate命令切换到graphical.target</code></pre><p>注：systemd配置文件中的Install区块中的WantedBy，定义如何安装这个配置文件，即怎样做到开机启动。这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在&#x2F;etc&#x2F;systemd&#x2F;system目录下面的multi-user.target.wants子目录之中。</p><h2 id="grub2-安装"><a href="#grub2-安装" class="headerlink" title="grub2 安装"></a>grub2 安装</h2><p>grub2-install： grub安装（MBR）</p><pre><code>[root@localhost boot]# grub2-install --boot-directory=/media/boot /dev/sdbInstalling for i386-pc platform.Installation finished. No error reported.[root@localhost boot]# lltotal 0drwxr-xr-x. 5 root root 63 Jan 22 06:57 grub2</code></pre><p>grub2-mkconfig 是根据&#x2F;etc&#x2F;default&#x2F;grub文件来创建配置文件的。</p><pre><code>[root@localhost boot]# grub2-mkconfig -o /media/boot/grub2/grub.cfgGenerating grub configuration file ...Found linux image: /boot/vmlinuz-3.10.0-1062.el7.x86_64Found initrd image: /boot/initramfs-3.10.0-1062.el7.x86_64.imgFound linux image: /boot/vmlinuz-0-rescue-39dfed02eb5d45adaaa54cb1f15f4d83Found initrd image: /boot/initramfs-0-rescue-39dfed02eb5d45adaaa54cb1f15f4d83.imgdone</code></pre><p>注：判断分区是mbr或gpt：<br><a href="https://blog.csdn.net/a13568hki/article/details/106014313">https://blog.csdn.net/a13568hki/article/details/106014313</a>  </p><p>systemd教程：<br><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a><br><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a><br><a href="https://blog.csdn.net/me0607040211/article/details/89071222">https://blog.csdn.net/me0607040211/article/details/89071222</a><br><a href="https://blog.csdn.net/Anhui_Chen/article/details/106988113">https://blog.csdn.net/Anhui_Chen&#x2F;article&#x2F;details&#x2F;106988113</a>  </p><h1 id="Linux其它命令"><a href="#Linux其它命令" class="headerlink" title="Linux其它命令"></a>Linux其它命令</h1><p>Linux核心：&#x2F;boot&#x2F;vmlinuz-version</p><pre><code>/boot/vmlinuz-3.10.0-1062.el7.x86_64</code></pre><p>Linux内核模块位置（ko）: &#x2F;lib&#x2F;modules&#x2F;version&#x2F;</p><pre><code>/lib/modules/3.10.0-1062.el7.x86_64</code></pre><p>ldd &#x2F;PATH&#x2F;TO&#x2F;BINARY_FILE：显示二进制文件所依赖的共享库<br>chroot: chroot &#x2F;PATH&#x2F;TO&#x2F;TEMPROOT [COMMAND…]：切换根目录</p><pre><code>chroot /test/virrrot  /bin/bash切换根目录使用过程详解：[root@localhost ~]# mkdir virroot[root@localhost ~]# mkdir ./virroot/bin[root@localhost ~]# cp -p /bin/bash ./virroot/bin/    \\ 直接执行会报错[root@localhost ~]# chroot ./virroot/ /bin/bashchroot: failed to run command ‘/bin/bash’: No such file or directory    \\ 查看bash的依赖[root@localhost ~]# ldd /bin/bashlinux-vdso.so.1 =&gt;  (0x00007fff48190000)   libtinfo.so.5 =&gt; /lib64/libtinfo.so.5 (0x00007f8eb4de8000)libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f8eb4be4000)libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8eb4816000)/lib64/ld-linux-x86-64.so.2 (0x00007f8eb5012000)\\ 拷贝相关依赖文件[root@localhost ~]# cp /lib64/libtinfo.so.5 virroot/lib64/[root@localhost ~]# cp /lib64/libdl.so.2 virroot/lib64/[root@localhost ~]# cp /lib64/libc.so.6 virroot/lib64/[root@localhost ~]# cp /lib64/ld-linux-x86-64.so.2 virroot/lib64/\\ 切换根目录，目前这个bash中只能执行自带的命令[root@localhost ~]# chroot virroot/ /bin/bashbash-4.2# </code></pre><p>用户空间访问、监控内核的方式：</p><pre><code>伪文件系统        /proc/sys: 此目录中的文件很多是可读写的    /sys/： 某些文件可写设定内核参数值的方法：    echo VALUE &gt; /proc/sys/TO/SOMEFILE    sysctl -w kernel.hostname=        能立即生效，但无法永久有效；永久有效：/etc/sysctl.conf    文件内容添加如下：         kernel.hostname=demo1    修改文件完成之后，执行如下命令可立即生效：    sysctl -psysctl -a: 显示所有内核参数及其值</code></pre><p>内核模块管理：</p><p>lsmod: 查看模块</p><pre><code>[root@localhost sys]# lsmod|head -5Module                  Size  Used bybinfmt_misc            17468  1 tcp_lp                 12663  0 nls_utf8               12557  1 isofs                  39844  1 </code></pre><p>modprobe MOD_NAME：装载某模块<br>modprobe -r MOD_NAME: 卸载某模块<br>modinfo MOD_NAME: 查看模块的具体信息  </p><pre><code>[root@localhost sys]# modinfo tcp_lpfilename:       /lib/modules/3.10.0-1062.el7.x86_64/kernel/net/ipv4/tcp_lp.ko.xzdescription:    TCP Low Prioritylicense:        GPLauthor:         Wong Hoi Sing Edison, Hung Hing Lun Mikeretpoline:      Yrhelversion:    7.7srcversion:     8AECB32F50124FF15710FCCdepends:        intree:         Yvermagic:       3.10.0-1062.el7.x86_64 SMP mod_unload modversions signer:         CentOS Linux kernel signing keysig_key:        51:08:4E:41:88:03:02:BE:5C:B0:74:AC:0D:A3:FE:10:23:3B:7F:1Csig_hashalgo:   sha256注：CentOS7 最新版本内核从&quot;kernel.ko&quot;移至&quot;kernel.ko.xz”。</code></pre><p>insmod &#x2F;PATH&#x2F;TO&#x2F;MODULE_FILE: 装载模块<br>rmmod MOD_NAME：卸载模块</p><p>depmod &#x2F;PATH&#x2F;TO&#x2F;MODILES_DIR:生成模块之间的依赖关系</p><p><a href="https://www.cnblogs.com/hanxiaomeng/p/12728104.html">https://www.cnblogs.com/hanxiaomeng/p/12728104.html</a></p><h1 id="Linux内核编译-多内核"><a href="#Linux内核编译-多内核" class="headerlink" title="Linux内核编译(多内核)"></a>Linux内核编译(多内核)</h1><p>我使用的CentOS7的内核版本是3.10.0，虚拟机软件为VMware® Workstation 16 Pro。内核版本相差太大会可能会导致不兼容。先从<a href="https://mirrors.edge.kernel.org/">https://mirrors.edge.kernel.org/</a> 上下载内核，然后上传到Linux系统中。  </p><ol><li><p>准备编译环境</p><pre><code> yum group install &quot;Development Tools&quot;  --setopt=group_package_types=mandatory,default,optional</code></pre></li><li><p>Linux内核源码目录在：&#x2F;usr&#x2F;src&#x2F;kernels。首先，将Linux内核解压到&#x2F;usr&#x2F;src&#x2F;kernels下</p><pre><code> [root@demo1 src]# tar -zxvf /home/demo/Desktop/linux-3.13.10.tar.gz  -C /usr/src/kernels</code></pre></li><li><p>将当前正在使用或编译的内核链接为linux目录</p><pre><code> [root@demo1 kernels]# ln -s linux-3.13.10/ linux</code></pre></li><li><p>编译</p></li></ol><p>内核中的功能除了核心功能之外，在编译时，大多功能都有三种选择：</p><pre><code>1、不使用此功能；2、编译成内核模块；3、编译进内核；</code></pre><p>如何指定编译内核的功能：</p><pre><code>  make gconfig: Gnome桌面环境使用，需要安装图形开发库组：GNOME Software Development  make kconfig: KDE桌面环境使用，需要安装图形开发库  make menuconfig: 文本界面，在内核目录下执行（最常用）</code></pre><p>在&#x2F;usr&#x2F;src&#x2F;linux&#x2F;kernels目录下执行make menuconfig</p><pre><code>     .config - Linux/x86 3.13.10 Kernel Configuration      ┌──────────────────────────────────────── Linux/x86 3.13.10 Kernel Configuration ────────────────────────────────────────┐      │  Arrow keys navigate the menu.  &lt;Enter&gt; selects submenus ---&gt; (or empty submenus ----).  Highlighted letters are       │        │  hotkeys.  Pressing &lt;Y&gt; includes, &lt;N&gt; excludes, &lt;M&gt; modularizes features.  Press &lt;Esc&gt;&lt;Esc&gt; to exit, &lt;?&gt; for Help, &lt;/&gt; │        │  for Search.  Legend: [*] built-in  [ ] excluded  &lt;M&gt; module  &lt; &gt; module capable                                       │        │                                                                                                                        │        │ ┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐ │        │ │                       [*] 64-bit kernel                                                                            │ │        │ │                           General setup  ---&gt;                                                                      │ │        │ │                       -*- Provide system-wide ring of trusted keys                                                 │ │        │ │                       [*] Enable loadable module support  ---&gt;                                                     │ │        │ │                       -*- Enable the block layer  ---&gt;                                                             │ │        │ │                           Processor type and features  ---&gt;                                                        │ │        │ │                           Power management and ACPI options  ---&gt;                                                  │ │        │ │                           Bus options (PCI etc.)  ---&gt;                                                             │ │        │ │                           Executable file formats / Emulations  ---&gt;                                               │ │        │ │                       -*- Networking support  ---&gt;                                                                 │ │        │ │                           Device Drivers  ---&gt;                                                                     │ │        │ │                           Firmware Drivers  ---&gt;                                                                   │ │        │ │                           File systems  ---&gt;                                                                       │ │        │ └───────────────────────↓(+)─────────────────────────────────────────────────────────────────────────────────────────┘ │                     │                                &lt;Select&gt;    &lt; Exit &gt;    &lt; Help &gt;    &lt; Save &gt;    &lt; Load &gt;                                │              注：---&gt;代表有子选项         * 代表编译进内核         M 代表编译成模块          空格键可以进行切换         General setup-&gt;Local version - append to kernel release 代表本地版本号         Processor type and features：代表处理器的类型         File systems：代表文件系统         Networking support：代表网络         两次ESC键返回上一层在编译特性时，会将结果保存到.config文件中。我们可以将CentOS系统/boot/config-3.10.0-1062.el7.x86_64拷贝到/usr/src/linux/.config，然后在它的基础上改。/boot/config-3.10.0-1062.el7.x86_64为红帽在编译当前系统内核时指定的特性文件。</code></pre><p>在&#x2F;usr&#x2F;src&#x2F;linux&#x2F;kernels目录下执行make</p><pre><code>  CC      sound/usb/hiface/snd-usb-hiface.mod.o  LD [M]  sound/usb/hiface/snd-usb-hiface.ko  CC      sound/usb/misc/snd-ua101.mod.o  LD [M]  sound/usb/misc/snd-ua101.ko  CC      sound/usb/snd-usb-audio.mod.o  LD [M]  sound/usb/snd-usb-audio.ko  CC      sound/usb/snd-usbmidi-lib.mod.o  LD [M]  sound/usb/snd-usbmidi-lib.ko  CC      sound/usb/usx2y/snd-usb-us122l.mod.o</code></pre><p>在&#x2F;usr&#x2F;src&#x2F;linux&#x2F;kernels目录下执行make modules_install </p><pre><code>  INSTALL /lib/firmware/kaweth/trigger_code_fix.bin  INSTALL /lib/firmware/ti_3410.fw  INSTALL /lib/firmware/ti_5052.fw  INSTALL /lib/firmware/mts_cdma.fw  INSTALL /lib/firmware/mts_gsm.fw  INSTALL /lib/firmware/mts_edge.fw  INSTALL /lib/firmware/edgeport/boot.fw  INSTALL /lib/firmware/edgeport/boot2.fw  INSTALL /lib/firmware/edgeport/down.fw  INSTALL /lib/firmware/edgeport/down2.fw  INSTALL /lib/firmware/edgeport/down3.bin  INSTALL /lib/firmware/whiteheat_loader.fw  INSTALL /lib/firmware/whiteheat.fw  INSTALL /lib/firmware/keyspan_pda/keyspan_pda.fw  INSTALL /lib/firmware/keyspan_pda/xircom_pgs.fw  DEPMOD  3.10.30</code></pre><p>在&#x2F;usr&#x2F;src&#x2F;linux&#x2F;kernels目录下执行make install </p><pre><code>[root@localhost linux]# make installsh /usr/src/kernels/linux-3.10.30/arch/x86/boot/install.sh 3.10.30 arch/x86/boot/bzImage \    System.map &quot;/boot&quot;</code></pre><p>注：我编译的Linux-4.1.16内核成功，但是编译3.X版本的内核会遇到depmod错误或者编译成功之后打开报此客户端禁用CPU错误。</p><p>遇到问题：<br><a href="https://blog.csdn.net/m0_38015368/article/details/82120887">https://blog.csdn.net/m0_38015368&#x2F;article&#x2F;details&#x2F;82120887</a><br><a href="https://access.redhat.com/solutions/1310043">https://access.redhat.com/solutions/1310043</a>  </p><p>相关步骤：<br><a href="https://www.cnblogs.com/linetwork/p/13153038.html">https://www.cnblogs.com/linetwork/p/13153038.html</a></p><h1 id="Screen命令"><a href="#Screen命令" class="headerlink" title="Screen命令"></a>Screen命令</h1><p>一般情况下我们使用远程连接Linux主机。如果某个操作或进程需要执行很长时间，这时连接中断或关闭远程连接会造成该远程连接下的所有进程都终止。为了避免以上问题我们可以使用screen命令。</p><p>首先，需要安装相关程序</p><pre><code>[root@demo1 mnt]# yum install screen</code></pre><p>直接打开一个新的屏幕 </p><pre><code>[root@demo1 mnt]# screen</code></pre><p>在新窗口中执行操作：</p><pre><code>[root@demo1 mnt]# ls -l /total 26lrwxrwxrwx.   1 root root    7 Oct 31 13:21 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 Jan 26 10:11 bootdrwxr-xr-x.  20 root root 3360 Feb  6 01:48 devdrwxr-xr-x. 141 root root 8192 Feb  6 02:00 etcdrwxr-xr-x.   3 root root   18 Oct 31 13:56 homelrwxrwxrwx.   1 root root    7 Oct 31 13:21 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 Oct 31 13:21 lib64 -&gt; usr/lib64drwxr-xr-x.   3 root root   18 Jan 22 07:26 mediadrwxr-xr-x.   8 demo demo 2048 Sep 11  2019 mntdrwxr-xr-x.   3 root root   16 Oct 31 13:39 optdr-xr-xr-x. 233 root root    0 Feb  6 01:48 procdr-xr-x---.  16 root root 4096 Feb  6 01:51 rootdrwxr-xr-x.  44 root root 1340 Feb  6 02:01 runlrwxrwxrwx.   1 root root    8 Oct 31 13:21 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 Apr 11  2018 srvdr-xr-xr-x.  13 root root    0 Feb  6 01:48 sysdrwxrwxrwt.  16 root root 4096 Feb  6 02:14 tmpdrwxr-xr-x.  13 root root  155 Oct 31 13:21 usrdrwxr-xr-x.  20 root root  282 Oct 31 13:53 var</code></pre><p>拆除屏幕（即返回开启screen前的窗口）</p><pre><code>Ctrl+a, d: 拆除屏幕，显示如下[detached from 3470.pts-0.demo1]</code></pre><p>显示已经建立的屏幕</p><pre><code>[root@demo1 mnt]# screen -lsThere is a screen on:    3470.pts-0.demo1(Detached)1 Socket in /var/run/screen/S-root.</code></pre><p>还原回某屏幕</p><pre><code>[root@demo1 mnt]# screen -r 3470[root@demo1 mnt]# ls -l /total 26lrwxrwxrwx.   1 root root    7 Oct 31 13:21 bin -&gt; usr/bindr-xr-xr-x.   5 root root 4096 Jan 26 10:11 bootdrwxr-xr-x.  20 root root 3360 Feb  6 01:48 devdrwxr-xr-x. 141 root root 8192 Feb  6 02:00 etcdrwxr-xr-x.   3 root root   18 Oct 31 13:56 homelrwxrwxrwx.   1 root root    7 Oct 31 13:21 lib -&gt; usr/liblrwxrwxrwx.   1 root root    9 Oct 31 13:21 lib64 -&gt; usr/lib64drwxr-xr-x.   3 root root   18 Jan 22 07:26 mediadrwxr-xr-x.   8 demo demo 2048 Sep 11  2019 mntdrwxr-xr-x.   3 root root   16 Oct 31 13:39 optdr-xr-xr-x. 233 root root    0 Feb  6 01:48 procdr-xr-x---.  16 root root 4096 Feb  6 01:51 rootdrwxr-xr-x.  44 root root 1340 Feb  6 02:01 runlrwxrwxrwx.   1 root root    8 Oct 31 13:21 sbin -&gt; usr/sbindrwxr-xr-x.   2 root root    6 Apr 11  2018 srvdr-xr-xr-x.  13 root root    0 Feb  6 01:48 sysdrwxrwxrwt.  16 root root 4096 Feb  6 02:14 tmpdrwxr-xr-x.  13 root root  155 Oct 31 13:21 usrdrwxr-xr-x.  20 root root  282 Oct 31 13:53 var</code></pre><p>退出该屏幕（exit）</p><pre><code>[root@demo1 mnt]# exit</code></pre><h1 id="Linux制作启动硬盘（我以CentOS7制作该内容失败了，只供参考）"><a href="#Linux制作启动硬盘（我以CentOS7制作该内容失败了，只供参考）" class="headerlink" title="Linux制作启动硬盘（我以CentOS7制作该内容失败了，只供参考）"></a>Linux制作启动硬盘（我以CentOS7制作该内容失败了，只供参考）</h1><p>操作顺序如下：grub–&gt;kernel–&gt;initrd–&gt;ROOTFS(&#x2F;sbin&#x2F;init, &#x2F;bin&#x2F;bash)</p><p>第一步添加一个新的硬盘<br>第二步使用fdisk命令在新的硬盘中新建两个分区（第一个）  </p><pre><code>Disk /dev/sdb: 2147 MB, 2147483648 bytes, 4194304 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xac7fe85b   Device Boot      Start         End      Blocks   Id  System/dev/sdb1   *        2048      411647      204800   83  Linux/dev/sdb2          411648     1026047      307200   83  Linux注：a选项给分区增加boot标识</code></pre><p>第三步使用mkfs命令为两个分区建立文件系统（文件系统类型随意）</p><pre><code>/dev/sda1: UUID=&quot;63389af9-2128-4b68-b072-0b3d7aaca50d&quot; TYPE=&quot;xfs&quot; /dev/sdb2: UUID=&quot;8e4ec16f-7a85-4c68-957d-4008a24539b0&quot; SEC_TYPE=&quot;ext2&quot; TYPE=&quot;ext3&quot; </code></pre><p>第四步在media下新建两个目录</p><pre><code>[root@demo1 media]# lssysboot  sysroot</code></pre><p>第五步将分区进行相应挂载</p><pre><code>[root@demo1 media]# mount /dev/sdb1 /media/sysboot/[root@demo1 media]# mount /dev/sdb2 /media/sysroot/</code></pre><p>第六步将boot分区下的内核拷贝到新建的boot分区下</p><pre><code>[root@demo1 sysboot]# cp /boot/vmlinuz-3.10.0-1062.el7.x86_64 /media/sysboot/</code></pre><p>第七步新建grub引导文件(CentOS7)</p><pre><code>\\ 生成grub2文件[root@demo1 sysboot]# grub2-install --boot-directory=/media/sysboot /dev/sdbInstalling for i386-pc platform.Installation finished. No error reported.[root@demo1 sysboot]# lltotal 6580drwxr-xr-x. 5 root root      63 Feb  6 02:52 grub2\\ 生成grub.cfg配置文件[root@demo1 sysboot]# grub2-mkconfig -o /media/sysboot/grub2/grub.cfgGenerating grub configuration file ...Found linux image: /boot/vmlinuz-3.10.301.0-elFound initrd image: /boot/initramfs-3.10.301.0-el.imgFound linux image: /boot/vmlinuz-3.10.0-1062.el7.x86_64Found initrd image: /boot/initramfs-3.10.0-1062.el7.x86_64.imgFound linux image: /boot/vmlinuz-0-rescue-39dfed02eb5d45adaaa54cb1f15f4d83Found initrd image: /boot/initramfs-0-rescue-39dfed02eb5d45adaaa54cb1f15f4d83.imgdone[root@demo1 grub2]# lltotal 28drwxr-xr-x. 2 root root   25 Feb  6 02:52 fonts-rw-r--r--. 1 root root 5235 Feb  6 02:56 grub.cfg-rw-r--r--. 1 root root 1024 Feb  6 02:52 grubenvdrwxr-xr-x. 2 root root 8192 Feb  6 02:52 i386-pcdrwxr-xr-x. 2 root root 4096 Feb  6 02:52 locale</code></pre><p>第八步新建的grub.cfg引导文件是以&#x2F;boot目录为参考的，需要进行相应修改</p><pre><code>删除不需要的menuentry部分修改某menuentry部分的文件系统id，查看文件系统id命令blkid。[root@demo1 grub2]# blkid/dev/sdb1: UUID=&quot;5c7cb977-7c65-45e6-9454-f4cfc0af28ba&quot; TYPE=&quot;xfs&quot; /dev/sda1: UUID=&quot;63389af9-2128-4b68-b072-0b3d7aaca50d&quot; TYPE=&quot;xfs&quot; /dev/sda2: UUID=&quot;UN0Ex0-C5Bz-oeCn-RbEP-RR1a-x79t-Ikyjh3&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb2: UUID=&quot;8e4ec16f-7a85-4c68-957d-4008a24539b0&quot; TYPE=&quot;ext3&quot; /dev/sr0: UUID=&quot;2019-09-11-18-50-31-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; /dev/mapper/centos-root: UUID=&quot;827a53b1-31be-4ab8-b5a2-3310ee209a81&quot; TYPE=&quot;xfs&quot; /dev/mapper/centos-swap: UUID=&quot;f03a485d-b51a-4f0a-ad29-1262c359686f&quot; TYPE=&quot;swap&quot; 修改linux16中的根目录root所在分区，并删除rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet。在linux16命令结尾处添加init=/bin/bash修改后的结果如下：menuentry &#39;CentOS Linux (3.10.0-1062.el7.x86_64) 7 (Core)&#39; --class centos --class gnu-linux --class gnu --class os --unrestricted $menuentry_id_option &#39;gnulinux-3.10.0-1062.el7.x86_64-advanced-827a53b1-31be-4ab8-b5a2-3310ee209a81&#39; &#123;        load_video        set gfxpayload=keep        insmod gzio        insmod part_msdos        insmod xfs        set root=&#39;hd0,msdos1&#39;        if [ x$feature_platform_search_hint = xy ]; then          search --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 --hint=&#39;hd0,msdos1&#39;  d6eb1eec-e0c1-4287-893e-83520d5448c7（修改为boot分区的id）        else          search --no-floppy --fs-uuid --set=root d6eb1eec-e0c1-4287-893e-83520d5448c7（修改为boot分区的id）        fi        linux16 /vmlinuz-3.10.0-1062.el7.x86_64 root=/dev/sda2(修改根目录分区) ro crashkernel=auto init=/bin/bash        initrd16 /initramfs-3.10.0-1062.el7.x86_64.img&#125;</code></pre><p>第九步建立虚拟文件系统</p><pre><code>mkinitrd  initrd文件路径  内核版本号[root@demo1 grub2]# mkinitrd /media/sysboot/initramfs-`uname -r`.img `uname -r`[root@demo1 sysboot]# file initramfs-3.10.0-1062.el7.x86_64.img initramfs-3.10.0-1062.el7.x86_64.img: ASCII cpio archive (SVR4 with no CRC)</code></pre><p>第十步修改虚拟文件系统：</p><pre><code>CentOS 5解压虚拟文件：    CentOS 5 的initrd-*是.gz压缩文件。需要先加后缀，再解压。然后使用cpio -id &lt; initrd-2.16.18-308.el5.img提取文件。    或者只使用zcat /boot/initrd-2.16.18-308.el5.img|cpio -id        然后修改虚拟文件系统中的init文件中的mkrootdev后面的根目录（CenOS7在grub.cfg中修改）        最后使用find . |cpio -H newc --quiet-o|gzip -9 /mnt/boot/initrd.gz重新打包虚拟文件系统 CentOS 7解压虚拟文件系统    解压： /usr/lib/dracut/skipcpio ../initramfs-3.10.0-1062.el7.x86_64.img|zcat |cpio -id    打包：find . |cpio -o -H newc | gzip &gt; initramfs_cpio.img    注：由于根目录是ext3，所以将相关模块拷贝到虚拟文件系统中    [root@demo1 fs]# lsmod |grep ext    ext4                  584153  1     mbcache                14958  1 ext4    jbd2                  107478  1 ext4    \\加载相关模块    [root@demo1 fs]# cp -r /usr/lib/modules/3.10.0-1062.el7.x86_64/kernel/fs/ext4/ /media/sysboot/demo/usr/lib/modules/3.10.0-1062.el7.x86_64/kernel/fs    [root@demo1 fs]# cp -r /usr/lib/modules/3.10.0-1062.el7.x86_64/kernel/fs/jbd2/ /media/sysboot/demo/usr/lib/modules/3.10.0-1062.el7.x86_64/kernel/fs    [root@demo1 fs]# cp -r /usr/lib/modules/3.10.0-1062.el7.x86_64/kernel/fs/mbcache.ko.xz /media/sysboot/demo/usr/lib/modules/3.10.0-1062.el7.x86_64/kernel/fs        [root@demo1 demo]# cp /sbin/depmod /media/sysboot/demo/sbin/    [root@demo1 demo]# ldd /sbin/depmod         linux-vdso.so.1 =&gt;  (0x00007ffee1183000)        liblzma.so.5 =&gt; /lib64/liblzma.so.5 (0x00007fe38dee1000)        libz.so.1 =&gt; /lib64/libz.so.1 (0x00007fe38dccb000)        libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007fe38dab5000)        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe38d6e7000)        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007fe38d4cb000)        /lib64/ld-linux-x86-64.so.2 (0x00007fe38e107000)    [root@demo1 demo]# cp /lib64/liblzma.so.5 /lib64/libz.so.1 /lib64/libgcc_s.so.1 /lib64/libc.so.6 /lib64/libpthread.so.0 /lib64/ld-linux-x86-64.so.2 /media/sysboot/demo/lib64    [root@demo1 fs]# cd /media/sysboot/demo/    [root@demo1 demo]# chroot .        \\重建模块依赖    bash-4.2# depmod</code></pre><p>第十一步创建根文件系统：</p><pre><code>   在第二个分区按照当前系统根目录创建跟文件系统目录   然后从当前系统拷贝相关命令到自己创建的跟文件系统中，相关命令：ldd、chroot。 </code></pre><p>第十二步将以上硬盘加入到虚拟机中运行：</p><h1 id="脚本制作"><a href="#脚本制作" class="headerlink" title="脚本制作"></a>脚本制作</h1><p>前提：</p><pre><code>$&#123;parameter#*word&#125;$&#123;parameter##*word&#125;$&#123;parameter%word*&#125;$&#123;parameter%%word*&#125;FILE=/usr/local/src$&#123;FILE#*/&#125;: usr/local/src$&#123;FILE##*/&#125;: src$&#123;FILE%/*&#125;: /usr/local$&#123;FILE%%/*&#125;:</code></pre><p>参见博客：<a href="https://www.cnblogs.com/alongdidi/p/bash_parameter_expansion.html">https://www.cnblogs.com/alongdidi/p/bash_parameter_expansion.html</a></p><p>复制二进制程序及其依赖的库文件的脚本：</p><pre><code>#!/bin/bash#DEST=/mnt/sysrootlibcp() &#123;  LIBPATH=$&#123;1%/*&#125;  [ ! -d $DEST$LIBPATH ] &amp;&amp; mkdir -p $DEST$LIBPATH  [ ! -e $DEST$&#123;1&#125; ] &amp;&amp; cp $1 $DEST$LIBPATH &amp;&amp; echo &quot;copy lib $1 finished.&quot;&#125;bincp() &#123;  CMDPATH=$&#123;1%/*&#125;  [ ! -d $DEST$CMDPATH ] &amp;&amp; mkdir -p $DEST$CMDPATH  [ ! -e $DEST$&#123;1&#125; ] &amp;&amp; cp $1 $DEST$CMDPATH  for LIB in  `ldd $1 | grep -o &quot;/.*lib\(64\)\&#123;0,1\&#125;/[^[:space:]]\&#123;1,\&#125;&quot;`; do    libcp $LIB  done&#125;read -p &quot;Your command: &quot; CMDuntil [ $CMD == &#39;q&#39; ]; do   ! which $CMD &amp;&gt; /dev/null &amp;&amp; echo &quot;Wrong command&quot; &amp;&amp; read -p &quot;Input again:&quot; CMD &amp;&amp; continue  COMMAND=` which $CMD | grep -v &quot;^alias&quot; | grep -o &quot;[^[:space:]]\&#123;1,\&#125;&quot;`  bincp $COMMAND  echo &quot;copy $COMMAND finished.&quot;  read -p &quot;Continue: &quot; CMDdone</code></pre><p>注：mount -n: 挂载时不更新&#x2F;etc&#x2F;mtab文件;</p><p>相关博客：<br><a href="https://blog.csdn.net/weixin_34245169/article/details/91798455">https://blog.csdn.net/weixin_34245169&#x2F;article&#x2F;details&#x2F;91798455</a><br><a href="https://linux.cn/article-8807-1.html">https://linux.cn/article-8807-1.html</a><br><a href="https://www.cnblogs.com/zhangchaocoming/p/14792181.html">https://www.cnblogs.com/zhangchaocoming/p/14792181.html</a><br><a href="https://blog.51cto.com/u_14322729/2412355">https://blog.51cto.com/u_14322729&#x2F;2412355</a></p><h2 id="内核部分编译"><a href="#内核部分编译" class="headerlink" title="内核部分编译"></a>内核部分编译</h2><p>如何实现部分编译：  </p><p>1、只编译某子目录下的相关代码：  </p><pre><code>make dir/make arch/make drivers/net/</code></pre><p>2、只编译部分模块</p><pre><code>make M=drivers/net/</code></pre><p>3、只编译某一模块</p><pre><code>make drivers/net/pcnet32.ko</code></pre><p>4、将编译完成的结果放置于别的目录中</p><pre><code>make O=/tmp/kernel </code></pre><p>5、交叉编译（即在一个CPU平台编译其它CPU平台上的代码）</p><pre><code>make ARCH=</code></pre><h1 id="Linux系统故障排除"><a href="#Linux系统故障排除" class="headerlink" title="Linux系统故障排除"></a>Linux系统故障排除</h1><h2 id="解决问题思路"><a href="#解决问题思路" class="headerlink" title="解决问题思路"></a>解决问题思路</h2><ul><li>确定问题的故障特征</li><li>重现故障</li><li>使用工具手机进一步信息</li><li>排除不可能的原因</li><li>定位故障</li><li>从简单的问题入手</li><li>一次尝试一种方式</li><li>备份原文件</li><li>尽可能借助于工具</li><li></li></ul><h2 id="可能会出现的故障"><a href="#可能会出现的故障" class="headerlink" title="可能会出现的故障"></a>可能会出现的故障</h2><p>1、用户无法登陆系统（migetty，bash程序故障）</p><pre><code>安装系统光盘，进入救援模式下。然后找到安装包执行rpm -ivh --replacepkgs --root /path/to/root bash-3.2-32.el5-i386.rpm</code></pre><p>其它故障：<a href="https://blog.51cto.com/yuanye1128/1403549?source=drt">https://blog.51cto.com/yuanye1128/1403549?source=drt</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;我们在计算机基础中简单介绍了一下计算机是如何进行启动。下面则是详细的介绍一台Linux操作系统是如何进行相应启动的。本内容目前只是初版，只供参考，后期还需要进行优化。&lt;/p&gt;
&lt;/div&gt;
</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux计划任务和日志</title>
    <link href="http://example.com/2022/11/27/Linux-crond/"/>
    <id>http://example.com/2022/11/27/Linux-crond/</id>
    <published>2022-11-28T02:39:38.213Z</published>
    <updated>2022-11-28T02:39:38.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h2><p>1、在未来的某个时间点执行一次某任务；</p><pre><code>atbatchat 时间at&gt; COMMANDat&gt; Ctrl+d指定时间：    绝对时间：HH:MM， DD.MM.YY  MM/DD/YY    相对时间：now+#        单位：minutes, hours, days, weeks    模糊时间：noon, midnight, teatime命令的执行结果：将以邮件的形式发送给安排任务的用户at -l = atq：查看at -d AT_JOB_ID = atrm  AT_JOB_ID：删除某个计划任务</code></pre><p>2、周期性地执行某任务</p><pre><code>cron：自身是一个不间断运行的服务anacron: cron的补充，能够实现让cron因为各种原因在过去的时间该执行而未执行的任务在恢复正常执行一次；cron:     系统cron任务：        /etc/crontab            分钟  小时  天  月  周  用户  任务    用户cron任务:        /var/spool/cron/USERNAME            分钟  小时  天  月  周  任务            时间的有效取值：        分钟：0-59        小时：0-23        天：1-31        月：1-12        周：0-7，0和7都表示周日            时间通配表示：        *: 对应时间的所有有效取值            3 * * * *             3 * * * 7            13 12 6 7 *        ,: 离散时间点：             10,40 02 * * 2,5         -：连续时间点：            10 02 * * 1-5        /#: 对应取值范围内每多久一次            */3 * * * *                每两小时执行一次：        08 */2 * * *    每两天执行一次：        10 04 */2 * *执行结果将以邮件形式发送给管理员：    */3 * * * * /bin/cat /etc/fstab &amp;&gt; /dev/nullcron的环境变量：cron执行所有命令都去PATH环境变量指定的路径下去找    PATH  /bin:/sbin:/usr/bin:/usr/sbin用户任务的管理：    crontab        -l: 列出当前用户的所有cron任务        -e: 编辑         -r: 移除所有任务        -u USERNAME: 管理其用户的cron任务</code></pre><h2 id="Linux上的日志系统"><a href="#Linux上的日志系统" class="headerlink" title="Linux上的日志系统"></a>Linux上的日志系统</h2><blockquote><p>CentOS 6之前只有rsyslogd 的年代中，由于 rsyslogd 必须要开机完成并且执行了 rsyslogd 这个daemon 之后，日志文件才会开始记录。所以，核心还得要自己产生一个 klogd 的服务，才能将系统在开机过程、启动服务过程中的信息记录下来。然后等 rsyslogd 启动后才传送给它来处理。 现在有了systemd 之后，由于这玩意儿是核心唤醒的，然后又是第一支执行的软件，它可以主动调用 systemd-journald 来协助记载登录文件。因此在开机过程中的所有信息，包括启动服务与服务若启动失败的情况等等，都可以直接被记录到systemd-journald 里头去！</p></blockquote><p>syslog服务：  </p><ul><li>syslogd: 系统，非内核产生的信息  </li><li>klogd：内核，专门负责记录内核产生的日志信息</li></ul><blockquote><p>CentOS 7.x 使用systemd 提供的 journalctl 日志管理<br>           rsyslog.service：主要记录系统与网络等服务的讯息<br>           logrotate：主要在进行登录文件的轮替功能。</p><p>系统由systemd 所管理，那所有经由 systemd 启动的服务，如果再启动或结束的过程中发生一些问题或者是正常的讯息, 就会将该讯息由 systemd-journald.service 以二进制的方式记录下来，之后再将这个讯息发送给rsyslog.service 作进一步的记载。 systemd-journald.service 的记录主要都放置于内存中，因此在存取方面性能比较好。我们也能够通过journalctl 以及 systemctl status unit.service 来查看各个不同服务的登录文件！这有个好处，就是日志文件可以随着个别服务让你查阅，在单一服务的处理上面，要比跑到 &#x2F;var&#x2F;log&#x2F;messages 去大海捞针来的简易很多！</p></blockquote><p>kernel –&gt; 物理终端(&#x2F;dev&#x2F;console) –&gt; &#x2F;var&#x2F;log&#x2F;dmesg（系统启动日志）</p><pre><code># dmesg# cat /var/log/dmesg</code></pre><p>日志需要滚动(日志切割)：</p><pre><code>messages messages.1 messages.2 messages.3</code></pre><p>常见日志文件：</p><pre><code>/var/log/boot.log： 开机的时候系统核心会去侦测与启动硬件，接下来开始各种核心支持的功能启动等。这些流程都会记录在 /var/log/boot.log 里面哩！ 不过这个文件只会存在这次开机启动的信息，前次开机的信息并不会被保留下来！/var/log/cron： crontab 调度有没有实际被进行？ 进行过程有没有发生错误？你的 /etc/crontab 是否撰写正确？在这个登录文件内查询看看。/var/log/dmesg： 记录系统在开机的时候核心侦测过程所产生的各项信息。由于 CentOS 默认将开机时核心的硬件侦测过程取消显示， 因此额外将数据记录一份在这个文件中；/var/log/lastlog： 可以记录系统上面所有的帐号最近一次登陆系统时的相关信息。/var/log/maillog 或 /var/log/mail/*： 记录邮件的往来信息，其实主要是记录 postfix （SMTP 协定提供者） 与 dovecot （POP3 协定提供者） 所产生的讯息啦。 SMTP 是发 信所使用的通讯协定， POP3 则是收信使用的通讯协定。 postfix 与 dovecot 则分别是两 套达成通讯协定的软件/var/log/messages： 这个文件相当的重要，几乎系统发生的错误讯息 （或者是重要的信 息） 都会记录在这个文件中； 如果系统发生莫名的错误时，这个文件是一定要查阅的登 录文件之一。/var/log/secure： 基本上，只要牵涉到“需要输入帐号密码”的软件，那么当登陆时 （不管 登陆正确或错误） 都会被记录在此文件中。 包括系统的 login 程序、图形接口登陆所使 用的 gdm 程序、 su, sudo 等程序、还有网络连线的 ssh, telnet 等程序， 登陆信息都会 被记载在这里；/var/log/wtmp, /var/log/faillog： 这两个文件可以记录正确登陆系统者的帐号信息 （wtmp） 与错误登陆时所使用的帐号信息 （faillog） ！/var/log/httpd/, /var/log/samba/： 不同的网络服务会使用它们自己的登录文件来记载它们 自己产生的各项讯息！上述的目录内则是个别服务所制订的登录文件。</code></pre><p>配置文件：&#x2F;etc&#x2F;syslog.conf</p><pre><code>配置文件定义格式为: facility.priority        action  facility,可以理解为日志的来源或设备目前常用的facility有以下几种：     auth      # 认证相关的     authpriv  # 权限,授权相关的     cron      # 任务计划相关的     daemon    # 守护进程相关的     kern      # 内核相关的     lpr       # 打印相关的     mail      # 邮件相关的     mark      # 标记相关的     news      # 新闻相关的     security # 安全相关的,与auth 类似      syslog   # syslog自己的     user     # 用户相关的     uucp     # unix to unix cp 相关的     local0 到 local7 # 用户自定义使用     *        # *表示所有的facility   priority(log level)日志的级别,一般有以下几种级别(从低到高)     debug           # 程序或系统的调试信息     info            # 一般信息    notice          # 不影响正常功能,需要注意的消息     warning/warn    # 可能影响系统功能,需要提醒用户的重要事件     err/error       # 错误信息     crit            # 比较严重的     alert           # 必须马上处理的     emerg/panic     # 会导致系统不可用的     *               # 表示所有的日志级别     none            # 跟* 相反,表示啥也没有       action(动作)日志记录的位置     系统上的绝对路径    # 普通文件 如： /var/log/xxx     |                   # 管道  通过管道送给其他的命令处理     终端              # 终端   如：/dev/console     @HOST               # 远程主机 如： @10.0.0.1          用户              # 系统用户 如： root     *                   # 登录到系统上的所有用户，一般emerg级别的日志是这样定义的 定义格式例子： mail.info   /var/log/mail.log # 表示将mail相关的,级别为info及                               # info以上级别的信息记录到/var/log/mail.log文件中 auth.=info  @10.0.0.1         # 表示将auth相关的,基本为info的信息记录到10.0.0.1主机上去                               # 前提是10.0.0.1要能接收其他主机发来的日志信息 user.!=error                  # 表示记录user相关的,不包括error级别的信息 user.!error                   # 与user.error相反 *.info                        # 表示记录所有的日志信息的info级别 mail.*                        # 表示记录mail相关的所有级别的信息 *.*                           # 你懂的. cron.info;mail.info           # 多个日志来源可以用&quot;;&quot; 隔开 cron,mail.info                # 与cron.info;mail.info 是一个意思 mail.*;mail.!=info            # 表示记录mail相关的所有级别的信息,但是不包括info级别的 </code></pre><blockquote><p>centos 7 配置文件：rsyslog.conf</p></blockquote><p>日志轮替：</p><pre><code>[root@study ~]# vim /etc/logrotate.conf # 下面的设置是 &quot;logrotate 的默认设置值&quot; ，如果个别的文件设置了其他的参数， # 则将以个别的文件设置为主，若该文件没有设置到的参数则以这个文件的内容为默认值！ weekly &amp;lt;==默认每个礼拜对登录文件进行一次 rotate 的工作 rotate 4 &amp;lt;==保留几个登录文件呢？默认是保留四个！ create &amp;lt;==由于登录文件被更名，因此创建一个新的来继续储存之意！ dateext &amp;lt;==就是这个设置值！可以让被轮替的文件名称加上日期作为文件名喔！ #compress &amp;lt;==被更动的登录文件是否需要压缩？如果登录文件太大则可考虑此参数启动 include /etc/logrotate.d # 将 /etc/logrotate.d/ 这个目录中的所有文件都读进来执行 rotate 的工作！ /var/log/wtmp &#123; &amp;lt;==仅针对 /var/log/wtmp 所设置的参数 monthly &amp;lt;==每个月一次，取代每周！     create 0664 root utmp &amp;lt;==指定新建文件的权限与所属帐号/群组     minsize 1M &amp;lt;==文件大小一定要超过 1M 后才进行rotate （略过时间参数）     rotate 1 &amp;lt;==仅保留一个，亦即仅有 wtmp.1 保留而已。 &#125;# 这个 wtmp 可记录登陆者与系统重新开机时的时间与来源主机及登陆期间的时间。 # 由于具有 minsize 的参数，因此不见得每个月一定会进行一次喔！要看文件大小。 # 由于仅保留一个登录文件而已，不满意的话可以将他改成 rotate 5 吧！[root@study ~]# logrotate [-vf] logfile 选项与参数： -v ：启动显示模式，会显示 logrotate 运行的过程喔！ -f ：不论是否符合配置文件的数据，强制每个登录文件都进行 rotate 的动作！</code></pre><p>观察日志信息（centos7）</p><pre><code>[root@study ~]# journalctl [-nrpf] [--since TIME] [--until TIME] _optional 选项与参数： 默认会输出全部的 log 内容，从旧的输出到最新的讯息     -n ：秀出最近的几行的意思～找最新的信息相当有用     -r ：反向输出，从最新的输出到最旧的数据     -p ：根据后面所接的讯息重要性排序！    -f ：类似 tail -f 的功能，持续显示 journal 日志的内容（实时监测时相当有帮助！）     --since --until：设置开始与结束的时间，让在该期间的数据输出而已     _SYSTEMD_UNIT=unit.service ：只输出 unit.service 的信息而已     _COMM=bash ：只输出与 bash 有关的信息     _PID=pid ：只输出 PID 号码的信息     _UID=uid ：只输出 UID 为 uid 的信息     SYSLOG_FACILITY=[0-23] ：使用 syslog.h 规范的服务相对序号来调用出正确的数据！         范例一：秀出目前系统中所有的 journal 日志数据     [root@study ~]# journalctl     -- Logs begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 00:01:01 CST.--     Aug 17 18:37:52 study.centos.vbird systemd-journal[105]: Runtime journal is using 8.0M （max 142.4M, leaving 213.6M of free 1.3G, current limit 142.4M）.     Aug 17 18:37:52 study.centos.vbird systemd-journal[105]: Runtime journal is using 8.0M （max 142.4M, leaving 213.6M of free 1.3G, current limit 142.4M）.     Aug 17 18:37:52 study.centos.vbird kernel: Initializing cgroup subsys cpuset     Aug 17 18:37:52 study.centos.vbird kernel: Initializing cgroup subsys cpu     .....（中间省略）.....     Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19268]: finished 0anacron Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19270]: starting 0yum-hourly.cron Aug 19 00:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[19274]: finished 0yum-hourly.cron     # 从这次开机以来的所有数据都会显示出来！通过 less 一页页翻动给管理员查阅！数据量相当大！     范例二：    （1）仅显示出 2015/08/18 整天以及    （2）仅今天及    （3）仅昨天的日志数据内容     [root@study ~]# journalctl --since &quot;2015-08-18 00:00:00&quot; --until &quot;2015-08-19 00:00:00&quot;     [root@study ~]# journalctl --since today     [root@study ~]# journalctl --since yesterday --until today     范例三：只找出 crond.service 的数据，同时只列出最新的 10 笔即可         [root@study ~]# journalctl _SYSTEMD_UNIT=crond.service -n 10     范例四：找出 su, login 执行的登录文件，同时只列出最新的 10 笔即可         [root@study ~]# journalctl _COMM=su _COMM=login -n 10     范例五：找出讯息严重等级为错误 （error） 的讯息！     [root@study ~]# journalctl -p err     范例六：找出跟登录服务 （auth, authpriv） 有关的登录文件讯息     [root@study ~]# journalctl SYSLOG_FACILITY=4 SYSLOG_FACILITY=10 # 更多关于 syslog_facility 的数据</code></pre><p>手动发送日志</p><pre><code>[root@study ~]# logger [-p 服务名称.等级] &quot;讯息&quot; 选项与参数： 服务名称.等级 ：范例一：指定一下，让 dmtsai 使用 logger 来传送数据到登录文件内 [root@study ~]# logger -p user.info &quot;I will check logger command&quot; [root@study ~]# journalctl SYSLOG_FACILITY=1 -n 3 -- Logs begin at Mon 2015-08-17 18:37:52 CST, end at Wed 2015-08-19 18:03:17 CST. --Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29710]: starting 0yum-hourly.cron Aug 19 18:01:01 study.centos.vbird run-parts（/etc/cron.hourly）[29714]: finished 0yum-hourly.cron Aug 19 18:03:17 study.centos.vbird dmtsai[29753]: I will check logger command</code></pre><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 鸟哥Linux私房菜-基础版</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;任务计划&quot;&gt;&lt;a href=&quot;#任务计划&quot; class=&quot;headerlink&quot; title=&quot;任务计划&quot;&gt;&lt;/a&gt;任务计划&lt;/h2&gt;&lt;p&gt;1、在未来的某个时间点执行一次某任务；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;at
batch

at 时间
at&amp;gt; COMM</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="LOG" scheme="http://example.com/tags/LOG/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="http://example.com/2022/11/27/Linux-shell/"/>
    <id>http://example.com/2022/11/27/Linux-shell/</id>
    <published>2022-11-27T14:05:00.135Z</published>
    <updated>2022-11-27T14:05:00.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程语言分类"><a href="#编程语言分类" class="headerlink" title="编程语言分类"></a>编程语言分类</h2><blockquote><p>编程语言可以分为机器语言、汇编语言、高级语言三种，其中高级语言还可以分为静态语言和动态语言。静态语言也称为编译型语言，即事先通过编译器转换成可执行格式，该语言变量一般是强类型。动态语言则称为解释性语言，即执行时通过解释器边解释边执行，该语言变量一般是弱类型。SHELL则是动态语言的一种，同时它也是一门面向过程的语言。</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一段命名的内存空间，我们可以通过变量去操纵变量所对应的内存空间。变量的存储内容可以分为如下几种：</p><ul><li>字符</li><li>数值</li><li>整型</li><li>浮点型: 11.23， 1.123<em>10^1, 0.1123</em>10^2  </li><li>bool型（真、假）</li></ul><p>变量赋值：VAR_NAME&#x3D;VALUE  </p><p>bash变量类型：</p><pre><code>环境变量：作用域为当前shell进程及其子进程；    定义方式一：        export VARNAME=VALUE    定义方式二：        VARNAME=VALUE        export VARNAME    查看当前shell中的环境变量：        printenv        env        export本地变量(局部变量)：    本地变量：set VARNAME=VALUE: 作用域为整个bash进程；        撤消变量：unset VARNAME        查看当shell中变量：set    局部变量：local VARNAME=VALUE：作用域为当前代码段；位置变量：    $1, $2, ...：脚本的第几个参数    shift：脚本的参数前移。第二个参数变为第一个...    ./filetest.sh /etc/fstab /etc/inittab        $1: /etc/fstab        $2: /etc/inittab特殊变量：    $?: 上一个命令的执行状态返回值；    $#：参数的个数    $*: 参数列表    $@：参数列表    </code></pre><p>引用变量：${VARNAME}, 括号有时可省略。如：$<strong>VARNAME</strong>OTHER这种变量后面直接跟其它字符的括号不能省略。</p><p>变量名称：</p><ul><li>只能包含字母、数字和下划线，并且不能数字开头；</li><li>不应该跟系统中已有的环境变量重名；</li><li>最好做到见名知义；</li></ul><p>程序执行，可能有两类返回值：</p><ul><li>程序执行结果（程序输出结果）</li><li>程序状态返回代码（0-255）<ul><li>0: 正确执行</li><li>1-255：错误执行。其中：1，2，127系统预留；</li></ul></li></ul><p>&#x2F;dev&#x2F;null: 软件设备， bit bucket，数据黑洞。在命令执行中，如果我们不想显示命令的执行结果，可以将命令输出重定向到数据黑洞。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>脚本：命令的堆砌，按实际需要，结合命令流程控制机制实现的源程序</p><p>脚本在执行时会启动一个子shell进程；命令行中启动的脚本会继承当前shell环境变量；系统自动执行的脚本(非命令行启动)就需要自我定义需要的各环境变量；</p><p>在脚本的第一行必须添加shebang（魔数），如下</p><pre><code> #!/bin/bash # 其它行中#代表注释行，不执行</code></pre><p>提示：</p><pre><code>“引用”一个命令的执行结果，要使用命令引用；比如: RESAULTS=`wc -l /etc/passwd | cut -d: -f1`；使用一个命令的执行状态结果，要直接执行此命令，一定不能引用；比如: if id user1一句中的id命令就一定不能加引号；如果想把一个命令的执行结果赋值给某变量，要使用命令引用，比如USERID=`id -u user1`;如果想把一个命令的执行状态结果保存下来，并作为命令执行成功与否的判断条件，则需要先执行此命令，而后引用其状态结果，如    id -u user1    RETVAL=$?    此句绝对不可以写为RETVAL=`id -u user1`；</code></pre><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>  与：两边都为真结果为真<br>  或：只要有一个为真结果就为真<br>  非：结果取反<br>  异或：两边结果不同真  </p><p>命令间的逻辑关系：</p><pre><code>逻辑与： &amp;&amp;    第一个条件为假时，第二条件不用再判断，最终结果已经有；    第一个条件为真时，第二条件必须得判断；逻辑或： ||    第一个条件为直时，第二条件不用再判断，最终结果已经有；    第一个条件为假时，第二条件必须得判断；</code></pre><p>如果用户user6不存在，就添加用户user6</p><pre><code>! id user6 &amp;&amp; useradd user6id user6 || useradd user6</code></pre><p>如果用户存在，就显示用户已存在；否则，就添加此用户；</p><pre><code>id user1 &amp;&amp; echo &quot;user1 exists.&quot; || useradd user1</code></pre><p>如果用户不存在，就添加；否则，显示其已经存在；</p><pre><code>! id user1 &amp;&amp; useradd user1 || echo &quot;user1 exists.&quot;</code></pre><p>如果用户不存在，添加并且给密码；否则，显示其已经存在；</p><pre><code>! id user1 &amp;&amp; useradd user1 &amp;&amp; echo &quot;user1&quot; | passwd --stdin user1|| echo &quot;user1 exists.&quot;id user7 &amp;&amp; echo &quot;user exists&quot; || useradd user7 || echo &quot;user7&quot;|passwd --stdin user7</code></pre><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><pre><code>如果用户不存在    添加用户，给密码并显示添加成功；否则    显示如果已经没在，没有添加；</code></pre><p>bash中的条件测试类型：  </p><ul><li><p>整数测试</p><p>  -eq: 测试两个整数是否相等；比如 $A -eq $B<br>  -ne: 测试两个整数是否不等；不等，为真；相等，为假；<br>  -gt: 测试一个数是否大于另一个数；大于，为真；否则，为假；<br>  -lt: 测试一个数是否小于另一个数；小于，为真；否则，为假；<br>  -ge: 大于或等于<br>  -le：小于或等于</p></li><li><p>字符测试</p><p>  &#x3D;&#x3D; ：测试是否相等，相等为真，不等为假<br>  !&#x3D; : 测试是否不等，不等为真，等为假<br>  &gt;： 测试两个字符串大小<br>  &lt;： 测试两个字符串大小<br>  -n string: 测试指定字符串是否为空，空则真，不空则假<br>  -z string: 测试指定字符串是否不空，不空为真，空则为假</p></li><li><p>文件测试</p><p>  -e FILE: 测试文件是否存在<br>  -f FILE: 测试文件是否为普通文件<br>  -d FILE: 测试指定路径是否为目录<br>  -r FILE: 测试当前用户对指定文件是否有读取权限；<br>  -w FILE: 测试当前用户对指定文件是否有写入权限；<br>  -x FILE: 测试当前用户对指定文件是否有执行权限；</p></li></ul><p>条件测试的表达式：  </p><pre><code>[ expression ]  [[ expression ]]  test expression注：&#39;[&#39;和&#39;]&#39; 内部要有一个空格，否则报错。INT1=63INT2=77[ $INT1 -eq $INI2 ][[ $INT1 -eq $INT2 ]]test $INT1 -eq $INT2   [ -e /etc/inittab ][ -x /etc/rc.d/rc.sysinit ] </code></pre><p>如果&#x2F;etc&#x2F;inittab文件的行数大于100，就显示好大的文件；</p><pre><code>[ `wc -l /etc/inittab | cut -d&#39; &#39; -f1` -gt 100 ] &amp;&amp; echo &quot;Large file.&quot;</code></pre><blockquote><p>注：Linux的Shell中0为真，其它整数为假。  </p></blockquote><p>条件判断，控制结构：</p><pre><code>单分支if语句if 判断条件; then  statement1  statement2  ...fi双分支的if语句：if 判断条件; then    statement1    statement2    ...else    statement3    statement4    ...fi多分支的if语句：if 判断条件1; then  statement1  ...elif 判断条件2; then  statement2  ...elif 判断条件3; then  statement3  ...else  statement4  ...ficase语句：选择结构case SWITCH in value1)  statement  ...  ;;value2)  statement  ...  ;;*)  statement  ...  ;;esaca-zA-Z0-9[abc]</code></pre><p>shell处理参数：</p><pre><code>#!/bin/bash#DEBUG=0ADD=0DEL=0for I in `seq 0 $#`; do  if [ $# -gt 0 ]; then      case $1 in      -v|--verbose)        DEBUG=1        shift ;;      -h|--help)        echo &quot;Usage: `basename $0` --add USER_LIST --del USER_LIST -v|--verbose -h|--help&quot;        exit 0        ;;      --add)        ADD=1        ADDUSERS=$2        shift 2        ;;      --del)        DEL=1        DELUSERS=$2        shift 2        ;;      *)        echo &quot;Usage: `basename $0` --add USER_LIST --del USER_LIST -v|--verbose -h|--help&quot;        exit 7        ;;    esac  fidoneif [ $ADD -eq 1 ]; then  for USER in `echo $ADDUSERS | sed &#39;s@,@ @g&#39;`; do    if id $USER &amp;&gt; /dev/null; then      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;$USER exists.&quot;    else      useradd $USER      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;Add user $USER finished.&quot;    fi  donefiif [ $DEL -eq 1 ]; then  for USER in `echo $DELUSERS | sed &#39;s@,@ @g&#39;`; do    if id $USER &amp;&gt; /dev/null; then      userdel -r $USER      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;Delete $USER finished.&quot;    else      [ $DEBUG -eq 1 ] &amp;&amp; echo &quot;$USER not exist.&quot;    fi  donefi</code></pre><p>组合测试条件</p><pre><code>-a: 与关系-o: 或关系!： 非关系if [ $# -gt 1 -a $# -le 3 ]if [ $# -gt 1 ] &amp;&amp; [ $# -le 3 ]注：取反要注意,比如！（A -a B） = ！A -o ！B</code></pre><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><pre><code>A=3B=61、let 算术运算表达式    let C=$A+$B2、$[算术运算表达式]    C=$[$A+$B]3、$((算术运算表达式))    C=$(($A+$B))4、expr 算术运算表达式，表达式中各操作数及运算符之间要有空格，而且要使用命令引用    C=`expr $A + $B`</code></pre><h2 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h2><pre><code>exit: 退出脚本exit #如果脚本没有明确定义退出状态码，那么，最后执行的一条命令的退出码即为脚本的退出状态码；</code></pre><h2 id="检查语法错误"><a href="#检查语法错误" class="headerlink" title="检查语法错误"></a>检查语法错误</h2><pre><code>bash -n 脚本：检查脚本，结果只供参考bash -x 脚本：单步执行</code></pre><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>shell循环有三种语法结构： </p><ul><li><p>for</p><pre><code>  for 变量 in 列表; do    循环体  done  for I in 1 2 3 4 5 6 7 8 9 10; do    加法运算  done  如何生成列表：      &#123;1..100&#125;      `seq [起始数 [步进长度]] 结束数`  for (( expr1 ; expr2 ; expr3 )); do     循环体  done</code></pre></li><li><p>while</p><pre><code>  进入循环：条件满足  退出循环：条件不满足  while CONDITION; do    statment  done</code></pre></li><li><p>until</p><pre><code>  进入循环：条件不满足  退出循环：条件满足  until CONDITION; do    statement    ...  done</code></pre></li></ul><p>循环体内中断循环语句：</p><pre><code>break: 提前退出循环  continue：提前结束本轮循环，而进入下一轮循环；</code></pre><p>while特殊用法：</p><pre><code>while的特殊用法一（死循环）：while :;do  donewhile的特殊用法二（读取/PATH/TO/SOMEFILE，将每一行内容赋值给LINE变量）：while read LINE; dodone &lt; /PATH/TO/SOMEFILE</code></pre><h2 id="declare命令"><a href="#declare命令" class="headerlink" title="declare命令"></a>declare命令</h2><pre><code>declare -i SUM=0declare [+/-][选项] 变量名    - ：给变量赋予类型属性    + ：取消变量的类型属性    -a：将变量声明为数组型    -i：将变量声明为整型    -x：将变量声明为环境变量    -r：将变量声明为只读变量    -p：查看变量的被声明的类型</code></pre><h2 id="shell选项"><a href="#shell选项" class="headerlink" title="shell选项"></a>shell选项</h2><p>写一个脚本，显示当前系统上shell为-s指定类型的用户，并统计其用户总数。-s选项后面跟的参数必须是&#x2F;etc&#x2F;shells文件中存在的shell类型，否则不执行此脚本。另外，此脚本还可以接受–help选项，以显示帮助信息。</p><pre><code>脚本执行形如：./showshells.sh -s bash显示结果形如：BASH，3users，they are:root,redhat,gentoo#!/bin/bash#if [ $1 == &#39;-s&#39; ]; then  ! grep &quot;$&#123;2&#125;$&quot; /etc/shells &amp;&gt; /dev/null &amp;&amp; echo &quot;Invalid shell.&quot; &amp;&amp; exit 7elif [ $1 == &#39;--help&#39; ];then  echo &quot;Usage: showshells.sh -s SHELL | --help&quot;  exit 0else  echo &quot;Unknown Options.&quot;  exit 8fiNUMOFUSER=`grep &quot;$&#123;2&#125;$&quot; /etc/passwd | wc -l`SHELLUSERS=`grep &quot;$&#123;2&#125;$&quot; /etc/passwd | cut -d: -f1`SHELLUSERS=`echo $SHELLUSERS | sed &#39;s@[[:space:]]@,@g&#39;`echo -e &quot;$2, $NUMOFUSER users, they are: \n$SHELLUSERS&quot;</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数定义：</p><pre><code>function FUNCNAME &#123;  command&#125;FUNCNAME() &#123;  command&#125;</code></pre><p>自定义执行状态返回值：</p><pre><code>return #0-255</code></pre><p>函数的参数:</p><pre><code>在脚本中传递参数方式：./a.sh m n $1: m$2: n在函数中传递参数方式和上面类似：funcion_name 5 6$1: 5$2: 6</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>1、变量中字符的长度：</p><pre><code>$&#123;\#VARNAME&#125;</code></pre><p>2、变量赋值等：</p><pre><code>$&#123;parameter:-word&#125;：如果parameter为空或未定义，则变量展开为“word”；否则，展开为parameter的值；$&#123;parameter:+word&#125;：如果parameter为空或未定义，不做任何操作；否则，则展开为“word”值；$&#123;parameter:=word&#125;：如果parameter为空或未定义，则变量展开为“word”，并将展开后的值赋值给parameter；$&#123;parameter:offset&#125;：取子串，从offset处的后一个字符开始$&#123;parameter:offset:length&#125;：取子串，从offset处的后一个字符开始，取lenth长的子串；  </code></pre><p>4、局部变量</p><pre><code>定义：local VAR_NAME=a=1test() &#123;  a=$[3+4]&#125;testfor I in `seq $a 10`; do  echo $Idone  </code></pre><p>5、命令mktemp</p><pre><code>创建临时文件或目录mktemp /tmp/file.XX    -d: 创建为目录</code></pre><p>6、信号</p><pre><code>kill -SIGNAL PID    1: HUP    2: INT    9: KILL    15: TERM    脚本中，能实现信号捕捉，但9和15无法捕捉Ctrl+c: SIGINTtrap命令：在脚本中捕获相应信号，执行信号对应的命令    trap &#39;COMMAND&#39; 信号列表注：信号0是Exit信号，这是Bash脚本特有信号，不管什么情况，只要退出脚本就会执行。</code></pre><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>写一个脚本，完成以下任务<br>1、添加5个用户, user1,…, user5<br>2、每个用户的密码同用户名，而且要求，添加密码完成后不显示passwd命令的执行结果信息；<br>3、每个用户添加完成后，都要显示用户某某已经成功添加；  </p><pre><code>useradd user1echo &quot;user1&quot; | passwd --stdin user1 &amp;&gt; /dev/nullecho &quot;Add user1 successfully.&quot;</code></pre><p>写一个脚本，完成以下要求：<br>1、添加3个用户user1, user2, user3；但要先判断用户是否存在，不存在而后再添加；<br>2、添加完成后，显示一共添加了几个用户；当然，不能包括因为事先存在而没有添加的；<br>3、最后显示当前系统上共有多少个用户；</p><p>写一个脚本，完成以下要求：<br>给定一个用户：<br>1、如果其UID为0，就显示此为管理员；<br>2、否则，就显示其为普通用户；  </p><pre><code>NAME=user16USERID=`id -u $NAME`if [ $USERID -eq 0 ]; then  echo &quot;Admin&quot;else  echo &quot;common user.&quot;fiNAME=user16if [ `id -u $NAME` -eq 0 ]; then  echo &quot;Admin&quot;else  echo &quot;common user.&quot;fi</code></pre><p>写一个脚本<br>判断当前系统上是否有用户的默认shell为bash；<br>   如果有，就显示有多少个这类用户；否则，就显示没有这类用户；</p><pre><code>grep &quot;bash$&quot; /etc/passwd &amp;&gt; /dev/nullRETVAL=$?if [ $RETVAL -eq 0 ]; then   ...注：grep 匹配上命令执行结果返回0，否则返回1</code></pre><p>写一个脚本<br>判断当前系统上是否有用户的默认shell为bash；<br>   如果有，就显示其中一个的用户名；否则，就显示没有这类用户；  </p><p>写一个脚本<br>给定一个文件，比如&#x2F;etc&#x2F;inittab<br>判断这个文件中是否有空白行；<br>如果有，则显示其空白行数；否则，显示没有空白行。</p><pre><code>#!/bin/bashA=`grep &#39;^$&#39; /etc/inittab | wc -l`if [ $A -gt 0 ]; then echo &quot;$A&quot;else echo &quot;meiyoukongbaihang&quot;fi                 —— by 张帅                 #!/bin/bashFILE=/etc/inittabif [ ! -e $FILE ]; then  echo &quot;No $FILE.&quot;  exit 8fiif grep &quot;^$&quot; $FILE &amp;&gt; /dev/null; then  echo &quot;Total blank lines: `grep &quot;^$&quot; $FILE | wc -l`.&quot;else  echo &quot;No blank line.&quot;fi</code></pre><p>写一个脚本<br>给定一个用户，判断其UID与GID是否一样<br>如果一样，就显示此用户为“good guy”；否则，就显示此用户为“bad  guy”。 </p><pre><code>#!/bin/bashUSERNAME=user1USERID=`id -u $USERNAME`GROUPID=`id -g $USERNAME`if [ $USERID -eq $GROUPID ]; then  echo &quot;Good guy.&quot;else  echo &quot;Bad guy.&quot;fi进一步要求：不使用id命令获得其id号；#!/bin/bash#USERNAME=user1if ! grep &quot;^$USERNAME\&gt;&quot; /etc/passwd &amp;&gt; /dev/null; then  echo &quot;No such user: $USERNAME.&quot;  exit 1fiUSERID=`grep &quot;^$USERNAME\&gt;&quot; /etc/passwd | cut -d: -f3`GROUPID=`grep &quot;^$USERNAME\&gt;&quot; /etc/passwd | cut -d: -f4`if [ $USERID -eq $GROUPID ]; then  echo &quot;Good guy.&quot;else  echo &quot;Bad guy.&quot;fi</code></pre><p>写一个脚本<br>给定一个用户，获取其密码警告期限；<br>而后判断用户密码使用期限是否已经小于警告期限； </p><pre><code>提示：计算方法，最长使用期限减去已经使用的天数即为剩余使用期限；如果小于，则显示“Warning”；否则，就显示“OK”。圆整：丢弃小数点后的所有内容注：密码文件有些用户的密码修改时间为空，没有处理#!/bin/bashW=`grep &quot;student&quot; /etc/shadow | cut -d: -f6`S=`date +%s`T=`expr $S/86400`L=`grep &quot;^student&quot; /etc/shadow | cut -d: -f5`N=`grep &quot;^student&quot; /etc/shadow | cut -d: -f3`SY=$[$L-$[$T-$N]]if [ $SY -lt $W ]; then  echo &#39;Warning&#39;else  echo &#39;OK&#39;fi                    —— by 董利东</code></pre><p>写一个脚本<br>给定一个文件：<br>如果是一个普通文件，就显示之；<br>如果是一个目录，亦显示之；<br>否则，此为无法识别之文件；</p><p>写一脚本<br>能接受一个参数(文件路径)<br>判定：此参数如果是一个存在的文件，就显示“OK.”；否则就显示”No such file.”</p><p>写一个脚本<br>给脚本传递两个参数(整数)；<br>显示此两者之和，之乘积；  </p><pre><code>#!/bin/bash#if [ $# -lt 2 ]; then  echo &quot;Usage: cacl.sh ARG1 ARG2&quot;  exit 8fiecho &quot;The sum is: $[$1+$2].&quot;echo &quot;The prod is: $[$1*$2].&quot;</code></pre><p>写一个脚本，完成以下任务<br>1、使用一个变量保存一个用户名；<br>2、删除此变量中的用户，且一并删除其家目录；<br>3、显示“用户删除完成”类的信息；  </p><p>写一个脚本<br>传递一个参数(单字符就行)给脚本，如参数为q，就退出脚本；否则，就显示用户的参数；  </p><p>写一个脚本<br>传递一个参数(单字符就行)给脚本，如参数为q、Q、quit或Quit，就退出脚本；否则，就显示用户的参数；  </p><pre><code>#!/bin/bash#if [ $1 = &#39;q&#39; ];then  echo &quot;Quiting...&quot;  exit 1elif [ $1 = &#39;Q&#39; ];then  echo &quot;Quiting...&quot;  exit 2  elif [ $1 = &#39;quit&#39; ];then  echo &quot;Quiting...&quot;  exit 3 elif [ $1 = &#39;Quit&#39; ];then  echo &quot;Quiting...&quot;  exit 4  else  echo $1fi</code></pre><p>传递三个参数给脚本，第一个为整数，第二个为算术运算符，第三个为整数，将计算结果显示出来，要求保留两位精度。形如：  </p><pre><code>./calc.sh 5 / 2Linux中计算可以使用bc计算器[root@localhost shells]# echo &quot;scale=2;5/2&quot;|bc2.50</code></pre><p>传递3个参数给脚本，参数均为用户名。将此些用户的帐号信息提取出来后放置于&#x2F;tmp&#x2F;testusers.txt文件中，并要求每一行行首有行号。  </p><p>写一个脚本：<br>判断当前主机的CPU生产商，其信息在&#x2F;proc&#x2F;cpuinfo文件中vendor id一行中。 </p><pre><code>如果其生产商为AuthenticAMD，就显示其为AMD公司；如果其生产商为GenuineIntel，就显示其为Intel公司；否则，就说其为非主流公司；</code></pre><p>写一个脚本：<br>给脚本传递三个整数，判断其中的最大数和最小数，并显示出来。</p><pre><code>MAX=0MAX -eq $1MAX=$1MAX -lt $2MAX=$2</code></pre><p>写一个脚本：<br>1、设定变量FILE的值为&#x2F;etc&#x2F;passwd<br>2、依次向&#x2F;etc&#x2F;passwd中的每个用户问好，并显示对方的shell，形如：    </p><pre><code>Hello, root, your shell: /bin/bash</code></pre><p>3、统计一共有多少个用户  </p><pre><code>for I in `seq 1 $LINES`; do echo &quot;Hello, `head -n $I /etc/passwd | tail -1 | cut -d: -f1`&quot;; done</code></pre><p>只向默认shell为bash的用户问声好</p><p>写一个脚本：<br>1、添加10个用户user1到user10，密码同用户名；但要求只有用户不存在的情况下才能添加；  </p><pre><code>扩展：接受一个参数：add: 添加用户user1..user10del: 删除用户user1..user10其它：退出adminusers user1,user2,user3,hello,hi</code></pre><p>写一个脚本：<br>计算100以内所有能被3整除的正整数的和；</p><pre><code>取模，取余:%3%2=1100%55=45</code></pre><p>写一个脚本：<br>计算100以内所有奇数的和以及所有偶数的和；分别显示之；  </p><pre><code>let I=$[$I+1]SUM=$[$SUM+$I]let SUM+=$Ilet I+=1 相当于 let I++let I-=1 相当于 let I--    ++I, --I*=、/=、%=</code></pre><p>写一个脚本<br>分别显示当前系统上所有默认shell为bash的用户和默认shell为&#x2F;sbin&#x2F;nologin的用户，并统计各类shell下的用户总数。显示结果形如：  </p><pre><code>BASH，3users，they are:root,redhat,gentooNOLOGIN, 2users, they are:bin,ftp#!/bin/bash#NUMBASH=`grep &quot;bash$&quot; /etc/passwd | wc -l`BASHUSERS=`grep &quot;bash$&quot; /etc/passwd | cut -d: -f1`BASHUSERS=`echo $BASHUSERS | sed &#39;s@[[:space:]]@,@g&#39;`echo &quot;BASH, $NUMBASH users, they are:&quot;echo &quot;$BASHUSERS</code></pre><p>写一个脚本，利用RANDOM生成10个随机数，并找出其中的最大值，和最小值；</p><pre><code>#!/bin/bash#declare -i MAX=0declare -i MIN=0for I in &#123;1..10&#125;; do  MYRAND=$RANDOM  [ $I -eq 1 ] &amp;&amp; MIN=$MYRAND  if [ $I -le 9 ]; then    echo -n &quot;$MYRAND,&quot;  else    echo &quot;$MYRAND&quot;  fi  [ $MYRAND -gt $MAX ] &amp;&amp; MAX=$MYRAND  [ $MYRAND -lt $MIN ] &amp;&amp; MIN=$MYRANDdoneecho $MAX, $MIN</code></pre><p>写一个脚本<br>通过命令行传递一个文件路径参数给脚本：  </p><pre><code>如果参数多了或少了，报错；如果参数指定的路径对应的是目录而不是文件，报错；</code></pre><p>而后，检查路径指定的文件是否为空或不存在，如果是，则新建此文件，并在文件中生成如下内容</p><pre><code>#!/bin/bash# </code></pre><p>而后，使用vim编辑器打开此文件，并让光标处于这个文件的最后一行；</p><p>写个脚本，按如下方式执行：  </p><pre><code>mkscript.sh -v|--version VERSION -a|--author AUTHOR -t|--time DATETIME -d|--description DESCRIPTION -f|--file /PATH/TO/FILE -h|--help </code></pre><p>1、此脚本能创建或打开-f选项指向的文件&#x2F;PATH&#x2F;TO&#x2F;FILE；如果其为空文件，能自动为其生成第一行；如果文件不空，且第一行不是#!&#x2F;bin&#x2F;bash，则中止此脚本，并报错“The file is not a bash script.”；否则，则直接使用vim 打开此文件；<br>提示：&#x2F;PATH&#x2F;TO&#x2F;FILE，要判断其目录是否存在；如果不存在，则报错；</p><p>2、如果为空文件，自动生成的第一行内容为：</p><pre><code>#!/bin/bash</code></pre><p>3、如果为空文件，且使用了-a选项，则在文件中添加“# Author: -a选项的参数”，比如：</p><pre><code># Author: Jerry</code></pre><p>4、如果为空文件，且使用了-t选项，则在文件中添加“# Date: 脚本执行-t选项后指定的时间”，比如：</p><pre><code># Date: 2013-03-08 18:05</code></pre><p>5、如果为空文件，且使用了-d选项，则在文件中添加“# Description: -d选项的内容”，比如：</p><pre><code># Description: Create a bash script file head.</code></pre><p>6、如果为空文件，且使用了-v选项，则在文件添加“# Version: -v后跟的参数”，比如:<br>    # Version: 0.1<br>6、-h选项只能单独使用，用于显示使用帮助；<br>7、其它选项，显示帮助信息；  </p><p>说明：<br>这是一个用于创建脚本的脚本，它可以自动帮助创建一个bash脚本的文件头，这样，以后使用此脚本来创建其它脚本将变得比较高效。比如：</p><pre><code>#!/bin/bash# Author: Jerry(jerry@magedu.com)# Date: 2013-03-08 18:05# Description: Create a bash script file head.# Version: 0.1</code></pre><p>计算100以内所有正整数的和</p><pre><code>#!/bin/bashdeclare -i I=1declare -i SUM=0while [ $I -le 100 ]; do  let SUM+=$I  let I++doneecho $SUM</code></pre><p>练习：转换用户输入的字符为大写，除了quit:</p><pre><code>#!/bin/bash#read -p &quot;Input something: &quot; STRINGwhile [ $STRING != &#39;quit&#39; ]; do  echo $STRING | tr &#39;a-z&#39; &#39;A-Z&#39;  read -p &quot;Input something: &quot; STRINGdone</code></pre><p>每隔5秒查看hadoop用户是否登录，如果登录，显示其登录并退出；否则，显示当前时间，并说明hadoop尚未登录：</p><pre><code>#!/bin/bash#who | grep &quot;hadoop&quot; &amp;&gt; /dev/nullRETVAL=$?while [ $RETVAL -ne 0 ]; do  echo &quot;`date`, hadoop is not log.&quot;   sleep 5  who | grep &quot;hadoop&quot; &amp;&gt; /dev/null  RETVAL=$?doneecho &quot;hadoop is logged in.&quot;</code></pre><p>写一个脚本：  </p><ol><li><p>显示一个菜单给用户：  </p><p> d|D) show disk usages.<br> m|M) show memory usages.<br> s|S) show swap usages.<br> *) quit.</p></li><li><p>当用户给定选项后显示相应的内容；</p></li></ol><p>扩展：<br>    当用户选择完成，显示相应信息后，不退出；而让用户再一次选择，再次显示相应内容；除了用户使用quit；</p><pre><code>#!/bin/bash#cat &lt;&lt; EOFd|D) show disk usages.m|M) show memory usages.s|S) show swap usages.*) quit.EOFread -p &quot;Your choice: &quot; CHOICEwhile [ $CHOICE != &#39;quit&#39; ];do  case $CHOICE in  d|D)    echo &quot;Disk usage: &quot;    df -Ph ;;  m|M)    echo &quot;Memory usage: &quot;    free -m | grep &quot;Mem&quot; ;;  s|S)    echo &quot;Swap usage: &quot;    free -m | grep &quot;Swap&quot; ;;  *)    echo &quot;Unknown..&quot; ;;  esacread -p &quot;Again, your choice: &quot; CHOICEdone</code></pre><p>写一个脚本：  </p><p>1、通过ping命令测试192.168.0.151到192.168.0.254之间的所有主机是否在线，</p><pre><code>如果在线，就显示&quot;ip is up.&quot;，其中的IP要换为真正的IP地址，且以绿色显示；如果不在线，就显示&quot;ip is down.&quot;，其中的IP要换为真正的IP地址，且以红色显示；echo -e &quot;\033[33;44mhello wrold\033[0m&quot;echo -e &quot;\033[33;44;1mhello wrold\033[0m&quot;    -e:开启转义字符    \033[： 后面跟着具体设置    1m：高亮显示    4m：下划线    30-37；前景色    40-47：后景色    5m：闪烁    7m：反显    8m：消隐    9m：斜线awk &#39;PATTERN&#123;ACTION&#125;&#39; file[root@localhost /]# awk -F : &#39;&#123;print $1,$3&#125;&#39; /etc/passwdroot 0bin 1daemon 2注：-F指定分隔符，$#代表分割后的第几列</code></pre><p>要求：分别使用while，until和for(两种形式)循环实现。<br>ping -c -W</p><p>写一个脚本，完成如下功能：<br>说明：此脚本能够为指定网卡创建别名，则指定地址；使用格式如：</p><pre><code>mkethalias.sh -v|--verbose -i ethX  </code></pre><p>1、-i选项用于指定网卡；指定完成后，要判断其是否存在，如果不存在，就退出；<br>2、如果用户指定的网卡存在，则让用户为其指定一个别名，此别名可以为空；如果不空，请确保其事先不存在，否则，要报错，并让用户重新输入；<br>3、在用户输入了一个正确的别名后，请用户输入地址和掩码；并将其配置在指定的别名上；<br>4、如果用户使用了-v选项，则在配置完成后，显示其配置结果信息；否则，将不显示；</p><p>写一个脚本，完成以下功能：  </p><pre><code>1、提示用户输入一个用户名；2、显示一个菜单给用户，形如：U|u  show UIDG|g  show GIDS|s  show SHELLQ|q  quit3、提醒用户选择一个选项，并显示其所选择的内容；</code></pre><p>如果用户给的是一个非上述所提示的选项，则提醒用户给出的选项错误，并请其重新选择后执行；</p><p>写一个脚本：<br>1、判断一个指定的bash脚本是否有语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出，其它任何键可以通过vim打开这个指定的脚本；<br>2、如果用户通过vim打开编辑后保存退出时仍然有错误，则重复第1步中的内容；否则，就正常关闭退出。  </p><pre><code>./syntax.sh a.shuntil bash -n $1 &amp;&gt; /dev/null; do    read -p &quot;Syntax error, [Qq] to quit, others for editing: &quot;  CHOICE    case $CHOICE in    q|Q)        echo &quot;Something wrong, quiting.&quot;        exit 5        ;;    *)        vim + $1        ;;    esacdoneecho &quot;0K&quot;</code></pre><p>练习：写一个脚本，判定192.168.0.200-192.168.0.254之间的主机哪些在线。要求：<br>1、使用函数来实现一台主机的判定过程；<br>2、在主程序中来调用此函数判定指定范围内的所有主机的在线情况。</p><pre><code>#!/bin/bash#PING() &#123;  for I in &#123;200..254&#125;;do    if ping -c 1 -W 1 192.168.0.$I &amp;&gt; /dev/null; then      echo &quot;192.168.0.$I is up.&quot;    else      echo &quot;192.168.0.$I is down.&quot;    fi  done&#125;PING#!/bin/bash#PING() &#123;    if ping -c 1 -W 1 $1 &amp;&gt; /dev/null; then      echo &quot;$1 is up.&quot;    else      echo &quot;$1 is down.&quot;    fi&#125;for I in &#123;200..254&#125;; do  PING 192.168.0.$Idone#!/bin/bash#PING() &#123;    if ping -c 1 -W 1 $1 &amp;&gt; /dev/null; then      return 0    else      return 1    fi&#125;for I in &#123;200..254&#125;; do  PING 192.168.0.$I  if [ $? -eq 0 ]; then    echo &quot;192.168.0.$I is up.&quot;  else    echo &quot;192.168.0.$I is down.&quot;  fidone</code></pre><p>写一个脚本：使用函数完成<br>1、函数能够接受一个参数，参数为用户名； </p><ul><li>判断一个用户是否存在  </li><li>如果存在，就返回此用户的shell和UID；并返回正常状态值；  </li><li>如果不存在，就说此用户不存在；并返回错误状态值；</li></ul><p>2、在主程序中调用函数；  </p><ul><li><p>扩展1：在主程序中，让用户自己输入用户名后，传递给函数来进行判断；</p></li><li><p>扩展2：在主程序中，输入用户名判断后不退出脚本，而是提示用户继续输入下一个用户名；如果用户输入的用户不存在，请用户重新输入；但如果用户输入的是q或Q就退出；</p><pre><code>  #!/bin/bash  #  user () &#123;  if id $1 &amp;&gt; /dev/null ;then  echo &quot;`grep ^$1  /etc/passwd | cut -d: -f3,7`&quot;     return 0  else     echo &quot;no $1&quot;      return 1  fi  &#125;  read -p &quot;please input username:&quot; username  until [ $username == q -o $username == Q ]; do      user $username      if [ $? == 0 ];then          read -p &quot;please input again:&quot; username      else          read -p &quot;no $username,please input again:&quot; username      fi  done</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;编程语言分类&quot;&gt;&lt;a href=&quot;#编程语言分类&quot; class=&quot;headerlink&quot; title=&quot;编程语言分类&quot;&gt;&lt;/a&gt;编程语言分类&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;编程语言可以分为机器语言、汇编语言、高级语言三种，其中高级语言还可以分为静态语言和</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="shell" scheme="http://example.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程管理</title>
    <link href="http://example.com/2022/11/27/Linux-program/"/>
    <id>http://example.com/2022/11/27/Linux-program/</id>
    <published>2022-11-27T13:35:48.747Z</published>
    <updated>2022-11-27T13:35:48.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程基础"><a href="#进程基础" class="headerlink" title="进程基础"></a>进程基础</h2><blockquote><p>进程也被叫做运行中的程序。当我们安装完软件之后，只是将软件文件保存在了硬盘中。我们运行软件，则会生成进程。计算机可以运行多个进程，但我们的内存只有一个。因此多个进程要对内存进行管理，这时我们采用虚拟地址空间避免进程去操作不属于自己的内存。在运行过程中所有进程需要的内存可能大于物理内存，这时我们需要使用虚拟内存和页面置换技术。计算机的多进程同时依赖于CPU（单核）的时间分片，因此在运行过程中我们需要进行进程切换。</p></blockquote><p><a href="https://blog.csdn.net/u014379540/article/details/52263114">https://blog.csdn.net/u014379540/article/details/52263114</a></p><h2 id="Linux查看进程命令"><a href="#Linux查看进程命令" class="headerlink" title="Linux查看进程命令"></a>Linux查看进程命令</h2><p>ps: Process State 查看进程状态</p><pre><code>BSD风格:a: 所有与终端有关的进程 u: 显示更详细信息x: 所有与终端无关的进程[demo@localhost ~]$ ps -auxUSER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot          1  0.2  0.5 194160  5088 ?        Ss   09:15   0:04 /usr/lib/systemd/systemd --switched-root --system --deseriroot          2  0.0  0.0      0     0 ?        S    09:15   0:00 [kthreadd]root          4  0.0  0.0      0     0 ?        S&lt;   09:15   0:00 [kworker/0:0H]root          5  0.0  0.0      0     0 ?        S    09:15   0:01 [kworker/u256:0]demo      19682  0.0  0.2 157456  2228 pts/0    R+   09:41   0:00 ps -aux字段含义：    USER：进程拥有者    PID ：进程ID    %CPU：占用的CPU使用率，它是使用的CPU时间除以进程已运行的时间（cputime/realtime比率），以百分比表示。除非你运气好，否则加起来不会达到100%    %MEM：进程占用的内存使用率    VSZ ：进程虚拟内存大小，一个进程使用的物理空间外加其所有共享库的空间。即进程可能使用的最大内存量。    RSS ：驻留集大小，进程中不能被交换出去部分（分页）的物理内存（指令和变量）。    TTY ：登入者的终端位置,?表示与终端无关    STAT：进程状态    START：进程的启动时间    TIME：进程已执行的时间    COMMAND：所执行的指令，加中括号表示是内核线程。进程状态：    D：不可中断的睡眠（比如磁盘IO，如果该进程所属条件（将文件读入内存中）没有完成不能结束中断）    R：运行或就绪    S：可中断的睡眠（比如网卡，当有数据到来之后可以立即结束中断）    T：停止    Z：僵死（运行结束，但是没有释放资源）        &lt;：高优先级进程    N： 低优先级进程    +：前台进程组（一个bash下可以运行很多进程，这些进程属于同一个进程组）中的进程    l: 多线程进程    s: 会话进程首进程（用户建立的连接。比如ssh，下面会有很多子进程。如果该进程结束，它下面的进程都会被结束）SysV风格：-ps    -elF    -ef    -eF    -e：显示所有进程ps -o PROPERTY1,PROPERTY2ps -o pid,comm,ni ：指定命令输出字段[demo@localhost ~]$ ps -axo pid,comm,ni   PID COMMAND          NI 10056 bash              0 10473 ps                0[demo@localhost ~]$ ps -elFF S UID         PID   PPID  C PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD4 S root          1      0  0  80   0 - 48542 ep_pol  5056   0 08:55 ?        00:00:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 221 S root          2      0  0  80   0 -     0 kthrea     0   0 08:55 ?        00:00:00 [kthreadd]1 S root          4      2  0  60 -20 -     0 worker     0   0 08:55 ?        00:00:00 [kworker/0:0H]1 S root          5      2  0  80   0 -     0 worker     0   0 08:55 ?        00:00:00 [kworker/u256:0]注：PRI：优先级、NI：nice值、PSR：运行在哪个cpu上、PPID：父进程ID[demo@localhost ~]$ ps -efUID         PID   PPID  C STIME TTY          TIME CMDroot          1      0  0 08:55 ?        00:00:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root          2      0  0 08:55 ?        00:00:00 [kthreadd][demo@localhost ~]$ ps -eFUID         PID   PPID  C    SZ   RSS PSR STIME TTY          TIME CMDroot          1      0  0 48542  5056   0 08:55 ?        00:00:03 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root          2      0  0     0     0   0 08:55 ?        00:00:00 [kthreadd]注：init或systemd: 进程号为1，是操作系统启动后的第一个进程，也是所有进程的父进程。</code></pre><p>pstree: 显示当前系统上的进程</p><p>pgrep：匹配进程名对应的pid</p><pre><code>[demo@localhost ~]$ pgrep systemd1506544115220169</code></pre><p>pidof: 根据程序名称，查找其相关进程的ID号</p><pre><code>[demo@localhost ~]$ pidof systemd1</code></pre><p>top：展示Linux进程信息</p><pre><code> -d: 指定延迟时长，单位是秒-b: 批模式-n #：在批模式下，共显示多少批top命令：https://www.cnblogs.com/niuben/p/12017242.html    常用命令：    M: 根据驻留内存大小进行排序    P：根据CPU使用百分比进行排序    T: 根据累计时间进行排序        l: 是否显示平均负载和启动时间    t: 是否显示进程和CPU状态相关信息    m: 是否显示内存相关信息        c: 是否显示完整的命令行信息    q: 退出top    k: 终止某个进程</code></pre><p>vmstat:系统状态查看命令</p><pre><code>vmstat n m：该命令是每n秒统计一次系统资源，共统计m次</code></pre><p><a href="https://www.linuxprobe.com/linux-vmstat-explain.html">https://www.linuxprobe.com/linux-vmstat-explain.html</a></p><h2 id="Linux进程间通信"><a href="#Linux进程间通信" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h2><p>通信方式：</p><ul><li>共享内存</li><li>信号: Signal</li><li>Semaphore</li></ul><p>kill命令：向进程发送信号  </p><p>重要的信号：</p><ul><li>1：SIGHUP: 让一个进程不用重启，就可以重读其配置文件，并让新的配置信息生效；</li><li>2: SIGINT：Ctrl+c: 中断一个进程</li><li>9: SIGKILL：杀死一个进程</li><li>15: SIGTERM：终止一个进程, 默认信号.中断进程时首先用-15，以便于其能够预先清理临时文件和释放资源。-9作为最后手段，应对哪些失控的进程</li></ul><p>kill使用：</p><pre><code>使用信号号码：kill -1 pid使用信号名称：kill -SIGKILL pid使用信号名称简写：kill -KILL pid</code></pre><p>killall COMMAND：杀死指定名字的所有进程</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>调整nice值：</p><pre><code>调整已经启动的进程的nice值：renice NI PID在启动时指定nice值：nice -n NI COMMAND</code></pre><p>前台作业：占据了命令提示符<br>后台作业：启动之后，释放命令提示符，后续的操作在后台完成  </p><p>前台–&gt;后台：</p><pre><code>Ctrl+z: 把正在前台的作业送往后台（调往后台的进程会中断并停止运行）COMMAND &amp;：让命令在后台执行（调往后台的进程会继续执行）</code></pre><p>jobs: 查看后台的所有作业</p><pre><code>作业号，不同于进程号    +：命令将默认操作的作业    -：命令将第二个默认操作的作业[demo@localhost ~]$ jobs[1]+  Stopped                 tar -zcvf etc.tar.gz /etc/*</code></pre><p>bg: 让后台的停止作业继续运行（我在CentOS7中使用该命令和感觉有问题）  </p><pre><code>bg [[%]JOBID]</code></pre><p>fg: 将后台的作业调回前台</p><pre><code>fg [[%]JOBID]</code></pre><p>kill %JOBID: 终止某作业</p><p>&#x2F;proc目录下的每个数字文件夹都代表着相应的进程<br>&#x2F;proc&#x2F;meminfo文件中是内存的相应信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程基础&quot;&gt;&lt;a href=&quot;#进程基础&quot; class=&quot;headerlink&quot; title=&quot;进程基础&quot;&gt;&lt;/a&gt;进程基础&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;进程也被叫做运行中的程序。当我们安装完软件之后，只是将软件文件保存在了硬盘中。我们运行软件，则会生</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="进程" scheme="http://example.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="http://example.com/2022/11/27/combute-basic/"/>
    <id>http://example.com/2022/11/27/combute-basic/</id>
    <published>2022-11-27T13:25:06.024Z</published>
    <updated>2022-11-27T13:25:06.024Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。</p></div><h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p>一台计算机由硬件、操作系统、程序组成。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9a0b832f9f9e5a95d12a836ab6d53630?method=download&shareKey=c00765b3eaaae0cc10aa16760a4ea955" alt="image"></p><p>硬件是计算机的基础，计算机的硬件组成可以分为运算器、控制器、存储器、输入&#x2F;输出设备。其中运算器和控制器是构成CPU的主要部分。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB760447eef5a97f121df438b75fc68075?method=download&shareKey=52b7a07d9bf375629854264a447c7701" alt="image"> </p><p>各元件之间的逻辑连接关系如下图所示。各元件之间通过地址线、数据线和控制信号线组成的本地总线链接。目前采用总线复用技术让地址、数据和控制信号使用同一条线路。早期的32位CPU中，其地址线和数据线分别都是32位，因此地址寻址空间范围为2的32次方字节，即从0到4G。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe1436f00078189da4932a78923a7936d?method=download&shareKey=e149a2a88f09bcd5958ce514327a5d64" alt="image"></p><p>早期系统通过两个芯片组进行各元件的连接，分别是： </p><ul><li>北桥：负责链接CPU、内存、显卡等高速设备  </li><li>南桥：负责链接硬盘、网卡、USB等低速设备</li></ul><p>目前北桥已经被整合到了CPU里面，下图为PRO-SW-W480-ACE主板说明图</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB09bda74bccf0f8982f80819324ce11e4?method=download&shareKey=300ea9f175b5eced9beef2872360c0d4" alt="image"></p><h2 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU由数十亿个微型晶体管构成。它的工作可以分为三个关键阶段：CPU从系统的主存中提取指令、然后解码该指令的实际内容、然后再由CPU的相关部分执行该指令。CPU内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连接。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5eeafe804430692ad0e9eead5a1a983?method=download&shareKey=687699edd636019aa7f7d2be4f2605db" alt="image">  </p><ul><li><strong>时    钟</strong>：负责发出CPU开始计时的时钟信号。</li><li><strong>运算器</strong>：负责运算从内存中读入寄存器的数据。 </li><li><strong>寄存器</strong>：可以看作内存的一种，用来暂存指令、数据和地址。  </li><li><strong>控制器</strong>：负责把内存上的指令，数据读入寄存器，并根据指令的结果控制计算机。</li></ul><p>根据功能的不同，可以将寄存器划分为下面这几类。 </p><table><thead><tr><th align="center">种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">累加寄存器</td><td align="center">存储运行的数据和运算后的数据</td></tr><tr><td align="center">标志寄存器</td><td align="center">用于反映处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td align="center">程序计数器</td><td align="center">用于存放下一条指令所在单元的地址的地方</td></tr><tr><td align="center">基址寄存器</td><td align="center">存储数据内存的起始位置</td></tr><tr><td align="center">变址寄存器</td><td align="center">存储基址寄存器的相对位置</td></tr><tr><td align="center">通用寄存器</td><td align="center">存储任意数据</td></tr><tr><td align="center">指令寄存器</td><td align="center">储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td align="center">栈寄存器</td><td align="center">存储栈区域的起始位置</td></tr></tbody></table><p>其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其它寄存器一般有多个。在内存中的存储通过地址编号来表示，而寄存器的种类则通过名字来区分。</p><p>至于CPU的指令集，那就是Intel的架构师们的工作。总之，CPU认识这些指令，并且能执行运算。这些指令我们称之为机器代码。机器代码由二进制的01字符串构成不利于人们阅读，因此人们在机器代码的基础上开发了一套汇编代码。汇编代码只有转换为本地代码才能运行。  </p><p>CPU 采用了一系列的措施加快指令的执行过程：</p><blockquote><p>流水线：有电子厂打工经历的读者肯定很熟悉这个流水线模式。CPU的流水线工作方式和工业生产上的流水线概念一样。就是将一个指令的执行过程也分解为多个步骤，CPU中的每个电路只执行其中一个步骤，这样前赴后继加快执行速度。CPU中多个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成几个步骤后再由这些电路单元分别执行。在执行过程中，指令源源不断的送往CPU。让每个电路单元都不闲着，这样就大大的加快了执行速度。  </p></blockquote><blockquote><p>超线程：CPU在进行线程切换的时候，要执行 切换各种寄存器状态等一些操作。把第一个线程的各种寄存器状态写回缓存中保存，然后把第二个线程的相关内容送到各种寄存器上。该过程必不可少，否则待会再将第一个线程切换回来时，不知道该线程的各个状态， 那还怎么接着继续执行呢？也正因为如此，所以这个过程比较慢，大概需要几万个时钟周期。所以后来做了这样的设计，把每个寄存器等都多做一个，就是多做一组寄存器(也包括一些其他相关电路等),CPU在执行A线程时，使用的第一组寄存器，切换到B线程，直接使用第二组寄存器，然后再切换A线程时，再使用第一组寄存器。，CPU就不用再傻傻的等着寄存器值的切换，线程切换只需要几个时钟周期就够了。对于普通的执行多任务的计算机，CPU线程切换是个非常频繁的操作，所以使用该技术就会节省大量的时钟周期。也就是相当于加快了CPU的执行速度。这就是CPU宣传参数中所谓的四核八线程的由来，其实就是超线程技术。(每个核多做一组寄存器等电路固然会占用宝贵的空间，但是它带来的优点远远大于缺点)。 </p></blockquote><blockquote><p>超标量技术: CPU可以在每个时钟周期内执行多个操作,可以实行指令的并行运算。在下面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出来并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。  </p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEBca6d3f2ca384de5d257b260ead71d115?method=download&shareKey=a7e4eea3d1346b04d1eada1e71e3b1bf" alt="image">  </p><blockquote><p>乱序执行: 我们认为程序都是顺序执行的。但是在CPU层面上，指令的执行顺序并不一定与它们在机器级程序(汇编)中的顺序一样。比如 a &#x3D; b+c; d++;这两个语句 不按照顺序执行也不会影响最终结果。当然这只是在CPU执行指令的层面，在程序员们看来，依旧认为程序是顺序执行的。</p></blockquote><blockquote><p>多核芯片：在芯片上有效地承载了四个微型芯片，每个微型芯片都有自己独立的CPU。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0b07646c4ecb73a0add4e1b5a2a9dfff?method=download&shareKey=7f5a08db7f8b74d0587553a87fafcb62" alt="image">  </p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是一种随机存储器（RAM），表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3eba4f99e53218fdec72fec4e08d9090?method=download&shareKey=f3f97c1a5885c0788caa1c94c0379427" alt="image">  </p><p>内存是编址的，编址的单位是字节（不是比特）。为了便于理解，我们把内存模型映射成为我们现实世界的模型。在现实世界中，内存的模型很像我们生活中的楼房。在这个楼房中，1层可以存储一个字节的数据，楼层号就是地址。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8993750ef7e3c66bac2868347fa8c680?method=download&shareKey=818ed6e9b52b16bec7a2247ba9780d24" alt="image">  </p><p>内存的内部是由各种IC电路（集成电路）组成的。内存IC是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的IC引脚来进行数据的读写。下面是一个虚拟的IC引脚示意图。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e9c34cbbec8776b666c35b72bb3b0bc?method=download&shareKey=c943f31ea062208c46c05dd12b6979de" alt="image">  </p><p>图中VCC和GND表示电源，A0-A9是地址信号的引脚，D0-D7表示的是数据信号、RD和WR都是控制信号。将电源链接到VCC和GND后，就可以对其它引脚传递0和1的信号，大多数情况下，+5V表示1,0V表示0。</p><p>我们都知道内存是用来存储数据，那么这个内存IC中能存储多少数据呢？D0-D7表示的是数据信号，也就是说，一次可以输入输出8bit &#x3D; 1byte的数据。A0~A9是地址信号共十个，表示可以指定00000 00000 - 11111 11111共2的10次方&#x3D;1024个地址。每个地址都会存放1byte的数据，因此我们可以得出内存IC的容量就是1KB。 </p><p>如果我们使用的是512MB的内存，这就相当于是512000（512*1000）个内存IC。当然，一台计算机不太可能有这么多个内存IC，然而，通常情况下，一个内存IC会有更多的引脚，也就能存储更多的数据。</p><p>内存IC读写过程如下：  </p><ul><li>写入数据：首先给VCC接通+5V的电源，给GND接通0V的电源，使用A0-A9来指定数据的存储场所，然后再把数据的值输入给D0-D7的数据信号，并把WR（write）的值置为1，执行完这些操作后，即可以向内存IC写入数据。</li><li>读入数据：只需要通过A0-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB81497d419eab65105d73ab9cd72f29b2?method=download&shareKey=86c4562d73c7ae4724b901546c120882" alt="image">  </p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘和内存都具有存储功能，它们都是存储设备。内存是一种高速、造价昂贵的存储设备，通过电流来实现存储。而磁盘则是速度较慢、造价低廉的存储设备，通过磁记录技术实现存储。磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，他们以5400rpm、7200rpm、10800rpm或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片33转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂的位置上的所有磁道合并起来，组成了一个柱面。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1ce7db34d73ec40ecb6ea85135bc6f18?method=download&shareKey=24f1372be02346ec060fc1de5f77a9e5" alt="image">  </p><blockquote><p>注意：固态硬盘不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中。与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p></blockquote><h3 id="输入-x2F-输出设备和设备驱动程序"><a href="#输入-x2F-输出设备和设备驱动程序" class="headerlink" title="输入&#x2F;输出设备和设备驱动程序"></a>输入&#x2F;输出设备和设备驱动程序</h3><p>I&#x2F;O设备一般包括两个部分：设备控制器和设备本身。任何一个硬件设备内部的电路可能跟CPU内部的电路都不一致。因此控制器负责将外部设备的信号转换成CPU总线上能理解的信号以及控制外部设备的传输速率、校验等功能。即I&#x2F;O控制器能够接受操作系统的指令，控制设备。I&#x2F;O控制器中也有用于临时保存输入输出数据的内存，这个内存我们称之为I&#x2F;O内存。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb7382c303e9917c95e83b6edbe2cdd4d?method=download&shareKey=dc3a6ac1c609075617bffd1cc30123a6" alt="image">  </p><h2 id="计算机概念"><a href="#计算机概念" class="headerlink" title="计算机概念"></a>计算机概念</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>计算机的运行离不开程序，程序由指令和数据两部分组成。计算机运行过程中CPU所使用的指令和数据都是来自于主内存。不论是软件程序还是数据，都必须要读入主内存后CPU才能利用。由于CPU的计算速度远大于从内存操作数据的速度，直观表现就是程序的性能在极大程度上受到内存访问次数的影响，内存访问次数越多，性能越差，所以才引入缓存从而减少cpu访问内存的次数。CPU中的缓存分为三层。一二级缓存私有，三级缓存共享。一级缓存分为数据缓存和指令缓存。缓存之所以可以减少CPU访问内存的次数是由于程序的局部性原理：</p><ul><li><p>时间局部性：被引用过一次的存储器位置中的内容在未来会被多次引用  </p></li><li><p>空间局部性：如果一个存储器位置的内容被引用，那么它附近的位置也很大概率被引用。</p></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbe7ae989c55df12e9e5c9016b7414bd6?method=download&shareKey=c3a7b4196623b3fed8259fab738a9928" alt="image"></p><h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>计算机接了这么多的外部设备，CPU如何区分不同的I&#x2F;O设备呢？类比计算机区分和互联网通信的各个进程的方法，计算机区分不同的和外部通信的进程靠的是套接字，也就是ip地址+端口号。这里cpu区分不同I&#x2F;O设备靠的也是端口号，称为I&#x2F;O端口，在一台计算机上I&#x2F;O端口的数目也是65535个。任何一个硬件设备通过IO总线接入计算机的时，它必须一开机就申请注册一批连续的I&#x2F;O端口。</p><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>为了更充分的使用CPU的运算能力，计算机引入了多任务的概念。多任务的实现依赖于CPU的时间切片以及虚拟内存地址两项技术。CPU的时间切片可以理解为一项任务运行5ms之后切换其它任务执行，即通过时间片轮转的方法使不同的程序并发执行。虚拟内存地址：由进程的虚地址构成的地址空间。我的理解是CPU中每一个进程的内存地址都是0-某个值（比如1024），根据不同的进程映射到不同的内存地址中。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>当计算机上运行多个任务，这时从键盘上输入数据或者移动鼠标时计算机是如何快速响应的？这就依赖于中断机制。程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断;</p><p>I&#x2F;O设备和CPU之间的信息交流通过中断机制来实现。中断是用来暂停当前正在运行的程序，然后跳转到其他程序运行的必要机制。  </p><p>每个设备发送信号通知CPU来查看，CPU怎么得知是哪个设备的信号呢？可能你会想到通过I&#x2F;O端口来识别，但I&#x2F;O端口是实现数据交互而不是识别信号交互的。中断控制器就登场了。</p><p>中断控制器（Interrupt Controller）：CPU外置芯片，接收中断信号。当某个外部设备（例如网卡卡）传来信号，CPU中断当前操作，将此信号接收至内存中。中断控制器上连接着中断线，每根线代表一个设备（不是固定的设备），用来区分外部设备，线路是可以复用的。</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>直接存储器访问（DMA）: 它可以控制内存和某些控制器之间的数据传输，而无需CPU的干预。比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B不经过CPU的处理。由CPU在内存中划好某次传输数据所需空间，并授权某根线路给DMA使用。否则，CPU 需要从来源把每一片段的数据复制到暂存器，之后把它们再次写回到新的进程空间。在这个时间中，CPU 对于其他的工作来说就无法使用。</p><p>DMA依赖于CPU外置的DMA控制器芯片。在实现DMA传输时，是由DMA控制器直接掌管总线。因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器。而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程必须经过DMA请求、DMA响应、DMA传输、DMA结束4个步骤。</p><p>在物理内存当中，最低地址段中的空间就预留给了DMA。一般大小为16M。在DMA最前面还有1M使用的空间是留给BIOS。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB672d57b20ba18a9f89a4467c41770579?method=download&shareKey=8b548b2cebd4abe92784a69245f7a0ad" alt="image">  </p><h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><p>现在CPU都是多核的，而在服务器领域使用多颗CPU是正常的。在SMP（对称多处理器：一块主板上有多个CPU插槽）多CPU架构中，每个插槽称为一个socket。当多个CPU访问同一个内存，传统上多CPU对于内存的访问是总线方式。总线方式就会存在资源争用和临界区问题，而且如果不断的增加CPU数量，内存的争用会愈演愈烈。这就体现在4核CPU的跑分性能达不到2核CPU的2倍，甚至1.5倍都没有。理论上来说这种方式实现12core以上的CPU已经没有太大的意义。</p><p>为了防止多颗CPU访问内存出现资源争用，可以为每个CPU分配一个专用内存并且配有专用控制器。由于内存属于系统级别，内核加载时有可能把数据加载到不同CPU的专用内存上。同时每个CPU都有自己的进程队列，这些队列会不断被内核进行平衡（rebalancing），确保资源平均利用。这样就有可能会导致1号CPU需要到2号CPU的专用内存上读写数据，这种现象称为非一致性内存访问（NUMA）。如下图，CPU 0-3访问自己的内存需要1、2、3步骤（3个时钟周期），而访问CPU 4-7的内存需要1、1a、2、3步骤，其中1a就需要消耗3个时钟周期。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe521c3b43a42aca7e0cc418a043987de?method=download&shareKey=9162438460f30dcd3d07f9640f50dd5c" alt="image"></p><p>在企业中，NUMA问题是很常见的。为了避免内存间交叉访问导致性能下降，可以禁止内核进行平衡。对于比较繁忙的、需要经常执行的批处理服务进程可以采取CPU绑定策略。</p><p>Intel的NUMA解决方案：放弃总线的访问方式，将CPU划分到多个Node中。每个node有自己独立的内存空间。各个node之间通过高速互联通讯，通讯通道被称为QuickPath Interconnect即QPI。</p><h3 id="多信道设计"><a href="#多信道设计" class="headerlink" title="多信道设计"></a>多信道设计</h3><p>由于所有的数据都必须要存放在主内存，所以主内存的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达64比特。为了加大这个宽度，芯片组厂商就将两个主内存汇整在一起。如果一支内存可达64比特，两支内存就可以达到128比特了。这就是双信道的设计理念。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>操作系统是硬件层上的一层软件，它提供系统调用并屏蔽了硬件层面上的差异。操作系统负责整个计算机的内存管理、硬件管理、文件管理以及应用管理。</p><p>有时我们将操作系统也称为虚拟机。因为我们只有一块cpu芯片(可能是多核心的)，只有一块内存，只有一个鼠标，只有一个键盘……。每个进程都想独占这一整套资源。cpu可以通过时间片轮转的方式将一个cpu芯片虚拟成多个cpu运行。内存的虚拟通过分页机制和虚拟地址空间。现在已经把计算机系统中最重要的两个部件CPU和内存虚拟出来了。剩下的那些I&#x2F;O设备如何虚拟呢？其实IO虚拟不需要专门去做，因为当前哪个进程获得了系统使用权，I&#x2F;O设备就交给该进程。</p><h3 id="CPU指令模式"><a href="#CPU指令模式" class="headerlink" title="CPU指令模式"></a>CPU指令模式</h3><p>有了操作系统之后。在某一时刻，要么是内核进程（操作系统核心）在上面运行，要么是用户空间进程在上面运行。内核在cpu上运行时称为内核模式，进程在cpu上运行时称为用户模式。在内存中内核占据的那段内存空间称为内核空间，用户进程占据的空间叫用户空间。用户模式时，进程是不能直接控制硬件的。这是因为在cpu内部，cpu制造商将cpu能运行的指令划分为４层(仅对x86架构而言)，ring0，ring1，ring2，ring3。由于历史原因，ring1和ring2并没有使用，linux只用了ring0和ring3。ring0称为内核模式，也称为特权指令模式，可以直接操控硬件。ring3是用户模式，可以执行一般指令。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>内存是易失性存储，即断电之后所有数据都会被清空。CPU运行所需的指令和数据都要从内存中获取。那么计算机是如何启动的呢？</p><p>在计算机主板上有一个ROM芯片（非易失性存储），该芯片存储了BIOS程序。在按下电源键之后系统会自动将BIOS程序加载到内存中然后执行。BIOS程序主要负责确定硬件是否正常，没有异常的话会根据配置文件（存储在CMOS）中的设备启动顺序查找MBR（主引导记录）。</p><p>MBR会查找活动分区，加载活动分区中的内核代码。然后将控制权转移给内核。接下来就进入操作系统的启动流程。</p><p>目前最新的是UEFI+GPT方式。UEFI可以认为是BIOS的升级版。GPT是MBR的升级版，2T以上的硬盘需要使用gpt。</p><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>设备驱动程序是I&#x2F;O系统的高层与设备控制器之间的通信程序，工作在内核模式。其主要任务：</p><ul><li>再把它转化为具体要求，发送给设备控制器，启动设备去执行。</li><li>反方向，它也将由设备控制器发来的信号，传送给上层软件。</li><li>接收上层软件发来的抽象I&#x2F;O要求（Linux中一切皆文件），如read、write等命令；</li></ul><h3 id="固件和驱动"><a href="#固件和驱动" class="headerlink" title="固件和驱动"></a>固件和驱动</h3><p>固件是直接写入ROM中的程序，比如BIOS。它直接和硬件打交道，指导硬件怎么干活。驱动负责操作系统和设备控制器之间的通信，告诉硬件要干什么。驱动一般运行在操作系统上，由操作系统进行管理。而固件往往直接”固定”在硬件上，直接控制硬件；</p><ul><li><p>eg1：利用打印机打印东西时：</p><ul><li>驱动的作用就是告诉打印机，要打印什么。</li><li>固件则告诉打印机，要怎么执行操作(把纸弄上打印区，然后喷墨，从哪里出纸等)。</li></ul></li><li><p>eg2. BIOS即为主板上的固件，功能 ：上电 - 进入BIOS - 自检(检查设备是否正常等) - 初始化各个模块(内存以及加载其他必要的固件等) - 转移控制到系统启动程序。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>本文简单介绍了计算机组成、硬件组成（CPU、内存、硬盘、IO设备）、连接方式、计算机基础概念（IO端口、中断、DMA、SMP、多通道）、计算机如何启动、驱动和固件等相关内容。在写作本文的过程中发现我脑子里有东西，但是什么都写不出来。上次面试时面试官问我计算机的组成？我只答出CPU、内存、硬盘、IO设备，CPU从内存中获取指令和数据。好尴尬！！！！真的只能说是一听就会，一说就废。</p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 简单介绍一下计算机的组成、计算机硬件的连接方式、多任务、计算机如何区分IO设备、CPU如何和IO设备之间交互、DMA机制、SMP架构、多通道、驱动的概念？</p><p>3. 计算机如何启动?</p><p>4. 驱动和固件的区别？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. B站马哥Linux运维课程中的操作系统基础  </p> <p>2. 内存--通俗理解：<https://blog.csdn.net/youhuakongzhi/article/details/109039652>  </p> <p>3. 程序员必知的硬核知识大全  </p> <p>4. 认识操作系统</p> <p>5. 图解操作系统</p> <p>6. Linux内核完全注释</p> <p>5. 固件和驱动区别 [https://blog.csdn.net/qq_36779888/article/details/108681805](https://blog.csdn.net/qq_36779888/article/details/108681805)</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;计算机组成&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="硬件" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络基础</title>
    <link href="http://example.com/2022/11/27/Linux-network/"/>
    <id>http://example.com/2022/11/27/Linux-network/</id>
    <published>2022-11-27T13:24:30.781Z</published>
    <updated>2022-11-27T13:24:30.781Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>网络功能是计算机之间通信的基础，也是一个操作系统的重要组成部分。本文主要介绍Linux网络相关配置。</P>  </div><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p>计算机网络实现了计算机之间的通信，我们可以通过两个层面来了解计算机网络。第一层面是物理层面，即计算机之间的连接线和设备；第二层面是计算机通信所采用的协议。我们首先了解一下计算机网络的物理层面。为了实现计算机之间的通信，我们首先通过线缆将各个计算机连接起来。为了在网络中识别各个计算机，我们给每个计算机分配一个MAC地址（位于网卡上）用于标识该计算机。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9f8be84ece7c84b15d27b8403b926f7?method=download&shareKey=cc97eec71b385792e190e815117b6031" alt="image"></p><p>由于一根线上在某一时刻只能传输某一个计算机的信息，否则会造成信号相互冲突。为了避免以上情况，引入了载波监听多路访问&#x2F;冲突检测机制。该机制是当计算机发送信息前，先监听线路中是否正在发送信息，如果没有则发送，否则等待。同时，在计算机发送信号之后，仍需继续侦听信道，当检测到冲突后马上迅速取消信息的传输并等待。</p><p>随着一根线上接入的计算机越来越多，发送信息时计算机冲突等待的时间也就越来越长。为此，我们可以将一个网络分成多个网络，网络之间使用网桥连接。网桥是一个智能设备，内部维护了一张MAC地址表。当A向D发送信息时，网桥左面的接口接收到信息查看MAC表显示D在来源接口所在的网络，网桥则会忽略该信息。网桥内部的MAC表可以人为指定，也可以自己学习。自己学习是根据接受信息的来源地址进行学习，如果在MAC表中查找目标地址不存在则会向网桥所有端口转发。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1bd50147127bd04dc2814f97780144be?method=download&shareKey=3bf691f9fc190026d0cc77e3f52d6926" alt="image"></p><p>随着不断发展，交换机取代了网桥。目前，我们将计算机直接连接到交换机的端口上，交换机内部也有一个MAC地址表。而且目前的网线一般都是全双工的（即内部包含两条线，一条发送信息，一条接受信息）。在计算机进行通信时，计算机一般会发送广播询问目标的地址。但是交换机并不能隔离广播，路由器的作用便是隔离广播。路由器的存在虽然隔离了广播，但是也造成我们无法确定目标主机是否存在。为了解决该问题，我们引入了IPV4地址。在通信时，计算机根据IPV4地址判断目标主机是否和自己在同一网段，如果在同一网段则可以通过交换机直接通信。如果不在同一网段，计算机则将信息发送给路由器，路由器根据路由配置进行转发。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.51wendang.com%2Fpic%2Fc1074616c12f52cc16eef53f%2F5-492-png_6_0_0_162_448_622_372_892.979_1262.879-823-0-0-823.jpg&refer=http%3A%2F%2Fwww.51wendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643791840&t=5377c338817383119402d7b2035b5756" alt="image"></p><p>以上的物理层面保证了计算机可以相互之间发送和接受信息，而协议层面则规定了计算机发送信息的格式。目前的协议层面我们常用的是TCP&#x2F;IP协议。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf00acbc1e730228b2a39f1a697f02ef3?method=download&shareKey=754667e281d8fa53a84cb867ca131c95" alt="image"></p><p>在这些层中，IP层是实现点到点的通信。而传输层是实现进程到进程的通信。</p><p>具体网络协议基础可以查看：<a href="https://www.cnblogs.com/imyalost/p/6086808.html">https://www.cnblogs.com/imyalost/p/6086808.html</a></p><h2 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h2><p>   ethX：代表的是以太网。IP地址虽然配置在网卡上，但是IP地址是属于内核的，即数据可以通过一个网卡采用其它网卡的IP访问计算机。</p><p>   网卡名称定义地址：</p><pre><code>RHEL5: /etc/modprobe.conf          alias RHEL6: /etc/udev/rules.d/70-persistent-net.rules（配置网卡名称和MAC地址）[root@Worker11 ~]# cat /etc/udev/rules.d/70-persistent-net.rules # This file was automatically generated by the /lib/udev/write_net_rules# program, run by the persistent-net-generator.rules rules file.## You can modify it, as long as you keep each rule on a single# line, and change only the value of the NAME= key.        # PCI device 0x8086:0x100f (e1000)SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;00:0c:29:8f:62:94&quot;, ATTR&#123;type&#125;==&quot;1&quot;, KERNEL==&quot;eth*&quot;, NAME=&quot;eth0&quot; </code></pre><h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><pre><code>ifconfig [ethX]     -a: 显示所有接口的配置信息    [root@Worker11 ~]# ifconfig    eth0      Link encap:Ethernet  HWaddr 00:0C:29:8F:62:94（物理地址）                inet addr:192.168.25.11（IP地址）  Bcast:192.168.25.255（广播地址）  Mask:255.255.255.0（子网掩码）              inet6 addr: fe80::20c:29ff:fe8f:6294/64 Scope:Link              UP（启用） BROADCAST（广播地址有效） RUNNING（动作） MULTICAST（多播地址有效）  MTU:1500  Metric:1              RX packets:464 errors:0 dropped:0 overruns:0 frame:0（接受数据）              TX packets:106 errors:0 dropped:0 overruns:0 carrier:0（发送数据）              collisions:0 txqueuelen:1000               RX bytes:36689 (35.8 KiB)  TX bytes:13139 (12.8 KiB)        lo        Link encap:Local Loopback                inet addr:127.0.0.1  Mask:255.0.0.0              inet6 addr: ::1/128 Scope:Host              UP LOOPBACK RUNNING  MTU:65536  Metric:1              RX packets:0 errors:0 dropped:0 overruns:0 frame:0              TX packets:0 errors:0 dropped:0 overruns:0 carrier:0              collisions:0 txqueuelen:0               RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)ifconfig ethX IP/MASK [up|down]     配置的地址立即生效，但重启网络服务或主机，都会失效；    ifconfig eth0 192.168.20.12/24 修改网卡地址，即时生效    ifconfig eth0 down：关闭eth0网卡    ifconfig eth0 up：开启eth0网卡    </code></pre><h3 id="重启网络服务："><a href="#重启网络服务：" class="headerlink" title="重启网络服务："></a>重启网络服务：</h3><p>RHEL5:&#x2F;etc&#x2F;init.d&#x2F;network {start|stop|restart|status}</p><p>RHEL6:  &#x2F;etc&#x2F;init.d&#x2F;NetworkManager {start|stop|restart|status}<br>        service network {start|stop|restart|status}（我一般使用这个）</p><p>RHEL7:  systemctl {start|stop|restart|status} network</p><h3 id="路由："><a href="#路由：" class="headerlink" title="路由："></a>路由：</h3><p>查看：  </p><pre><code>route -n: 以数字方式显示各主机或端口等相关信息，否则可能会显示对应IP的主机名[demo@localhost rules.d]$ route -nKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0</code></pre><p>网关：   </p><pre><code>route     add: 添加        -host: 主机路由        -net：网络路由        -net 0.0.0.0    route add -net|-host DEST gw NEXTHOP    route add default gw NEXTHOP    route add -net 10.0.1.0/24 gw 192.168.100.6    [root@localhost ~]# route add -net 192.168.20.0/24 gw 192.168.122.254    del：删除        -host        -net                 route del -net 10.0.0.0/8         route del -net 0.0.0.0        route del default所做出的改动重启网络服务或主机后失效；</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>网络接口配置文件：  </p><p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-INTERFACE_NAME</p><pre><code>DEVICE=: 关联的设备名称，要与文件名的后半部“INTERFACE_NAME”保持一致; BOOTPROTO=&#123;static|none|dhcp|bootp&#125;: 引导协议；要使用静态地址，使用static或none；dhcp表示使用DHCP服务器获取地址；IPADDR=: IP地址NETMASK=：子网掩码GATEWAY=：设定默认网关；ONBOOT=：开机时是否自动激活此网络接口；HWADDR=： 硬件地址，要与硬件中的地址保持一致；可省；USERCTL=&#123;yes|no&#125;: 是否允许普通用户控制此接口；PEERDNS=&#123;yes|no&#125;: 是否在BOOTPROTO为dhcp时接受由DHCP服务器指定的DNS地址；不会立即生效，但重启网络服务或主机都会生效；</code></pre><p>路由：</p><p>&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;route-ethX</p><pre><code>添加格式一：DESTvia NEXTHOP192.168.20.0/24 via 192.168.20.254添加格式二：ADDRESS0=NETMASK0=GATEWAY0=</code></pre><p>DNS服务器指定方法只有一种：</p><pre><code>/etc/resolv.confnameserver DNS_IP_1nameserver DNS_IP_2</code></pre><p>指定本地解析：</p><pre><code>/etc/hosts主机IP            主机名      主机别名172.16.0.1www.magedu.comwwwDNS--&gt;/etc/hosts--&gt;DNS</code></pre><p>配置主机名：</p><pre><code>hostname HOSTNAME # 立即生效，但不是永久有效；hostnamectl set-hostname hostname # CentOS 7，同时会修改/etc/hosts# 配置文件（CentOS 6修改，CentOS7及其以上方式已被弃用）/etc/sysconfig/networkHOSTNAME=# 配置文件（CentOS 7修改）/etc/hosts</code></pre><p>RHEL5：（图形化界面设置）</p><pre><code>setup: system-config-network-tuisystem-config-network-gui</code></pre><h3 id="IP管理新命令"><a href="#IP管理新命令" class="headerlink" title="IP管理新命令"></a>IP管理新命令</h3><p>iproute2</p><pre><code>ip    link: 网络接口属性    addr: 协议地址    route: 路由link    show        ip -s link show    set        ip link set DEV &#123;up|down&#125;        addr    add        ip addr add ADDRESS dev DEV    del        ip addr del ADDRESS dev DEV    show        ip addr show dev DEV to PREFIX（显示指定范围内的网卡信息）    flush        ip addr flush dev DEV to PREFIX（配置网卡地址删除）route:     ip route add to 10.0.1.0/24 dev eth1 via 192.168.100.6        add, change, show, flush, replace            显示网卡属性[root@localhost network-scripts]# ip -s link show1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    RX: bytes  packets  errors  dropped overrun mcast       107024     1248     0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns     107024     1248     0       0       0       0       2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    RX: bytes  packets  errors  dropped overrun mcast       0          0        0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns     23168      144      0       0       0       0   关闭网卡[root@localhost network-scripts]# ip link set ens33 down查看网卡地址[root@localhost network-scripts]# ip -s addr show dev ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever    RX: bytes  packets  errors  dropped overrun mcast       0          0        0       0       0       0           TX: bytes  packets  errors  dropped carrier collsns     49909      306      0       0       0       0       显示指定IP地址范围内的网卡信息[root@localhost network-scripts]# ip addr show dev ens33  to 10/8[root@localhost network-scripts]# ip addr show dev ens33  to 192.168.120.0/242: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever删除指定范围内的网卡地址[root@localhost network-scripts]# ip addr show dev ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever    inet 192.168.121.11/24 scope global ens33:1       valid_lft forever preferred_lft forever[root@localhost network-scripts]# ip addr flush dev ens33 to 192.168.121.11/24[root@localhost network-scripts]# ip addr show dev ens332: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 00:0c:29:fe:dd:c9 brd ff:ff:ff:ff:ff:ff    inet 192.168.120.12/24 scope global ens33       valid_lft forever preferred_lft forever添加路由[root@localhost network-scripts]# ip route add to 10.0.1.0/24 dev ens33 via 192.168.120.6[root@localhost network-scripts]# ip route show10.0.1.0/24 via 192.168.120.6 dev ens33 192.168.20.0/24 via 192.168.122.254 dev virbr0 192.168.120.0/24 dev ens33 proto kernel scope link src 192.168.120.12 192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 </code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>一块网卡可以使用多个地址：<br>网络设备可以起别名：</p><p>eth0</p><pre><code>ethX:X, eth0:0, eth0:1, ...    </code></pre><p>配置方法：</p><pre><code>第一种方法：ifconfig ethX:X IP/NETMASKifconfig eth0:0 172.16.200.33/16第二种方法：ip    eth1, 添加个地址192.168.100.1    ip addr add 192.168.100.1/24 dev eth1 label eth1:0第三种方法,上面的方法主机重启会消失/etc/sysconfig/network-scripts/ifcfg-ethX:XDEVICE=ethX:X非主要地址不能使用DHCP动态获取; </code></pre><p>监听端口：  </p><p>netstat命令：</p><pre><code>-r: 显示路由表-n: 以数字方式显示-a：显示所有的网络连接和监听接口-t: 建立的tcp连接-u: 显示udp连接-l: 显示监听状态的连接-p: 显示监听指定的套接字的进程的进程号及进程名[root@localhost html]# netstat -anptlActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      1175/cupsd          tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      1382/master         tcp        0      0 127.0.0.1:44321         0.0.0.0:*               LISTEN      19272/pmcd          tcp        0      0 127.0.0.1:4330          0.0.0.0:*               LISTEN      34102/pmlogger  </code></pre><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 马哥Linux运维课程</p> </div>    ]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;网络功能是计算机之间通信的基础，也是一个操作系统的重要组成部分。本文主要介绍Linux网络相关配置。&lt;/P&gt;  
&lt;/div&gt;


&lt;h2 id=&quot;网络基础&quot;&gt;&lt;a href=&quot;#网络基础&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="network" scheme="http://example.com/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>Linux软件包管理</title>
    <link href="http://example.com/2022/11/27/Linux-software/"/>
    <id>http://example.com/2022/11/27/Linux-software/</id>
    <published>2022-11-27T13:23:18.034Z</published>
    <updated>2022-11-27T13:23:18.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序介绍"><a href="#程序介绍" class="headerlink" title="程序介绍"></a>程序介绍</h2><blockquote><p>我们将语言分为两种。一种是编译器语言，另一种是解释性语言。编译语言以C语言为例，需要将源代码–&gt;（编译）二进制格式才能在机器上运行。编译的过程大致如下：源代码–&gt;编译–&gt;链接–&gt;运行。其中链接分为两种：一种是静态链接，另一种是动态链接。静态链接是由链接器在链接时将库的内容加入到可执行程序中的做法。动态链接则是在第一次访问库时将库加载到内存中，之后所有的程序在需要时都可以直接访问该库。解释性语言是边读取边翻译的过程，脚本便是一种解释性语言。  </p></blockquote><p>程序：指令+数据</p><pre><code>指令：芯片    CPU: 普通指令，特权指令    指令集注：不同CPU的指令集是不相同的，所以在一些机器上编译的程序不能在另一些机器上直接使用。</code></pre><p>程序的组成：</p><ul><li>二进制程序</li><li>库</li><li>配置文件</li><li>帮助文件</li></ul><h2 id="程序介绍-1"><a href="#程序介绍-1" class="headerlink" title="程序介绍"></a>程序介绍</h2><p>linux文件夹介绍：</p><pre><code>/boot/etc/usr/var/dev/lib/tmp/bin/sbin/proc/sys/mnt/media/home/root/misc/opt/srv具体分析：/etc, /bin, /sbin, /lib    系统启动就需要用到的程序，这些目录不能挂载额外的分区，必须在根文件系统的分区上    /usr/    etc    bin    sbin    lib    操作系统核心功能，可以单独分区。该程序下的配置文件一般也在/etc下/usr/share/man：上面两种程序的帮助文档位置/usr/local    bin    sbin    lib    etc    man    第三方程序，可以单独分区/opt：一些比较老的第三方程序的默认存放路径，可以单独分区/proc/sys    伪文件系统，不能单独分区，默认为空；/dev: 设备，不能单独分区；   udev机制：/home:建议单独分区，防止操作系统重装等操作时用户数据丢失。/root: 不能单独分区/var：建议单独分区/boot：内核，initrd(initramfs)： 建议单独分区     内核：          操作系统加载顺序POST--&gt;BIOS(HD)--&gt;(MBR)bootloader(该模块应该能理解文件系统结构，ext2, ext3, xfs)--&gt;内核     bootloader根据活动分区直接去定位内核位置，然后加载内核。中间和根目录没有关系。操作系统启动后，然后寻找根，并将boot目录挂载到根下。     建议给boot单独分区，然后将根目录挂载到LVM分区下。因为LVM是操作系统功能，boot需要在操作系统启动前加载。这样可以在需要时，增大根目录下的空间。</code></pre><h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2><p> 软件包管理器的核心功能</p><ul><li>制作软件包；  </li><li>安装、卸载、升级、查询、校验；</li></ul><p>不同系统上的软件包管理器</p><ul><li>Redhat, SUSE: RPM (PRM is Package Manager)</li><li>Debian: dpt</li></ul><p>依赖关系:  </p><pre><code>依赖关系顾名思义就是A软件需要使用B软件的某些功能。比如X依赖于Y，Y依赖于Z。X--&gt;Y--&gt;Z</code></pre><p>工具分类：</p><ul><li>前端工具（自动处理依赖关系）：yum, apt-get</li><li>后端工具（手动处理依赖关系）：RPM, dpt</li></ul><h2 id="rpm基础"><a href="#rpm基础" class="headerlink" title="rpm基础"></a>rpm基础</h2><p>rpm的主要功能为安装、查询、卸载、升级、校验、数据库的重建、验正数据包等工作；</p><p>rpm包来源：</p><pre><code>二进制格式    rpm包作者下载源程序，编译配置完成后，制作成rpm包。因此rpm包安装后可以直接运行。    bind-9.7.1-1.noarch.rpm    bind-9.7.1-1.ppc.rpm</code></pre><p>rpm包命名格式：</p><pre><code>假设源码格式为：bind-9.7.1.tar.gz包：组成部分（为了防止包过大，可能会将包拆为主包和子包）    主包：        bind-9.7.1-1.el5.i586.rpm    子包：        bind-libs-9.7.1-1.el5.i586.rpm        bind-utils-9.7.1-1.el5.i586.rpm包名格式：    name-version-release.arch.rpm    bind-major.minor.release1-release2.arch.rpm主版本号：重大改进次版本号：某个子功能发生重大变化发行号1：修正了部分bug，调整了一点功能发行号2:rpm包的版本号，上面三个版本号和源码包保持一致。arch：硬件平台bind-9.7.1-1.el5.i586.rpm    9.7.1和源码包一致，分别是主版本号、次版本号、发行号1    1.el5是发行号2,其中1代表rpm的发行版本，el5代表的是redhat 5系统。如果不限制系统el5可以直接省略    i586是arch：该值代表了32位的硬件平台。noarch代表不限制硬件平台。</code></pre><p>查看主机的操作系统和硬件平台版本：</p><pre><code>[demo@localhost dev]$ uname -aLinux localhost.localdomain 3.10.0-1062.el7.x86_64 #1 SMP Wed Aug 7 18:08:02 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux</code></pre><h2 id="rpm命令"><a href="#rpm命令" class="headerlink" title="rpm命令"></a>rpm命令</h2><p>RadHat安装盘中含有很多rpm安装包，可以将安装盘挂载在文件系统中。然后获取rpm安装包。  </p><pre><code> /dev/cdrom：光盘设备命名  </code></pre><p>1、安装</p><pre><code>rpm -i /PATH/TO/PACKAGE_FILE    -h: 以#显示进度；每个#表示2%;     -v: 显示详细过程    -vv: 更详细的过程rpm -ivh /PATH/TO/PACKAGE_FILE    --nodeps: 忽略依赖关系；（可以安装，但安装上软件也不能使用）    --replacepkgs: 重新安装，替换原有安装；    --force: 强行安装，可以实现重装或降级；\\ 安装[root@localhost demo]# rpm -ivh zsh-5.0.2-33.el7.x86_64.rpm warning: zsh-5.0.2-33.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEYPreparing...                          ################################# [100%]Updating / installing...   1:zsh-5.0.2-33.el7                 ################################# [100%]\\ 存在依赖，安装失败[root@localhost demo]# rpm -ivh tomcat-7.0.76-9.el7_6.noarch.rpm warning: tomcat-7.0.76-9.el7_6.noarch.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEYerror: Failed dependencies:    apache-commons-collections is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-daemon is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-dbcp is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-logging is needed by tomcat-0:7.0.76-9.el7_6.noarch    apache-commons-pool is needed by tomcat-0:7.0.76-9.el7_6.noarch    tomcat-lib = 0:7.0.76-9.el7_6 is needed by tomcat-0:7.0.76-9.el7_6.noarch</code></pre><p>2、查询（PACKAGE_NAME可以是安装包的前缀）</p><pre><code>rpm -q PACKAGE_NAME： 查询指定的包是否已经安装rpm -qa : 查询已经安装的所有包rpm -qi PACKAGE_NAME: 查询指定包的说明信息；rpm -ql PACKAGE_NAME: 查询指定包安装后生成的文件列表；rpm -qc PACEAGE_NEME：查询指定包安装的配置文件；rpm -qd PACKAGE_NAME: 查询指定包安装的帮助文件；rpm -q --scripts PACKAGE_NAME: 查询指定包中包含的脚本    rpm -qf /path/to/somefile: 查询指定的文件是由哪个rpm包安装生成的；    如果某rpm包尚未安装，我们需查询其说明信息、安装以后会生成的文件；rpm -qpi /PATH/TO/PACKAGE_FILErpm -qpl示例：[root@localhost demo]# rpm -q zshzsh-5.0.2-33.el7.x86_64注：rpm -q zsh* 这种查询的是当前目录下以zsh开头的文件或文件夹名称是否安装[root@localhost demo]# rpm -q tomcatpackage tomcat is not installed[root@localhost demo]# rpm -qi zsh-5.0.2-33.el7.x86_64Name        : zshVersion     : 5.0.2Release     : 33.el7Architecture: x86_64Install Date: Fri 07 Jan 2022 11:02:48 PM ESTGroup       : System Environment/ShellsSize        : 5856382License     : MITSignature   : RSA/SHA256, Thu 22 Aug 2019 05:45:54 PM EDT, Key ID 24c6a8a7f4a80eb5Source RPM  : zsh-5.0.2-33.el7.src.rpmBuild Date  : Thu 22 Aug 2019 01:13:36 PM EDTBuild Host  : x86-01.bsys.centos.orgRelocations : (not relocatable)Packager    : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor      : CentOSURL         : http://zsh.sourceforge.net/Summary     : Powerful interactive shellDescription :The zsh shell is a command interpreter usable as an interactive loginshell and as a shell script command processor.  Zsh resembles the kshshell (the Korn shell), but includes many enhancements.  Zsh supportscommand line editing, built-in spelling correction, programmablecommand completion, shell functions (with autoloading), a historymechanism, and more.[root@localhost demo]# rpm -ql zsh-5.0.2-33.el7.x86_64/bin/zsh/etc/skel/.zshrc/etc/zlogin/etc/zlogout/etc/zprofile/etc/zshenv/etc/zshrc/usr/lib64/zsh                   ....[root@localhost demo]# rpm -q --scripts zsh-5.0.2-33.el7.x86_64postinstall scriptlet (using /bin/sh):if [ ! -f /etc/shells ] ; then    echo &quot;/bin/zsh&quot; &gt; /etc/shellselse    grep -q &quot;^/bin/zsh$&quot; /etc/shells || echo &quot;/bin/zsh&quot; &gt;&gt; /etc/shellsfiif [ -f /usr/share/info/zsh.info.gz ]; then# This is needed so that --excludedocs works./sbin/install-info /usr/share/info/zsh.info.gz /usr/share/info/dir \  --entry=&quot;* zsh: (zsh).An enhanced bourne shell.&quot;fi:preuninstall scriptlet (using /bin/sh):if [ &quot;$1&quot; = 0 ] ; then    if [ -f /usr/share/info/zsh.info.gz ]; then    # This is needed so that --excludedocs works.    /sbin/install-info --delete /usr/share/info/zsh.info.gz /usr/share/info/dir \      --entry=&quot;* zsh: (zsh).An enhanced bourne shell.&quot;    fifi:postuninstall scriptlet (using /bin/sh):if [ &quot;$1&quot; = 0 ] ; then    if [ -f /etc/shells ] ; then        TmpFile=`/bin/mktemp /tmp/.zshrpmXXXXXX`        grep -v &#39;^/bin/zsh$&#39; /etc/shells &gt; $TmpFile        cp -f $TmpFile /etc/shells        rm -f $TmpFile    fifi[root@localhost bin]# rpm -qf zshzsh-5.0.2-33.el7.x86_64</code></pre><p>3、升级</p><pre><code>rpm -Uvh /PATH/TO/NEW_PACKAGE_FILE: 如果装有老版本的，则升级；否则，则安装；rpm -Fvh /PATH/TO/NEW_PACKAGE_FILE：如果装有老版本的，则升级；否则，退出；    --oldpackage: 降级</code></pre><p>4、卸载</p><pre><code>rpm -e PACKAGE_NAME    --nodeps :忽略依赖关系[root@localhost bin]# rpm -e zsh-5.0.2-33.el7.x86_64</code></pre><p>5、校验  </p><pre><code>rpm -V PACKAGE_NAME[root@localhost demo]# rpm -V zshS.5....T.  c /etc/zshrc注：该选项是校验rpm产生的所有文件是否和原始rpm包中文件的信息是否一致。其中S代表文件大小不一致，M代表对应文件的权限不一致，5代表对应文件的MD5不一致，D代表文件的major和minor号不一致，L代表文件的符号链接内容不一致，U代表文件的owner不一致，G表示文件的Group不一致，T表示文件的修改时间不一致，c只有文件是一个配置文件时才会有此标识。没有变化的文件不列出。</code></pre><p>6、重建数据库</p><pre><code>rpm数据库位置:/var/lib/rpmrpm     --rebuilddb: 重建数据库，一定会重新建立；    --initdb：初始化数据库，没有才建立，有就不用建立；该命令执行过程中要等待一段时间。</code></pre><p>7、检验来源合法性，及软件包完整性； (校验rpm包) </p><p>加密类型：</p><ul><li>对称：加密解密使用同一个密钥</li><li>公钥：一对儿密钥，公钥，私钥；公钥隐含于私钥中，可以提取出来，并公开出去；</li><li>单向：</li></ul><p>红帽的公钥：</p><pre><code># ls /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release注：由于我们目前是直接使用的红帽光盘安装rpm，故我们目前使用红帽的公钥。如果rpm是从其它来源获得，则需使用来源处获取的公钥。</code></pre><p>rpm –import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-redhat-release: 导入密钥文件</p><pre><code>[root@localhost rpm-gpg]# rpm --import RPM-GPG-KEY-CentOS-7</code></pre><p>rpm -K &#x2F;PAPT&#x2F;TO&#x2F;PACKAGE_FILE</p><pre><code>dsa, gpg: 验正来源合法性，也即验正签名；可以使用--nosignature，略过此项sha1, md5: 验正软件包完整性；可以使用--nodigest，略过此项[root@localhost rpm-gpg]# rpm -K /home/demo/zsh-5.0.2-33.el7.x86_64.rpm /home/demo/zsh-5.0.2-33.el7.x86_64.rpm: rsa sha1 (md5) pgp md5 OK</code></pre><blockquote><p>注：ldd &#x2F;PATH&#x2F;TO&#x2F;BINARY_FILE #查看二进制程序依赖的库文件<br>   ldconfig -p # 查看本机已经缓存的所有可用库文件名以及文件路径映射关系</p></blockquote><h2 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h2><p>1、yum仓库中的元数据文件</p><pre><code> primary.xml.gz - 所有RPM包的列表； - 依赖关系； - 每个RPM安装生成的文件列表；  filelists.xml.gz - 当前仓库中所有RPM包的所有文件列表； other.xml.gz - 额外信息，RPM包的修改日志；  repomd.xml - 记录的是上面三个文件的时间戳和校验和；（每次访问yum仓库都会下载该文件，然后和本地的前三个文件进行比较，如果不一致则重新下载上述三个文件。）  comps*.xml:  - RPM包分组信息；（该文件包含了rpm分组，每个分组中包含了必须安装的软件、推荐安装的软件、选择安装的软件）</code></pre><p>2、本机的yum源配置</p><p>配置文件地址：&#x2F;etc&#x2F;yum.repos.d</p><p>如何为yum定义repo文件</p><pre><code>[Repo_ID]（配置标签名）name=Description （名称）baseurl= （地址）    ftp://    http://    file:///enabled=&#123;1|0&#125; （该配置时候可用）gpgcheck=&#123;1|0&#125; （是否校验完整性和来源合法性）gpgkey= （） （来源的公钥）例：[base]name=CentOS-$releasever - Basemirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/         ftp://172.16.0.1/pub/&#123;Server,VT,Cluster,ClusterStorage&#125;gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7</code></pre><p>3、yum命令</p><p>yum [options] [command] [package …]</p><pre><code>-y: 自动回答为yes--nogpgchecklist: 列表     支持glob：例 yum list all zsh*，后面可以跟包名和*号    all:所有的    available：可用的，仓库中有但尚未安装的    installed: 已经安装的    updates: 可用的升级[root@localhost media]# yum list available|head -10Loaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileAvailable Packages389-ds-base.x86_64                      1.3.9.1-10.el7                      demo389-ds-base-libs.x86_64                 1.3.9.1-10.el7                      demoElectricFence.x86_64                    2.2.2-39.el7                        demoImageMagick.x86_64                      6.7.8.9-18.el7                      demoImageMagick-c++.x86_64                  6.7.8.9-18.el7                      demoImageMagick-perl.x86_64                 6.7.8.9-18.el7                      demoLibRaw.x86_64                           0.19.2-1.el7                        demoyum源名：@base该包已经安装，且是从base安装的        @anaconda该报已经安装，且是从操作系统的安装程序anaconda安装的        installed 表示该包是由rpm手动安装的      </code></pre><p>clean: 清理yum下的缓存（目录在&#x2F;var&#x2F;cache&#x2F;yum下）</p><pre><code>[ packages | headers | metadata | dbcache | all ]</code></pre><p>repolist: 显示repo列表及其简要信息</p><pre><code>allenabled： 默认disabled: 禁用[root@localhost demo]# yum repolist allLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilerepo id                           repo name                              statusdemo                              centos-demo                            enabled: 4,067repolist: 4,067</code></pre><p>install: 安装<br>update: 升级<br>update_to: 升级为指定版本<br>remove|erase：卸载</p><pre><code>yum install PACKAGE_NAME[root@localhost demo]# yum remove zshLoaded plugins: fastestmirror, langpacksResolving Dependencies--&gt; Running transaction check---&gt; Package zsh.x86_64 0:5.0.2-33.el7 will be erased--&gt; Finished Dependency ResolutionDependencies Resolved======================================================================================= Package        Arch              Version                   Repository            Size=======================================================================================Removing: zsh            x86_64            5.0.2-33.el7              installed            5.6 MTransaction Summary=======================================================================================Remove  1 PackageInstalled size: 5.6 MIs this ok [y/N]: yDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transactionWarning: RPMDB altered outside of yum.  Erasing    : zsh-5.0.2-33.el7.x86_64                                             1/1 warning: /etc/zshrc saved as /etc/zshrc.rpmsave  Verifying  : zsh-5.0.2-33.el7.x86_64                                             1/1 Removed:  zsh.x86_64 0:5.0.2-33.el7                                                            Complete!</code></pre><p>info: 查看包的说明信息</p><pre><code>[root@localhost bin]# yum info zshLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfileInstalled PackagesName        : zshArch        : x86_64Version     : 5.0.2Release     : 33.el7Size        : 5.6 MRepo        : installedFrom repo   : demoSummary     : Powerful interactive shellURL         : http://zsh.sourceforge.net/License     : MITDescription : The zsh shell is a command interpreter usable as an interactive login            : shell and as a shell script command processor.  Zsh resembles the ksh            : shell (the Korn shell), but includes many enhancements.  Zsh supports            : command line editing, built-in spelling correction, programmable            : command completion, shell functions (with autoloading), a history            : mechanism, and more.</code></pre><p>provides| whatprovides: 查看指定的文件或特性是由哪个包安装生成的。; </p><pre><code>[root@localhost etc]# yum provides zshLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilezsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : demozsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : @demo[root@localhost usr]# yum provides /etc/zshrcLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilezsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : demoMatched from:Filename    : /etc/zshrczsh-5.0.2-33.el7.x86_64 : Powerful interactive shellRepo        : @demoMatched from:Filename    : /etc/zshrc</code></pre><p>grouplist：查看组列表。有些默认不显示，可以使用hidden参数</p><pre><code>[root@localhost usr]# yum grouplist hiddenLoaded plugins: fastestmirror, langpacksThere is no installed groups file.Maybe run: yum groups mark convert (see man yum)Loading mirror speeds from cached hostfileInstalled Environment Groups:   Development and Creative WorkstationAvailable Environment Groups:(可用环境组)   Minimal Install   Compute Node   Infrastructure Server   File and Print Server   Basic Web Server   Virtualization Host   Server with GUI   GNOME Desktop   KDE Plasma Workspaces   Development and Creative WorkstationInstalled Groups:   Development ToolsAvailable Groups:（可用组）   Additional Development                          ....       \\ 以上命令也可以使用[root@localhost usr]# yum grouplist Deve*</code></pre><p>groupinfo：查看组信息</p><pre><code>[root@localhost usr]# yum groupinfo &quot;Development Tools&quot;Loaded plugins: fastestmirror, langpacksThere is no installed groups file.Maybe run: yum groups mark convert (see man yum)Loading mirror speeds from cached hostfileGroup: Development ToolsGroup-Id: development Description: A basic development environment. Mandatory Packages:（必须安装）    autoconf    automake    binutils    ... Default Packages:（默认安装）    byacc    cscope    ctags    ... Optional Packages:（可选）   ElectricFence   ant   babel   bzr   chrpath    ...</code></pre><p>groupinstall：安装<br>groupremove：移除<br>groupupdate：更新  </p><pre><code>[root@localhost media]# yum groupinstall &quot;Development Tools&quot; --setopt=group_package_types=mandatory,default,optionalLoaded plugins: fastestmirror, langpacksThere is no installed groups file.Maybe run: yum groups mark convert (see man yum)Loading mirror speeds from cached hostfileResolving Dependencies--&gt; Running transaction check                        ....</code></pre><p><a href="https://blog.51cto.com/u_4528728/3804803">https://blog.51cto.com/u_4528728&#x2F;3804803</a>  </p><blockquote><p>如何创建yum仓库的元数据：   </p><p>createrepo: <a href="https://blog.csdn.net/u013158317/article/details/95587397">https://blog.csdn.net/u013158317/article/details/95587397</a></p></blockquote><div class="note green icon-padding flat"><p>练习：</p>  <p>1、将系统安装光盘挂载至/media/yum目录，用其实现yum仓库；  </p>  <p>2、配置使用http://172.16.0.1/yum/{Server,VT,Cluster,ClusterStorage}为可用yum仓库；</p><p>写一个脚本，完成以下功能：  </p><p>说明：此脚本能于同一个repo文件中创建多个Yum源的指向；  </p><p>1、接受一个文件名做为参数，此文件存放至/etc/yum.repos.d目录中，且文件名以.repo为后缀；要求，此文件不能事先存，否则，报错；  </p><p>2、在脚本中，提醒用户输入repo id；如果为quit，则退出脚本；否则，继续完成下面的步骤； </p><p>3、repo name以及baseurl的路径，而后以repo文件的格式将其保存至指定的文件中；</p>  <p>4、enabled默认为1，而gpgcheck默认设定为0；  </p><p>5、此脚本会循环执行多次，除非用户为repo id指定为quit；  </p></div>  <h2 id="手动编译安装软件"><a href="#手动编译安装软件" class="headerlink" title="手动编译安装软件"></a>手动编译安装软件</h2><p>RPM安装：  </p><pre><code>二进制格式：源程序--&gt;编译--&gt;二进制格式    有些特性是编译选定的，如果编译未选定此特性，将无法使用；    rpm包的版本会落后于源码包，甚至落后很多；bind-9.8.7, bind-9.7.2定制：手动编译安装</code></pre><p>相关工具：</p><pre><code>gcc: GNU C Complier, C语言编译工具g++: C++语言编译工具make: 项目管理工具    makefile: 定义了make（gcc,g++）按何种次序去编译这些源程序文件中的源程序使用automake--&gt; makefile.in，使用autoconf--&gt; configure，获取的源码中会包含以上两个文件。然后makefile.in和configure得到makefile</code></pre><p>编译安装的步骤：</p><ol><li><p>前提：准备开发环境(编译环境)<br>安装”Development Tools”和”Development Libraries” </p></li><li><p>获取源码包</p><pre><code> [root@localhost Desktop]# ll total 1016 -rw-rw-r--+ 1 demo demo       0 Dec 25 04:42 demo2.txt -rwxrw-rw-+ 1 demo demo 1039530 Jan  8 07:59 nginx-1.18.0.tar.gz</code></pre></li><li><p>解压源码包</p><pre><code> [root@localhost Desktop]# tar -zxvf nginx-1.18.0.tar.gz </code></pre></li><li><p>指定编译特性</p><pre><code> # cd # ./configure   --help  --prefix=/path/to/somewhere --sysconfdir=/PATH/TO/CONFFILE_PATH 功能：1、让用户选定编译特性；2、检查编译环境  // 查看软件支持的特性 [root@localhost nginx-1.18.0]# ./configure --help // 指定软件的编译特性 [root@localhost nginx-1.18.0]# ./configure --prefix=/usr/local/nginx --conf-path=/usr/local/etc --without-http_rewrite_module --without-http_gzip_module</code></pre></li><li><p>编译</p><pre><code>  make</code></pre></li><li><p>安装</p><pre><code> make install</code></pre></li><li><p>修改PATH环境变量，以能够识别此程序的二进制文件路径；</p><pre><code> 修改/etc/profile文件，然后执行source /etc/profile 在/etc/profile.d/目录建立一个以.sh为名称后缀的文件，在里面定义export PATH=$PATH:/path/to/somewhere</code></pre></li><li><p>默认情况下，系统搜索库文件的路径&#x2F;lib, &#x2F;usr&#x2F;lib; 要增添额外搜寻路径：</p><pre><code> 在/etc/ld.so.conf.d/中创建以.conf为后缀名的文件，而后把要增添的路径直接写至此文件中； # ldconfig 通知系统重新搜寻库文件     -v: 显示重新搜寻库的过程</code></pre></li><li><p>头文件：输出给系统</p><pre><code> 默认：/usr/include 增添头文件搜寻路径，使用链接进行：     /usr/local/tengine/include/   /usr/include/     两种方式：     ln -s /usr/local/tengine/include/* /usr/include/ 或     ln -s /usr/local/tengine/include  /usr/include/tengine(建议这种)</code></pre></li><li><p>man文件路径：安装在–prefix指定的目录下的man目录；&#x2F;usr&#x2F;share&#x2F;man</p><pre><code>1、man -M /PATH/TO/MAN_DIR COMMAND2、在/etc/man.config中添加一条MANPATH</code></pre></li><li><p>删除软件只需要将软件生成的文件以及上述修改删除即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;程序介绍&quot;&gt;&lt;a href=&quot;#程序介绍&quot; class=&quot;headerlink&quot; title=&quot;程序介绍&quot;&gt;&lt;/a&gt;程序介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;我们将语言分为两种。一种是编译器语言，另一种是解释性语言。编译语言以C语言为例，需要将源代码–&amp;g</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="yum" scheme="http://example.com/tags/yum/"/>
    
    <category term="rpm" scheme="http://example.com/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>vi编辑器</title>
    <link href="http://example.com/2022/11/27/Linux-VI/"/>
    <id>http://example.com/2022/11/27/Linux-VI/</id>
    <published>2022-11-27T11:54:59.238Z</published>
    <updated>2022-11-27T11:54:59.236Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>vi是linux中最常用的一个文本编辑器。vim是vi的增强版。</P>  </div><h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p>vim模式分为如下几种：</p><ul><li>编辑模式(命令模式)</li><li>输入模式</li><li>末行模式</li></ul><p>模式转换：  </p><pre><code>编辑--&gt;输入：    i: 在当前光标所在字符的前面，转为输入模式；    a: 在当前光标所在字符的后面，转为输入模式；    o: 在当前光标所在行的下方，新建一行，并转为输入模式；        I：在当前光标所在行的行首，转换为输入模式    A：在当前光标所在行的行尾，转换为输入模式    O：在当前光标所在行的上方，新建一行，并转为输入模式；输入--&gt;编辑：    ESC    编辑--&gt;末行：    ：末行--&gt;编辑：    ESC, ESC</code></pre><h2 id="vim打开文件"><a href="#vim打开文件" class="headerlink" title="vim打开文件"></a>vim打开文件</h2><pre><code># vim /path/to/somefilevim +# :打开文件，并定位于第#行 vim +：打开文件，定位至最后一行vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首默认处于编辑模式</code></pre><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><pre><code>1、末行模式关闭文件    :q  退出    :wq 保存并退出    :q! 不保存并退出    :w 保存    :w! 强行保存    :wq --&gt; :x2、编辑模式下退出    ZZ: 保存并退出</code></pre><h2 id="移动光标-编辑模式"><a href="#移动光标-编辑模式" class="headerlink" title="移动光标(编辑模式)"></a>移动光标(编辑模式)</h2><pre><code>1、逐字符移动：    h: 左    l: 右    j: 下    k: 上 #h: 移动#个字符；2、以单词为单位移动    w: 移至下一个单词的词首    e: 跳至当前或下一个单词的词尾    b: 跳至当前或前一个单词的词首        #w: 移动#个单词3、行内跳转：    0: 绝对行首    ^: 行首的第一个非空白字符    $: 绝对行尾4、行间跳转    #G：跳转至第#行；    G：最后一行        末行模式下，直接给出行号即可</code></pre><h2 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h2><pre><code>Ctrl+f: 向下翻一屏Ctrl+b: 向上翻一屏Ctrl+d: 向下翻半屏Ctrl+u: 向上翻半屏</code></pre><h2 id="删除单个字符"><a href="#删除单个字符" class="headerlink" title="删除单个字符"></a>删除单个字符</h2><pre><code>x: 删除光标所在处的单个字符  \#x: 删除光标所在处及向后的共#个字符</code></pre><h2 id="删除命令-d"><a href="#删除命令-d" class="headerlink" title="删除命令: d"></a>删除命令: d</h2><p>d命令跟跳转命令组合使用；</p><pre><code>#dw, #de, #db</code></pre><p>dd: 删除当前光标所在行</p><pre><code>#dd: 删除包括当前光标所在行在内的#行；</code></pre><p>末行模式下：</p><pre><code>StartADD,EndADDd        .: 表示当前行    $: 最后一行    +#: 向下的#行</code></pre><h2 id="复制命令-y"><a href="#复制命令-y" class="headerlink" title="复制命令 y"></a>复制命令 y</h2><pre><code>用法同d命令</code></pre><h2 id="修改：先删除内容，再转换为输入模式"><a href="#修改：先删除内容，再转换为输入模式" class="headerlink" title="修改：先删除内容，再转换为输入模式"></a>修改：先删除内容，再转换为输入模式</h2><pre><code>c: 用法同d命令</code></pre><h2 id="粘贴命令-p"><a href="#粘贴命令-p" class="headerlink" title="粘贴命令 p"></a>粘贴命令 p</h2><pre><code>p: 如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面；P: 如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面；</code></pre><h2 id="替换："><a href="#替换：" class="headerlink" title="替换："></a>替换：</h2><pre><code>r: 替换单个字符R: 替换模式</code></pre><h2 id="撤消编辑操作-u"><a href="#撤消编辑操作-u" class="headerlink" title="撤消编辑操作 u"></a>撤消编辑操作 u</h2><pre><code>u：撤消前一次的编辑操作    连续u命令可撤消此前的n次编辑操作#u: 直接撤消最近#次编辑操作撤消最近一次撤消操作：Ctrl+r</code></pre><h2 id="重复前一次编辑操作"><a href="#重复前一次编辑操作" class="headerlink" title="重复前一次编辑操作"></a>重复前一次编辑操作</h2><p>. (点)</p><h2 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h2><pre><code>v: 按字符选取V：按矩形选取</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><pre><code>/PATTERN?PATTERN    n:向下    N:向上</code></pre><h2 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h2><p>在末行模式下使用s命令</p><pre><code>ADDR1,ADDR2s@PATTERN@string@gi1,$%：表示全文</code></pre><p>练习：将&#x2F;etc&#x2F;yum.repos.d&#x2F;server.repo文件中的<a href="ftp://instructor.example.com/pub%E6%9B%BF%E6%8D%A2%E4%B8%BAhttp://172.16.0.1/yum">ftp://instructor.example.com/pub替换为http://172.16.0.1/yum</a></p><pre><code>%s/ftp:\/\/instructor\.example\.com\/pub/http:\/\/172.16.0.1\/yum/g%s@ftp://instructor\.example\.com/pub@http://172.16.0.1/yum@g</code></pre><p>文件内容如下：</p><pre><code># repos on instructor for classroom use# Main rhel5 server[base]name=Instructor Server Repositorybaseurl=ftp://172.16.0.1/pub/Servergpgcheck=0# This one is needed for xen packages[VT]name=Instructor VT Repositorybaseurl=ftp://172.16.0.1/pub/VTgpgcheck=0# This one is needed for clustering packages[Cluster]name=Instructor Cluster Repositorybaseurl=ftp://172.16.0.1/pub/Clustergpgcheck=0# This one is needed for cluster storage (GFS, iSCSI target, etc...) packages[ClusterStorage]name=Instructor ClusterStorage Repositorybaseurl=ftp://172.16.0.1/pub/ClusterStoragegpgcheck=0</code></pre><h2 id="使用vim编辑多个文件"><a href="#使用vim编辑多个文件" class="headerlink" title="使用vim编辑多个文件"></a>使用vim编辑多个文件</h2><pre><code>vim FILE1 FILE2 FILE3:next 切换至下一个文件:prev 切换至前一个文件:last 切换至最后一个文件:first 切换至第一个文件退出:qa 全部退</code></pre><h2 id="分屏显示一个文件"><a href="#分屏显示一个文件" class="headerlink" title="分屏显示一个文件"></a>分屏显示一个文件</h2><pre><code>Ctrl+w, s: 水平拆分窗口Ctrl+w, v: 垂直拆分窗口注：先按住Ctrl+w，松开，然后按s在窗口间切换光标：Ctrl+w, ARROW(上下左右):qa 关闭所有窗口</code></pre><h2 id="分窗口编辑多个文件"><a href="#分窗口编辑多个文件" class="headerlink" title="分窗口编辑多个文件"></a>分窗口编辑多个文件</h2><pre><code>vim -o : 水平分割显示vim -O : 垂直分割显示</code></pre><h2 id="将当前文件中部分内容另存为另外一个文件"><a href="#将当前文件中部分内容另存为另外一个文件" class="headerlink" title="将当前文件中部分内容另存为另外一个文件"></a>将当前文件中部分内容另存为另外一个文件</h2><pre><code>末行模式下使用w命令:w:ADDR1,ADDR2w /path/to/somewhere</code></pre><h2 id="将另外一个文件的内容填充在当前文件中"><a href="#将另外一个文件的内容填充在当前文件中" class="headerlink" title="将另外一个文件的内容填充在当前文件中"></a>将另外一个文件的内容填充在当前文件中</h2><pre><code>:r /path/to/somefile</code></pre><h2 id="跟shell交互"><a href="#跟shell交互" class="headerlink" title="跟shell交互"></a>跟shell交互</h2><pre><code>:! COMMAND</code></pre><h2 id="高级话题"><a href="#高级话题" class="headerlink" title="高级话题"></a>高级话题</h2><p>1、显示或取消显示行号</p><pre><code>:set number:set nu:set nonu</code></pre><p>2、显示忽略或区分字符大小写</p><pre><code>:set ignorecase:set ic:set noic</code></pre><p>3、设定自动缩进</p><pre><code>:set autoindent:set ai:set noai</code></pre><p>4、查找到的文本高亮显示或取消</p><pre><code>:set hlsearch:set nohlsearch</code></pre><p>5、语法高亮</p><pre><code>:syntax on:syntax off</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>/etc/vimrc~/.vimrc</code></pre><div class="note green icon-padding flat"><p>注：可以使用vimtutor练习</p></div>    ]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;vi是linux中最常用的一个文本编辑器。vim是vi的增强版。&lt;/P&gt;  
&lt;/div&gt;

&lt;h2 id=&quot;vim模式&quot;&gt;&lt;a href=&quot;#vim模式&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="vi" scheme="http://example.com/tags/vi/"/>
    
  </entry>
  
  <entry>
    <title>sed（流编辑器）</title>
    <link href="http://example.com/2022/11/27/Linux-Sed/"/>
    <id>http://example.com/2022/11/27/Linux-Sed/</id>
    <published>2022-11-27T11:29:41.234Z</published>
    <updated>2022-11-27T11:29:41.232Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>sed是Linux中的一个流编辑器，它主要是针对行进行编辑的。vi和nano是全屏编辑器。</P>  <p>sed 模式空间：默认不编辑原文件，仅对模式空间中的数据做处理；而后，处理结束后，将模式空间打印至屏幕</P></div><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><pre><code>sed [options] &#39;AddressCommand&#39; file ...    -n: 静默模式，不再默认显示模式空间中的内容    -i: 直接修改原文件    -e SCRIPT -e SCRIPT:可以同时执行多个脚本    -f /PATH/TO/SED_SCRIPT        sed -f /path/to/scripts  file    -r: 表示使用扩展正则表达式注：AddressCommand中地址省略代表所有行。有地址，后面的command命令不能空。Address：1、StartLine,EndLine    比如1,100    $：最后一行2、/RegExp/    /^root/3、/pattern1/,/pattern2/    第一次被pattern1匹配到的行开始，至第一次被pattern2匹配到的行结束，这中间的所有行4、LineNumber    指定的行5、StartLine, +N    从startLine开始，向后的N行；Command：    d: 删除符合条件的行；    p: 显示符合条件的行；    a \string: 在指定的行后面追加新行，内容为string        \n：可以用于换行    i \string: 在指定的行前面添加新行，内容为string    r FILE: 将指定的文件的内容添加至符合条件的行处    w FILE: 将地址指定的范围内的行另存至指定的文件中;     s/pattern/string/修饰符: 查找并替换，默认只替换每行中第一次被模式匹配到的字符串        加修饰符        g: 全局替换        i: 忽略字符大小写    s///: s###, s@@@        字串引用：                    \(\), \1, \2            l..e: like--&gt;liker          love--&gt;lover                    like--&gt;Like          love--&gt;Love        &amp;: 引用模式匹配的整个串   [root@localhost etc]# echo &quot;/etc/rc.d/&quot; | sed -r &#39;s@^(/.*)/([^/]+)/?@\1 and \2 and &amp;@g&#39;   /etc and rc.d and /etc/rc.d/     [root@localhost etc]# sed -n &#39;1,3p&#39; /etc/inittab    # inittab is no longer used when using systemd.   #   # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</code></pre><div class="note green icon-padding flat"><p>sed练习：</p><p>1、删除/etc/grub.conf文件中行首的空白符； </p> <pre><code>sed -r &#39;s@^[[:spapce:]]+@@g&#39; /etc/grub.conf</code></pre><p>2、替换/etc/inittab文件中"id:3:initdefault:"一行中的数字为5；</p><pre><code>sed &#39;s@\(id:\)[0-9]\(:initdefault:\)@\15\2@g&#39; /etc/inittab</code></pre><p>3、删除/etc/inittab文件中的空白行；</p><pre><code>sed &#39;/^$/d&#39; /etc/inittab</code></pre><p>4、删除/etc/inittab文件中开头的#号; </p><pre><code>sed &#39;s@^#@@g&#39; /etc/inittab</code></pre><p>5、删除某文件中开头的#号及后面的空白字符，但要求#号后面必须有空白字符;</p><pre><code>sed -r &#39;s@^#[[:space:]]+@@g&#39; /etc/inittab</code></pre><p>6、删除某文件中以空白字符后面跟#类的行中的开头的空白字符及#</p><pre><code>sed -r &#39;s@^[[:space:]]+#@@g&#39; /etc/inittab</code></pre><p>7、取出一个文件路径的目录名称;</p><pre><code>echo &quot;/etc/rc.d/&quot; | sed -r &#39;s@^(/.*/)[^/]+/?@\1@g&#39;基名：echo &quot;/etc/rc.d/&quot; | sed -r &#39;s@^/.*/([^/]+)/?@\1@g&#39;</code></pre><p>8、传递一个用户名参数给脚本，判断此用户的用户名跟其基本组的组名是否一致，并将结果显示出来。注使用sed命令执行状态结果需注意。</p><pre><code>[root@localhost etc]# grep root /etc/passwd | sed -n &#39;/^\(root\):.*:[[:digit:]]:[[:digit:]]:\1/p&#39;root:x:0:0:root:/root:/bin/bash</code></pre></div><p><a href="https://www.cnblogs.com/zakun/p/linux-cmd-sed.html">https://www.cnblogs.com/zakun/p/linux-cmd-sed.html</a> </p><p><a href="https://www.runoob.com/linux/linux-comm-sed.html">https://www.runoob.com/linux/linux-comm-sed.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;sed是Linux中的一个流编辑器，它主要是针对行进行编辑的。vi和nano是全屏编辑器。&lt;/P&gt;  
&lt;p&gt;sed 模式空间：默认不编辑原文件，仅对模式空间中的数据做处理；而后，处理结束后</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="sed" scheme="http://example.com/tags/sed/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://example.com/2022/11/27/Linux-file/"/>
    <id>http://example.com/2022/11/27/Linux-file/</id>
    <published>2022-11-27T07:57:24.976Z</published>
    <updated>2022-11-27T07:57:24.974Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相成。同时，文件系统也是一个操作系统的重要组成部分。</P></div><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在Linux中一切皆文件</p><pre><code>[demo@localhost dev]$ ll文件类型                   主设备号 次设备号crw-rw-rw-. 1 root tty       5,     0 Dec 25 04:19 ttycrw--w----. 1 root tty       4,     0 Dec 25 04:19 tty0crw--w----. 1 root tty       4,     1 Dec 25 04:19 tty1brw-rw----. 1 root disk      8,     0 Dec 25 04:19 sdabrw-rw----. 1 root disk      8,     1 Dec 25 04:19 sda1brw-rw----. 1 root disk      8,     2 Dec 25 04:19 sda2                         设备文件类型：b: 按块为单位，随机访问的设备；c：按字符为单位，线性设备；主设备号 （major number）    标识设备类型次设备号 （minor number）    标识同一种类型中不同设备</code></pre><p>创建特殊文件</p><pre><code>mknod [OPTION]... NAME TYPE MAJOR（主设备号） MINOR（次设备号）    -m MODE ： 指定权限[root@localhost dev]# mknod sda3 b 8 3[root@localhost dev]# mknod -mode 660 sda4 b 8 3</code></pre><p>磁盘设备的设备文件名：</p><pre><code>IDE, ATA：hdSATA：sdSCSI: sdUSB: sd同种设备以a，b，c...来区分同一种类型下的不同设备，即sda, sdb, sdc, ...IDE:     第一个IDE口：主、从        /dev/hda, /dev/hdb    第二个IDE口：主、从        /dev/hdc, /dev/hdd</code></pre><p>同一磁盘设备文件分区名:</p><pre><code>如hda:     hda1: 第一个主分区    hda2: 第二个主分区    hda3: 第三个主分区    hda4: 第四个主分区（MBR中的扩展分区）    hda5: 第一个逻辑分区</code></pre><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h3><p>首先了解一下磁盘的物理结构。磁盘是由一个个光盘结合在一起，每个光盘上都有一些同心圆。这些同心圆我们称之为磁道，然后将磁道划分为一个个的扇区作为基本存储单元。同时每一个光盘的同一扇区称之为柱面。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB362e3b95a3888dcdf1fc43d21c8daa00?method=download&shareKey=974939cf6495a01ed31327a286a5aa35" alt="image"></p><p>磁盘刚被创建出来后，没有任何信息。磁盘在出厂的时候会进行低级格式化。格式化之后的扇区由前导码（包括柱面号、扇区号等）、数据区和ECC（数据纠错码）组成。</p><p>大部分的磁盘能够划分出一到多个分区，叫做磁盘分区。每个分区都有独立的文件系统，每块分区的文件系统都可以不同。目前磁盘的分区组织方式有两种，分别为MBR和GPT。  </p><h3 id="分区组织方式"><a href="#分区组织方式" class="headerlink" title="分区组织方式"></a>分区组织方式</h3><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>磁盘的0号分区称为主引导记录（MBR），位于磁盘的第一扇区。MBR由Bootloader（446bytes）、Partition Table（64bytes，每个16个字节记录一个分区）、Magic Number（2个字节）组成。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB373eb090e2c333bc226709ac8b7ff105?method=download&shareKey=06a6b63acbf2ef85453d7227a63f4643" alt="image"></p><ol><li><p>Bootloader:用于标识操作系统的放置方式和位置，以便可以将其加载到计算机的内存中。    </p></li><li><p>Partition Table:由于Partition Table最多只能包含四条记录。如果磁盘分区大于4，需要将最后一条记录添加为扩展分区。扩展分区可以存储更多的分区记录。</p></li><li><p>Magic Number：如果为0x55 0xAA，则代表该设备MBR中含有Bootloader。</p></li></ol><p>在计算机启动过程中会首先启动BIOS检查各种硬件环境，之后根据BIOS的配置挨个查看存储设备的前512字节是不是以0x55 0xAA结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载该磁盘MBR中的Bootloader。并将控制权转移到相应设备（U盘、硬盘）的引导加载程序(Bootloader)。</p><p>MBR存在如下限制：</p><ol><li>操作系统无法抓取到2.2T以上的磁盘容量</li><li>MBR仅有一个区块。若被破坏后，经常无法或很难救援</li><li>MBR内存开机管理程序的区块仅446Bytes，无法容纳较多的程序码</li></ol><h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p>GPT不存在如上所述的限制。</p><blockquote><p>过去一个扇区的大小为512Bytes，目前已经有4K的扇区出现。为了相容于所有的磁盘，所以引入了逻辑区块位址（LBA)的概念。GPT将磁盘所有扇区以此LBA（默认为512Bytes喔！）来规划，而第一个LBA称为LBA0.</p></blockquote><p>GPT使用了34个LBA区块来记录分区信息。同时整个磁盘的最后33个LBA也拿来作为一个备份。GPT结构如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB1a6a41e7d27580e02d1060e36902cd66?method=download&shareKey=9aa1e15262c5049a57738d48448694f5" alt="image"></p><p>LBA0 (MBR兼容）</p><p>与MBR模式相似的，这个相容区块也分为两个部分。一个就是根之前446Bytes相似的区块，存储了第一阶段的开机管理程序。而在原本的分区表的记录区内放入了一个特殊标志，用来表示此磁盘为GPT格式。而不懂GPT分区表的磁盘管理程序，就不会认识这颗磁盘。除非用户有特别要求要处理这颗磁盘。</p><p>LBA1 （GPT表头）</p><p>记录了备份用的GPT分区放置的位置，同时放置了分区表的校验机制码。操作系统可以根据这个校验码来判断GPT是否正确。若有错误，还可以通过这个记录区来取得备份的GPT来恢复GPT的正常运行。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>磁盘在使用之前要进行高级格式化，高级格式化即在分区上分配文件系统。</p><h4 id="ext-系列"><a href="#ext-系列" class="headerlink" title="ext 系列"></a>ext 系列</h4><p>每个文件系统的结构如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd28a8793ae46cdcd002c271e2f45bcac?method=download&shareKey=255b05b4812120ce65529dfddcf1bb03" alt="image"></p><ul><li>引导块：为了一致性，每个分区都要从引导块开始，即使引导块不包括操作系统。引导块占据文件系统的前4096个字节，从磁盘上的字节偏移量0开始。引导块可用于启动操作系统。  </li><li>超级块：描述整个分区的文件系统信息。例如块大小、文件系统的大小、文件系统的块数等。  </li><li>空闲空间管理：块位图和inode位图。块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块。其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用</li><li>inode：一个文件除了数据需要存储之外，一些描述信息也需要存储。例如文件类型（常规、目录、符号链接等），权限，文件大小，创建&#x2F;修改&#x2F;访问时间等。也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中</li><li>根目录：存放文件系统目录树的根部。</li><li>文件和目录：存储文件和目录的数据。</li></ul><p>文件系统逻辑结构图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8fafced3dd9b543ffa04545dfc65680e?method=download&shareKey=c8803f0b05537d766c6ad7f60b7588da" alt="image"></p><p>Linux支持的文件系统</p><ul><li>ext3, ext4, ext2: extended</li><li>reiserfs</li><li>iso9660, swap, cifs, nfs</li><li>xfs, jfs</li><li>ocfs2, gfs2</li><li>fat32, ntfs</li></ul><h4 id="xfs文件系统"><a href="#xfs文件系统" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><p>CentOS 7 开始，默认的文件系统已经由原本的Ext4 变成了xfs 这个较适合大容量磁盘与巨型文件性能较佳的文件系统了。</p><p>Ext文件系统采用的是预先规划出所有的inode&#x2F;block&#x2F;metadata等数据，这些数据未来系统可以直接使用。xfs则是根据需要动态分配inode和block数据。当磁盘容量达到TB以上等级时，传统ext家族在文件系统格式化时预先规划inode和block就需要消耗好多的时间。</p><p>xfs文件系统的组成：</p><ol><li>数据区：这个区域和ext文件系统的block群组一样，只不过inode和block是动态产生的，并非是一开始格式化就分配好的</li><li>文件系统活动登录区：日志区。文件的变化会记录到这里。当变化完整的写入数据区后，该笔记录才会被终结。</li><li>实时运行区：当有文件要被创建时，xfs会在这个区段里面找一个到数个extent区块，将文件放置在这个区块中，等到动态分配完毕后，再写入到数据区的inode和block中。这个extent区块的大小要在格式化的时候就指定，最小值4k最大可到1G。建议不要乱动，具有磁盘阵列stripe的情况下，则建议extent设置为与stripe一样大比较好。</li></ol><p>查看xfs文件系统信息：</p><pre><code>[root@study ~]# xfs_info 挂载点|设备文件名范例一：找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录[root@study ~]# df -T /bootFilesystem Type 1K-blocks Used Available Use% Mounted on/dev/vda2 xfs 1038336 133704 904632 13% /boot# 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！[root@study ~]# xfs_info /dev/vda21 meta-data=/dev/vda2 isize=256 agcount=4, agsize=65536 blks2 = sectsz=512 attr=2, projid32bit=13 = crc=0 finobt=04 data = bsize=4096 blocks=262144, imaxpct=255 = sunit=0 swidth=0 blks6 naming =version 2 bsize=4096 ascii-ci=0 ftype=07 log =internal bsize=4096 blocks=2560, version=28 = sectsz=512 sunit=0 blks, lazy-count=19 realtime =none extsz=4096 blocks=0, rtextents=0第 1 行里面的 isize 指的是 inode 的容量，每个有 256Bytes 这么大。至于 agcount 则是前面谈到的储存区群组 （allocation group） 的个数，共有 4 个， agsize 则是指每个储存区群组具有 65536 个 block 。配合第 4 行的 block 设置为 4K，因此整个文件系统的容量应该就是 4655364K 这么大！第 2 行里面 sectsz 指的是逻辑扇区 （sector） 的容量设置为 512Bytes 这么大的意思。第 4 行里面的 bsize 指的是 block 的容量，每个 block 为 4K 的意思，共有 262144 个block 在这个文件系统内。第 5 行里面的 sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。这部份我们下面格式化的时候会举一个例子来说明。第 7 行里面的 internal 指的是这个登录区的位置在文件系统内，而不是外部设备的意思。且占用了 4K * 2560 个 block，总共约 10M 的容量。第 9 行里面的 realtime 区域，里面的 extent 容量为 4K。不过目前没有使用。</code></pre><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="分区命令"><a href="#分区命令" class="headerlink" title="分区命令"></a>分区命令</h3><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区！parted &#x2F;dev&#x2F;xxx print可以找出内部的分区表类型，之后再用 gdisk 或 fdisk 来操作系统。</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk -l [&#x2F;dev&#x2F;to&#x2F;some_device_file] ：查看当前系统识别了几块硬盘  </p><pre><code>[root@localhost dev]# fdisk -lDisk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0001d65a   Device Boot      Start         End      Blocks   Id  System/dev/sda1   *        2048     2099199     1048576   83  Linux（分区）/dev/sda2         2099200    41943039    19921920   8e  Linux LVM（分区）Disk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes</code></pre><p>fdisk &#x2F;dev&#x2F;sda  </p><pre><code>p: 显示当前硬件的分区，包括没保存的改动n: 创建新分区    e: 扩展分区（创建扩展分区，将所有空间分配给它）    p: 主分区d: 删除一个分区w: 保存退出q: 不保存退出t: 修改分区类型L: （查看分区类型）l: 显示所支持的所有类型[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xc8f76ed0.Command (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  SystemCommand (m for help): nPartition type:   p   primary (0 primary, 0 extended, 4 free)   e   extendedSelect (default p): pPartition number (1-4, default 1):   First sector (2048-41943039, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +1GPartition 1 of type Linux and of size 1 GiB is set... //再建立两个主分区Command (m for help): nPartition type:   p   primary (3 primary, 0 extended, 1 free)   e   extendedSelect (default e): eSelected partition 4First sector (6293504-41943039, default 6293504): Using default value 6293504Last sector, +sectors or +size&#123;K,M,G&#125; (6293504-41943039, default 41943039): Using default value 41943039Partition 4 of type Extended and of size 17 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  System/dev/sdb1            2048     2099199     1048576   83  Linux/dev/sdb2         2099200     4196351     1048576   83  Linux/dev/sdb3         4196352     6293503     1048576   83  Linux/dev/sdb4         6293504    41943039    17824768    5  ExtendedCommand (m for help): nAll primary partitions are in useAdding logical partition 5First sector (6295552-41943039, default 6295552):  Using default value 6295552Last sector, +sectors or +size&#123;K,M,G&#125; (6295552-41943039, default 41943039): +1GPartition 5 of type Linux and of size 1 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  System/dev/sdb1            2048     2099199     1048576   83  Linux/dev/sdb2         2099200     4196351     1048576   83  Linux/dev/sdb3         4196352     6293503     1048576   83  Linux/dev/sdb4         6293504    41943039    17824768    5  Extended/dev/sdb5         6295552     8392703     1048576   83  Linux</code></pre><p>cat &#x2F;proc&#x2F;partitions ：查看系统有哪些分区<br>partprobe [&#x2F;dev&#x2F;sda]：重新加载设备分区</p><h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><pre><code>[root@study ~]# gdisk 设备名称范例：由前一小节的 lsblk 输出，我们知道系统有个 /dev/vda，请观察该磁盘的分区与相关数据[root@study ~]# gdisk /dev/vda  #仔细看，不要加上数字喔！GPT fdisk （gdisk） version 0.8.6Partition table scan:MBR: protectiveBSD: not presentAPM: not presentGPT: presentFound valid GPT with protective MBR; using GPT. &amp;lt;==找到了 GPT 的分区表！Command （? for help）: #这里可以让你输入指令动作，可以按问号 （?） 来查看可用指令Command （? for help）: ?b back up GPT data to a filec change a partition&#39;s named delete a partition # 删除一个分区i show detailed information on a partitionl list known partition typesn add a new partition # 增加一个分区o create a new empty GUID partition table （GPT）p print the partition table # 印出分区表 （常用）q quit without saving changes  # 不储存分区就直接离开 gdiskr recovery and transformation options （experts only）s sort partitionst change a partition&#39;s type codev verify diskw write table to disk and exit  # 储存分区操作后离开 gdiskx extra functionality （experts only）? print this menuCommand （? for help）:</code></pre><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>查看当前内核所支持文件系统类型：</p><pre><code>cat /proc/filesystems  </code></pre><h4 id="ext系列文件系统"><a href="#ext系列文件系统" class="headerlink" title="ext系列文件系统"></a>ext系列文件系统</h4><p>专门管理ext系列文件：<br>mkdfs.ext4<br>mke2fs  </p><pre><code>-j: 创建ext3类型文件系统-b BLOCK_SIZE: 指定块大小，默认为4096；可用取值为1024、2048或4096；-L LABEL：指定分区卷标；-m #: 指定预留给超级用户的块数百分比-i #: 用于指定用多少字节的空间创建一个inode，默认为8192；这里给出的数值应该为块大小的2^n倍；-N #: 指定inode个数；-F: 强制创建文件系统；-E: 用户指定额外文件系统属性; [root@localhost ~]# mkfs -t ext2 /dev/sdb1mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65536 inodes, 262144 blocks13107 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8192 inodes per groupSuperblock backups stored on blocks: （超级块备份存储的块地址）    32768, 98304, 163840, 229376Allocating group tables: done                            Writing inode tables: done                            Writing superblocks and filesystem accounting information: done</code></pre><h4 id="xfs文件系统-1"><a href="#xfs文件系统-1" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><pre><code>[root@study ~]# mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \[-r parms] 设备名称选项与参数：关于单位：下面只要谈到“数值”时，没有加单位则为 Bytes 值，可以用 k,m,g,t,p （小写）等来解释比较特殊的是 s 这个单位，它指的是 sector 的“个数”喔！-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！-d ：后面接的是重要的 data section 的相关参数值，主要的值有：    agcount=数值 ：设置需要几个储存群组的意思（AG），通常与 CPU 有关    agsize=数值 ：每个 AG 设置为多少容量的意思，通常 agcount/agsize 只选一个设置即可    file ：指的是“格式化的设备是个文件而不是个设备”的意思！（例如虚拟磁盘）    size=数值 ：data section 的容量，亦即你可以不将全部的设备容量用完的意思    su=数值 ：当有 RAID 时，那个 stripe 数值的意思，与下面的 sw 搭配使用    sw=数值 ：当有 RAID 时，用于储存数据的磁盘数量（须扣除备份碟与备用碟）    sunit=数值 ：与 su 相当，不过单位使用的是“几个 sector（512Bytes大小）”的意思    swidth=数值 ：就是 su*sw 的数值，但是以“几个 sector（512Bytes大小）”来设置-f ：如果设备内已经有文件系统，则需要使用这个 -f 来强制格式化才行！-i ：与 inode 有较相关的设置，主要的设置值有：    size=数值 ：最小是 256Bytes 最大是 2k，一般保留 256 就足够使用了！    internal=[0&amp;#124;1]：log 设备是否为内置？默认为 1 内置，如果要用外部设备，使用下面设置    logdev=device ：log 存储为后面接的那个设备上头的意思，需设置 internal=0 才可！    size=数值 ：指定这块登录区的容量，通常最小得要有 512 个 block，大约 2M 以上才行！-L ：后面接这个文件系统的标头名称 Label name 的意思！-r ：指定 realtime section 的相关设置值，常见的有：    extsize=数值 ：就是那个重要的 extent 数值，一般不须设置，但有 RAID 时，    最好设置与 swidth 的数值相同较佳！最小为 4K 最大为 1G 。    范例：将前一小节分区出来的 /dev/vda4 格式化为 xfs 文件系统[root@study ~]# mkfs.xfs /dev/vda4meta-data=/dev/vda4 isize=256 agcount=4, agsize=65536 blks= sectsz=512 attr=2, projid32bit=1= crc=0 finobt=0data = bsize=4096 blocks=262144, imaxpct=25= sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal log bsize=4096 blocks=2560, version=2= sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0# 很快格是化完毕！都用默认值！较重要的是 inode 与 block 的数值[root@study ~]# blkid /dev/vda4/dev/vda4: UUID=&quot;39293f4f-627b-4dfd-a015-08340537709c&quot; TYPE=&quot;xfs&quot;# 确定创建好 xfs 文件系统了！</code></pre><p>XFS文件系统for RAID性能优化</p><p>磁盘阵列 （RAID） 就是通过将文件先细分为数个小型的分区区块 （stripe） 之后，然后将众多的 stripes 分别放到磁盘阵列里面的所有磁盘， 所以一个文件是被同时写入到多个磁盘去，当然性能会好一些。为了文件的保全性，所以在这些磁盘里面，会保留数个（与磁盘阵列的规划有关） 备份磁盘 （parity disk）， 以及可能会保留一个以上的备用磁盘（spare disk）。</p><p>文件系统的读写要能够有最优化，最好能够搭配磁盘阵列的参数来设计，这样性能才能够起来！也就是说，你可以先在文件系统就将 stripe 规划好， 那交给 RAID 去存取时，它就无须重复进行文件的 stripe 过程，性能当然会更好！那格式化时，最优化性能与什么咚咚有关呢？我们来假设个环境好了：</p><blockquote><p>我有两个线程的 CPU 数量，所以 agcount 最好指定为 2</p><p>当初设置 RAID 的 stripe 指定为 256K 这么大，因此 su 最好设置为 256k</p><p>设置的磁盘阵列有 8 颗，因为是 RAID5 的设置，所以有一个 parity （备份碟），因此指定 sw 为 7</p><p>由上述的数据中，我们可以发现数据宽度 （swidth） 应该就是 256K*7 得到 1792K，以指定 extsize 为 1792k</p></blockquote><blockquote><p>重新创建文件系统会损坏原有文件  </p></blockquote><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>mkfs: make file system  </p><pre><code>-t FSTYPE 文件系统类型    mkfs -t ext2 = mkfs.ext2mkfs -t ext3 = mkfs.ext3</code></pre><p>parted：创建文件系统，ext和xfs都可以</p><pre><code>parted [设备] [指令 [参数]]新增分区：mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束显示分区：print删除分区：rm [partition]范例一：以 parted 列出目前本机的分区表数据[root@study ~]# parted /dev/vda printModel: Virtio Block Device （virtblk） &amp;lt;==磁盘接口与型号Disk /dev/vda: 42.9GB &amp;lt;==磁盘文件名与容量Sector size （logical/physical）: 512B/512B &amp;lt;==每个扇区的大小Partition Table: gpt &amp;lt;==是 GPT 还是 MBR 分区Disk Flags: pmbr_bootNumber Start End Size File system Name Flags1 1049kB 3146kB 2097kB bios_grub2 3146kB 1077MB 1074MB xfs3 1077MB 33.3GB 32.2GB lvm4 33.3GB 34.4GB 1074MB xfs Linux filesystem5 34.4GB 35.4GB 1074MB ext4 Microsoft basic data6 35.4GB 36.0GB 537MB linux-swap（v1） Linux swap[ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ]</code></pre><h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><blockquote><p>修复文件系统时不能被挂载</p></blockquote><h4 id="xfs-repair"><a href="#xfs-repair" class="headerlink" title="xfs_repair"></a>xfs_repair</h4><p>检查并修复 XFS 文件系统</p><pre><code>[root@study ~]# xfs_repair [-fnd] 设备名称选项与参数：-f ：后面的设备其实是个文件而不是实体设备-n ：单纯检查并不修改文件系统的任何数据 （检查而已）-d ：通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作！很危险！不要随便使用范例：检查一下刚刚创建的 /dev/vda4 文件系统[root@study ~]# xfs_repair /dev/vda4Phase 1 - find and verify superblock...Phase 2 - using internal logPhase 3 - for each AG...Phase 4 - check for duplicate blocks...Phase 5 - rebuild AG headers and trees...Phase 6 - check inode connectivity...Phase 7 - verify and correct link counts...done# 共有 7 个重要的检查流程！详细的流程介绍可以 man xfs_repair 即可！</code></pre><h4 id="其它文件系统自检"><a href="#其它文件系统自检" class="headerlink" title="其它文件系统自检"></a>其它文件系统自检</h4><p>fsck: 检查并修复Linux文件系统</p><pre><code>-t FSTYPE: 指定文件系统类型-a: 自动修复</code></pre><p>e2fsck: 专用于修复ext2&#x2F;ext3文件系统</p><pre><code>-f: 强制检查；-p: 自动修复；[root@localhost ~]# e2fsck /dev/sdb1e2fsck 1.42.9 (28-Dec-2013)filesystem: clean, 11/65536 files, 4443/262144 blocks</code></pre><h3 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h3><p>blkid: 查询或查看磁盘设备的相关属性 UUID、TYPE（文件系统）、LABEL</p><pre><code>[root@localhost ~]# blkid/dev/sda1: UUID=&quot;63389af9-2128-4b68-b072-0b3d7aaca50d&quot; TYPE=&quot;xfs&quot; /dev/sda2: UUID=&quot;UN0Ex0-C5Bz-oeCn-RbEP-RR1a-x79t-Ikyjh3&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb1: UUID=&quot;224f048a-76cf-4320-89b8-4458d6b96def&quot; TYPE=&quot;ext2&quot; /dev/sr0: UUID=&quot;2019-09-11-18-50-31-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; /dev/mapper/centos-root: UUID=&quot;827a53b1-31be-4ab8-b5a2-3310ee209a81&quot; TYPE=&quot;xfs&quot; /dev/mapper/centos-swap: UUID=&quot;f03a485d-b51a-4f0a-ad29-1262c359686f&quot; TYPE=&quot;swap&quot; </code></pre><p>e2label: 用于查看或定义卷标（应该只能查看ext格式的文件系统）</p><pre><code>e2label 设备文件 卷标: 设定卷标[root@localhost ~]# e2label /dev/sdb1 filesystem[root@localhost ~]# e2label /dev/sdb1filesystem</code></pre><p>tune2fs: 调整文件系统的相关属性</p><pre><code>-j: 不损害原有数据，将ext2升级为ext3；不能反方向执行-L LABEL: 设定或修改卷标; -m #: 调整预留百分比；（预留给超级用户）-r #: 指定预留块数；（预留给超级用户）-o: 设定默认挂载选项；    acl 开启文件系统acl选项-c #：指定挂载次数达到#次之后进行自检，0或-1表关闭此功能；-i #: 每挂载使用多少天后进行自检；0或-1表示关闭此功能；-l: 显示超级块中的信息；[root@localhost ~]# tune2fs -l /dev/sdb1tune2fs 1.42.9 (28-Dec-2013)Filesystem volume name:   filesystemLast mounted on:          &lt;not available&gt;Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96defFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_fileFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              65536Block count:              262144Reserved block count:     13107Free blocks:              257701Free inodes:              65525First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      63Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Filesystem created:       Sun Dec 26 07:12:40 2021Last mount time:          n/aLast write time:          Sun Dec 26 07:24:57 2021Mount count:              0Maximum mount count:      -1Last checked:             Sun Dec 26 07:12:40 2021Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:          256Required extra isize:     28Desired extra isize:      28Default directory hash:   half_md4Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4f</code></pre><p>dumpe2fs: 显示文件系统属性信息</p><pre><code>-h: 只显示超级块中的信息[root@localhost ~]# dumpe2fs /dev/sdb1dumpe2fs 1.42.9 (28-Dec-2013)Filesystem volume name:   filesystemLast mounted on:          &lt;not available&gt;Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96defFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_fileFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              65536Block count:              262144Reserved block count:     13107Free blocks:              257701Free inodes:              65525First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      63Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Filesystem created:       Sun Dec 26 07:12:40 2021Last mount time:          n/aLast write time:          Sun Dec 26 07:24:57 2021Mount count:              0Maximum mount count:      -1Last checked:             Sun Dec 26 07:12:40 2021Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:          256Required extra isize:     28Desired extra isize:      28Default directory hash:   half_md4Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4fGroup 0: (Blocks 0-32767)  Primary superblock at 0, Group descriptors at 1-1  Reserved GDT blocks at 2-64  Block bitmap at 65 (+65), Inode bitmap at 66 (+66)  Inode table at 67-578 (+67)  32183 free blocks, 8181 free inodes, 2 directories  Free blocks: 585-32767  Free inodes: 12-8192Group 1: (Blocks 32768-65535)  Backup superblock at 32768, Group descriptors at 32769-32769  Reserved GDT blocks at 32770-32832  Block bitmap at 32833 (+65), Inode bitmap at 32834 (+66)  Inode table at 32835-33346 (+67)  32189 free blocks, 8192 free inodes, 0 directories  Free blocks: 33347-65535  Free inodes: 8193-16384</code></pre><p>xfs_admin:修改xfs文件系统：</p><pre><code>[root@study ~]# xfs_admin [-lu] [-L label] [-U uuid] 设备文件名选项与参数：-l ：列出这个设备的 label name-u ：列出这个设备的 UUID-L ：设置这个设备的 Label name-U ：设置这个设备的 UUID 喔！范例：设置 /dev/vda4 的 label name 为 vbird_xfs，并测试挂载[root@study ~]# xfs_admin -L vbird_xfs /dev/vda4writing all SBsnew label = &quot;vbird_xfs&quot; # 产生新的 LABEL 名称啰！[root@study ~]# xfs_admin -l /dev/vda4label = &quot;vbird_xfs&quot;[root@study ~]# mount LABEL=vbird_xfs /data/xfs/范例：利用 uuidgen 产生新 UUID 来设置 /dev/vda4，并测试挂载[root@study ~]# umount /dev/vda4 # 使用前，请先卸载！[root@study ~]# uuidgene0fa7252-b374-4a06-987a-3cb14f415488 # 很有趣的指令！可以产生新的 UUID 喔！[root@study ~]# xfs_admin -u /dev/vda4UUID = e0a6af55-26e7-4cb7-a515-826a8bd29e90[root@study ~]# xfs_admin -U e0fa7252-b374-4a06-987a-3cb14f415488 /dev/vda4Clearing log and setting UUIDwriting all SBsnew UUID = e0fa7252-b374-4a06-987a-3cb14f415488[root@study ~]# mount UUID=e0fa7252-b374-4a06-987a-3cb14f415488 /data/x</code></pre><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载：将新的文件系统关联至当前根文件系统，挂载完成后，要通过挂载点访问对应文件系统上的文件；</p><p>卸载：将某文件系统与当前根文件系统的关联关系预以移除；</p><p>mount：挂载</p><pre><code>mount 设备 挂载点    设备：        设备文件：/dev/sda5        卷标：LABEL=“”        UUID： UUID=“”    挂载点：目录        要求：            1、此目录没有被其它进程使用；            2、目录得事先存在；            3、目录中的原有的文件将会暂时隐藏；mount [options] [-o options] DEVICE MOUNT_POINT    -a: 表示挂载/etc/fstab文件中定义的所有文件系统    -n: 默认情况下，mount命令每挂载一个设备，都会把挂载的设备信息保存至/etc/mtab文件；使用—n选项意味着挂载设备时，不把信息写入此文件；    -t FSTYPE: 指定正在挂载设备上的文件系统的类型；不使用此选项时，mount会调用blkid命令获取对应文件系统的类型；    -r: 只读挂载，挂载光盘时常用此选项    -w: 读写挂载        -o: 指定额外的挂载选项，也即指定文件系统启用的属性；        remount: 重新挂载当前文件系统        ro: 挂载为只读        rw: 读写挂载</code></pre><p>umount: 卸载某文件系统</p><pre><code>umount 设备umount 挂载点卸载注意事项：    挂载的设备没有进程使用；</code></pre><p>mount -o loop 文件地址 MOUNT_POINT: 挂载本地回环设备（比如iso文件）</p><p>文件系统的配置文件&#x2F;etc&#x2F;fstab  </p><pre><code>OS在初始时，会自动挂载此文件中定义的每个文件系统要挂载的设备挂载点文件系统类型挂载选项（文件系统选项）转储频率(每多少天做一次完全备份)文件系统检测次序(只有根可以为1)/dev/sda5/mnt/testext3defaults0 0文件系统参数：async/sync 非同步/同步        设置磁盘是否以非同步方式运行！默认为 async（性能较佳）auto/noauto 自动/非自动    当下达 mount -a 时，此文件系统是否会被主动测试挂载。默认为 auto。rw/ro 可读写/只读    让该分区以可读写或者是只读的型态挂载上来，如果你想要分享的数据是不给使用者随意变更的， 这里也能够设置为只读。则不论在此文件系统的文件是否设置 w 权限，都无法写入喔！exec/noexec可执行/不可执行    限制在此文件系统内是否可以进行“执行”的工作？如果是纯粹用来储存数据的目录, 那么可以设置为 noexec 会比较安全。不过，这个参数也不能随便使用，因为你不知道该目录下是否默认会有可执行文件。举例来说，如果你将 noexec 设置在 /var ，当某些软件将一些可执行文件放置于 /var 下时，那就会产生很大的问题喔！ 因此，建议这个 noexec 最多仅设置于你自订或分享的一般数据目录。user/nouser允许/不允许    使用者挂载是否允许使用者使用 mount指令来挂载呢？一般而言，我们当然不希望一般身份的 user 能使用 mount 啰，因为太不安全了，因此这里应该要设置为 nouser 啰！suid/nosuid具有/不具有suid 权限    该文件系统是否允许 SUID 的存在？如果不是可执行文件放置目录，也可以设置为 nosuid 来取消这个功能！defaults 同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。默认情况使用 defaults 设置即可！</code></pre><p>mount -a：挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统  </p><p>fuser: 验正进程正在使用的文件或套接字文件  </p><pre><code>-v: 查看某文件上正在运行的进程-k: 杀死访问进程的文件-m: 指定MOUNT_POINTfuser -km MOUNT_POINT：终止正在访问此挂载点的所有进程</code></pre><h3 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h3><p>Swap（交换分区）：把不常访问的内存先写到磁盘中，然后释放这些内存，给其它更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</p><p>free :查看内存容量  </p><pre><code>-m ：以M为单位显示-g ：以g为单位显示-h ：单位换算[demo@localhost ~]$ free -h              total        used        free      shared  buff/cache   availableMem:           972M        625M        122M         16M        225M        191MSwap:          2.0G         51M        1.9Gfree是真正尚未被使用的物理内存数量。avaliable是从应用程序的角度看到的可用内存数量。Linux内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的buffer和cache。所以对于内核来说，buffer和cache都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的free内存可以用，内核就会从buffer和cache中回收内存来满足应用程序的请求。</code></pre><h4 id="创建swap实体分区"><a href="#创建swap实体分区" class="headerlink" title="创建swap实体分区"></a>创建swap实体分区</h4><ol><li><p>在硬盘中创建Swap分区</p></li><li><p>调整Swap分区类型为82</p><pre><code>fdisk 调整分区类型为 82gdisk 调整为8200</code></pre></li><li><p>开始创建Swap格式</p><pre><code> mkswap /dev/sda8  创建交换分区：      -L LABEL [root@localhost ~]# free          total        used        free      shared  buff/cache   availableMem:         995748      648288       73440       17184      274020      187264Swap:       2097148       51976     2045172</code></pre></li><li><p>开启Swap分区</p><pre><code> swapon /dev/sda8  开启交换分区 -a: 启用所有的定义在/etc/fstab文件中的交换设备 -s: 查看交换分区由哪些文件或者分区组成 [root@localhost ~]# swapon /dev/sdb5 [root@localhost ~]# free -h total        used        free      shared  buff/cache   available Mem:           972M        633M         71M         16M        267M        182M Swap:          3.0G         50M        3.0G [root@localhost var]# swapon -s FilenameType Size UsedPriority /dev/dm-1              partition   2097148 30652   -2 /var/swapfile           file   1048572   0      -3</code></pre></li></ol><p>swapoff &#x2F;dev&#x2F;sda8 关闭交换分区  </p><h4 id="创建swap文件分区"><a href="#创建swap文件分区" class="headerlink" title="创建swap文件分区"></a>创建swap文件分区</h4><p>如何在一个分区中创建一个文件，并把它添加到swap交换分区中  </p><blockquote><p>回环设备loopback, 使用软件来模拟实现硬件</p></blockquote><p>dd ： 读取、转换并输出数据</p><pre><code>if=数据来源of=数据存储目标bs=1 读取或输出的块大小count=2 拷贝多少个块seek=#: 创建数据文件时，创建文件跳过的空间大小dd if=/dev/sda of=/mnt/usb/mbr.backup bs=512 count=1dd if=/mnt/usb/mbr.backup of=/dev/sda bs=512 count=1</code></pre><p>首先，创建一个镜像文件：&#x2F;dev&#x2F;zero 读出的都是0</p><pre><code>dd if=/dev/zero of=/var/swapfile bs=1M count=1024 </code></pre><p>其次，将文件创建为swap分区</p><pre><code>[root@localhost var]# mkswap /var/swapfile Setting up swapspace version 1, size = 1048572 KiBno label, UUID=86213827-3a91-4171-9892-e9c8efd42e2b</code></pre><p>最后，开启swap分区文件</p><pre><code>[root@localhost var]# swapon /var/swapfileswapon: /var/swapfile: insecure permissions 0644, 0600 suggested.[root@localhost var]# free -h              total        used        free      shared  buff/cache   availableMem:           972M        631M         67M         16M        274M        182MSwap:          3.0G         50M        3.0G</code></pre><h3 id="xfs文件备份与还原"><a href="#xfs文件备份与还原" class="headerlink" title="xfs文件备份与还原"></a>xfs文件备份与还原</h3><h4 id="xfsdump备份"><a href="#xfsdump备份" class="headerlink" title="xfsdump备份"></a>xfsdump备份</h4><p>xfsdumcp是xfs文件系统备份工具，可以进行完整备份和增量备份。同时xfsdumcp是通过文件系统的UUID来分辨各个备份文件的，因此不能备份两个具有相同UUID的文件系统。</p><pre><code>[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据选项与参数：-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ （默认为 0，即完整备份）-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 设备文件名或其他一般文件文件名等-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态</code></pre><p>完整备份</p><pre><code># 1\. 先确定 /boot 是独立的文件系统喔！[root@study ~]# df -h /bootFilesystem Size Used Avail Use% Mounted on/dev/vda2 1014M 131M 884M 13% /boot # 挂载 /boot 的是 /dev/vda 设备！# 看！确实是独立的文件系统喔！ /boot 是挂载点！# 2\. 将完整备份的文件名记录成为 /srv/boot.dump ：[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /bootxfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /bootxfsdump: using file dump （drive_simple） strategyxfsdump: version 3.1.4 （dump format 3.0） - type ^C for status and controlxfsdump: level 0 dump of study.centos.vbird:/boot # 开始备份本机/boot系统xfsdump: dump date: Wed Jul 1 18:43:04 2015 # 备份的时间xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1 # 这次dump的IDxfsdump: session label: &quot;boot_all&quot; # 简单给予一个名字记忆xfsdump: ino map phase 1: constructing initial dump list # 开始备份程序xfsdump: ino map phase 2: skipping （no pruning necessary）xfsdump: ino map phase 3: skipping （only one dump stream）xfsdump: ino map construction completexfsdump: estimated dump size: 103188992 Bytesxfsdump: creating dump session media file 0 （media 0, file 0）xfsdump: dumping ino mapxfsdump: dumping directoriesxfsdump: dumping non-directory filesxfsdump: ending media filexfsdump: media file size 102872168 Bytesxfsdump: dump size （non-dir files） : 102637296 Bytesxfsdump: dump complete: 1 seconds elapsedxfsdump: Dump Summary:xfsdump: stream 0 /srv/boot.dump OK （success）xfsdump: Dump Status: SUCCESS# 在指令的下达方面，你也可以不加 -L 及 -M 的，只是那就会进入互动模式，要求你 enter！# 而执行 xfsdump 的过程中会出现如上的一些讯息，您可以自行仔细的观察！[root@study ~]# ll /srv/boot.dump-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump[root@study ~]# ll /var/lib/xfsdump/inventory-rw-r--r--. 1 root root 5080 Jul 1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj-rw-r--r--. 1 root root 312 Jul 1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex-rw-r--r--. 1 root root 576 Jul 1 18:43 fstab# 使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔！</code></pre><p>累积备份</p><pre><code># 0\. 看一下有没有任何文件系统被 xfsdump 过的数据？[root@study ~]# xfsdump -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:43:04 2015session label: &quot;boot_all&quot;session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1level: 0resumed: NOsubtree: NOstreams: 1stream 0:pathname: /srv/boot.dumpstart: ino 132 offset 0end: ino 2138243 offset 0interrupted: NOmedia files: 1media file 0:mfile index: 0mfile type: datamfile size: 102872168mfile start: ino 132 offset 0mfile end: ino 2138243 offset 0media label: &quot;boot_all&quot;media id: a6168ea6-1ca8-44c1-8d88-95c863202eabxfsdump: Dump Status: SUCCESS# 我们可以看到目前仅有一个 session 0 的备份数据而已！而且是 level 0 喔！# 1\. 先恶搞一下，创建一个大约 10 MB 的文件在 /boot 内：[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=1010+0 records in10+0 records out10485760 Bytes （10 MB） copied, 0.166128 seconds, 63.1 MB/s# 2\. 开始创建差异备份文件，此时我们使用 level 1 吧：[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot....（中间省略）....[root@study ~]# ll /srv/boot*-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump-rw-r--r--. 1 root root 10510952 Jul 1 18:46 /srv/boot.dump1# 看看文件大小，岂不是就是刚刚我们所创建的那个大文件的容量吗？ ^_^# 3\. 最后再看一下是否有记录 level 1 备份的时间点呢？[root@study ~]# xfsdump -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2....（中间省略）....session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1resumed: NOsubtree: NOstreams: 1stream 0:pathname: /srv/boot.dump1start: ino 455518 offset 0....（下面省略）....</code></pre><h4 id="xfsrestore还原"><a href="#xfsrestore还原" class="headerlink" title="xfsrestore还原"></a>xfsrestore还原</h4><pre><code>[root@study ~]# xfsrestore -I &amp;lt;==用来察看备份文件数据[root@study ~]# xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录 &amp;lt;==单一文件全系统复原[root@study ~]# xfsrestore [-f 备份文件] -r 待复原目录 &amp;lt;==通过累积备份文件来复原系统[root@study ~]# xfsrestore [-f 备份文件] -i 待复原目录 &amp;lt;==进入互动模式选项与参数：-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等-f ：后面接的就是备份文件！企业界很有可能会接 /dev/st0 等磁带机！我们这里接文件名！-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，需要这东西来达成累积复原-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！</code></pre><p>用xfsrestore查看xfsdump备份数据</p><pre><code>[root@study ~]# xfsrestore -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:43:04 2015session label: &quot;boot_all&quot;session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1level: 0pathname: /srv/boot.dumpmfile size: 102872168media label: &quot;boot_all&quot;session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1pathname: /srv/boot.dump1mfile size: 10510952media label: &quot;boot_2&quot;xfsrestore: Restore Status: SUCCESS</code></pre><p>完全备份还原</p><pre><code># 1\. 直接将数据给它还原回去即可！[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/bootxfsrestore: using file dump （drive_simple） strategyxfsrestore: version 3.1.4 （dump format 3.0） - type ^C for status and controlxfsrestore: using online session inventoryxfsrestore: searching media for directory dumpxfsrestore: examining media file 0xfsrestore: reading directoriesxfsrestore: 8 directories and 327 entries processedxfsrestore: directory post-processingxfsrestore: restoring non-directory filesxfsrestore: restore complete: 1 seconds elapsedxfsrestore: Restore Summary:xfsrestore: stream 0 /srv/boot.dump OK （success） # 是否是正确的文件啊？xfsrestore: Restore Status: SUCCESS如果只想要复原某一个目录或文件的话，直接加上“ -s 目录 ”这个选项与参数即可！</code></pre><p>部分备份还原</p><pre><code># 继续复原 level 1 到 /tmp/boot 当中！[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot</code></pre><p>仅还原部分文件的 xfsrestore 互动模式</p><pre><code># 1\. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！[root@study ~]# mkdir /tmp/boot3[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3========================== subtree selection dialog ==========================the following commands are available:pwdls [ &amp;lt;path&amp;gt; ]cd [ &amp;lt;path&amp;gt; ]add [ &amp;lt;path&amp;gt; ] # 可以加入复原文件列表中delete [ &amp;lt;path&amp;gt; ] # 从复原列表拿掉文件名！并非删除喔！extract # 开始复原动作！quithelp-&amp;gt; ls455517 initramfs-3.10.0-229.el7.x86_64kdump.img138 initramfs-3.10.0-229.el7.x86_64.img141 initrd-plymouth.img140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img137 vmlinuz-3.10.0-229.el7.x86_64136 symvers-3.10.0-229.el7.x86_64.gz135 config-3.10.0-229.el7.x86_64134 System.map-3.10.0-229.el7.x86_64133 .vmlinuz-3.10.0-229.el7.x86_64.hmac1048704 grub2/131 grub/-&amp;gt; add grub-&amp;gt; add grub2-&amp;gt; add config-3.10.0-229.el7.x86_64-&amp;gt; extract[root@study ~]# ls -l /tmp/boot3-rw-r--r--. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64drwxr-xr-x. 2 root root 26 May 4 17:52 grubdrwxr-xr-x. 6 root root 104 Jun 25 00:02 grub2# 就只会有 3 个文件名被复原，当然，如果文件名是目录，那下面的子文件当然也会被还原回来的！</code></pre><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>RAID中文名称为独立磁盘冗余阵列，简称为磁盘阵列。简单的说，RAID是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。RAID的主要优势有如下几点：大容量、高性能、可靠性、可管理性（它将多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器）。实现RAID的关键技术为镜像、数据条带、数据校验技术。RAID的每种级别仅代表磁盘组织方式不同，没有上下之分。  </p><p>一般来说， RAID 不可作为数据备份的替代方案，它对非磁盘故障等造成的数据丢失无能为力，比如病毒、人为破坏、意外删除等情形。此时的数据丢失是相对操作系统、文件系统、卷管理器或者应用系统来说的，对于 RAID 系统来身，数据都是完好的，没有发生丢失。所以，数据备份、灾 备等数据保护措施是非常必要的，与 RAID 相辅相成，保护数据在不同层次的安全性，防止发生数据丢失。</p><p>从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及软硬混合 RAID 三种。软 RAID 所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片，效率自然最低。硬 RAID 配备了专门的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片以及阵列缓冲，不占用 CPU 资源，但成本很高。软硬混合 RAID 具备 RAID 控制 &#x2F; 处理芯片，但缺乏 I&#x2F;O 处理芯片，需要 CPU 和驱动程序来完成，性能和成本 在软 RAID 和硬 RAID 之间。不建议使用软RAID。</p><p>常见raid级别如下，具体可参见文章<a href="https://blog.csdn.net/ensp1/article/details/81318135">https://blog.csdn.net/ensp1/article/details/81318135</a>，以上关于raid内容也是摘取自这篇文章。</p><h4 id="raid-0"><a href="#raid-0" class="headerlink" title="raid 0"></a>raid 0</h4><p>raid 0基于条带化技术。将数据按照stripe大小切分之后存放到各磁盘中</p><p><img src="https://img-blog.csdnimg.cn/20200701102411750.png" alt="image"></p><pre><code>    性能提升: 读，写    冗余能力（容错能力）: 无    空间利用率：nS    至少2块盘</code></pre><h4 id="raid-1"><a href="#raid-1" class="headerlink" title="raid 1"></a>raid 1</h4><p>raid 1基于镜像技术。将数据复制为N份存放到各磁盘中。</p><p><img src="https://img-blog.csdnimg.cn/20200701102427735.png" alt="image"></p><pre><code>    性能表现：写性能下降，读性能提升    冗余能力：有    空间利用率：1/2    至少2块盘</code></pre><h4 id="raid-5"><a href="#raid-5" class="headerlink" title="raid 5"></a>raid 5</h4><p>raid 5采用的是条带化和校验技术。将数据按照stripe大小切分并且计算数据校验信息然后分别存放到各磁盘中。当一个磁盘损坏后可以根据其它磁盘数据进行恢复，而且该技术中校验信息不是存放到固定磁盘中的。</p><p><img src="https://img-blog.csdnimg.cn/20200701102535811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vuc3Ax,size_16,color_FFFFFF,t_70" alt="image"></p><pre><code>    性能表现：读，写提升    冗余能力：有    空间利用率：(n-1)/n    至少需要3块</code></pre><p>raid 5 并发问题<a href="https://forum.huawei.com/enterprise/zh/thread/580916590801731584">https://forum.huawei.com/enterprise/zh/thread/580916590801731584</a></p><h4 id="raid10"><a href="#raid10" class="headerlink" title="raid10"></a>raid10</h4><p>raid 10 从下往上是先采用raid 1的镜像技术，再采用raid 0 的条带化技术。</p><p><img src="https://img-blog.csdnimg.cn/2020070110262565.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：1/2    至少需要4块</code></pre><h4 id="raid-01"><a href="#raid-01" class="headerlink" title="raid 01"></a>raid 01</h4><p>raid 01 从下往上是先采用raid 0的条带化技术，再采用raid 1的镜像技术。<br><img src="https://img-blog.csdnimg.cn/20200701102612237.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：1/2    至少需要4块</code></pre><h4 id="raid-50"><a href="#raid-50" class="headerlink" title="raid 50"></a>raid 50</h4><p>raid 50 从下往上是先采用raid 5技术，再采用raid 0 技术。<br><img src="https://img-blog.csdnimg.cn/20200701102710274.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：(n-2)/n    至少需要6块</code></pre><h4 id="jbod"><a href="#jbod" class="headerlink" title="jbod"></a>jbod</h4><p>jbod并不是一个raid技术，它仅仅只是将几个磁盘组成一个大的存储设备。</p><p><img src="https://img-blog.csdnimg.cn/20200701102345894.png" alt="image"></p><pre><code>    性能表现：无提升    冗余能力：无    空间利用率：100%    至少需要2块</code></pre><h4 id="软件raid练习"><a href="#软件raid练习" class="headerlink" title="软件raid练习"></a>软件raid练习</h4><p>以下我们使用逻辑RAID作为练习，软件RAID在Linux中的设备名为&#x2F;dev&#x2F;md</p><p>mdadm：将任何块设备做成RAID </p><pre><code>模式化的命令：    创建模型        -C             专用选项：                -l: 级别                -n #: 设备个数（raid使用的磁盘数量）                -a &#123;yes|no&#125;: 是否自动为其创建设备文件                -c: CHUNK大小, 2^n，默认为64K                -x #: 指定空闲盘个数    管理模式        --add,         --remove,         --fail        mdadm /dev/md# --fail /dev/sda7    监控模式        -F：    增长模式        -G：    装配模式        -A:</code></pre><p>查看RAID阵列的详细信息</p><pre><code>mdadm -D /dev/md#    --detail</code></pre><p>停止阵列：</p><pre><code>mdadm -S /dev/md#    --stop</code></pre><p>将当前RAID信息保存至配置文件，以便以后进行装配：</p><pre><code>mdamd -D --scan &gt; /etc/mdadm.conf</code></pre><p>使用软raid操作如下：</p><pre><code>1. 在磁盘/dev/sdb上创建四个磁盘分区（6，7,8,9），每个分区的类型修改为fd[root@localhost var]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nAll primary partitions are in useAdding logical partition 6First sector (8394752-41943039, default 8394752): Using default value 8394752Last sector, +sectors or +size&#123;K,M,G&#125; (8394752-41943039, default 41943039): +1GPartition 6 of type Linux and of size 1 GiB is setCommand (m for help): tPartition number (1-8, default 8): fdPartition number (1-8, default 8): 6Hex code (type L to list all codes): fdChanged type of partition &#39;Linux&#39; to &#39;Linux raid autodetect&#39;2. 使用mdadm命令创建raid[root@localhost dev]# mdadm -C /dev/md0 -l 1 -n 2 -a yes -x 1 /dev/sdb&#123;6,7,8&#125;mdadm: Note: this array has metadata at the start and    may not be suitable as a boot device.  If you plan to    store &#39;/boot&#39; on this device please ensure that    your boot-loader understands md/v1.x metadata, or use    --metadata=0.90   （软raid不能作为启动分区）Continue creating array? Continue creating array? (y/n) ymdadm: Defaulting to version 1.2 metadatamdadm: array /dev/md0 started.[root@localhost dev]# ll -d /dev/md*brw-rw----. 1 root disk 9, 0 Jan  1 04:42 /dev/md03. 在raid上创建文件系统[root@localhost dev]# mke2fs /dev/md0mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65408 inodes, 261632 blocks13081 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8176 inodes per groupSuperblock backups stored on blocks:     32768, 98304, 163840, 229376Allocating group tables: done                            Writing inode tables: done                            Writing superblocks and filesystem accounting information: done4. 挂载文件系统[root@localhost dev]# mount /dev/md0 /mnt5. 拷贝并查看文件[root@localhost mnt]# cp /etc/inittab ./[root@localhost mnt]# lltotal 20-rw-r--r--. 1 root root   511 Jan  1 04:47 inittabdrwx------. 2 root root 16384 Jan  1 04:46 lost+found[root@localhost mnt]# cat inittab # inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM....6. 查看raid信息[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:           Version : 1.2     Creation Time : Sat Jan  1 04:42:17 2022        Raid Level : raid1        Array Size : 1046528 (1022.00 MiB 1071.64 MB)     Used Dev Size : 1046528 (1022.00 MiB 1071.64 MB)      Raid Devices : 2     Total Devices : 3       Persistence : Superblock is persistent       Update Time : Sat Jan  1 04:47:39 2022             State : clean     Active Devices : 2   Working Devices : 3    Failed Devices : 0     Spare Devices : 1Consistency Policy : resync              Name : localhost.localdomain:0  (local to host localhost.localdomain)              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72            Events : 17    Number   Major   Minor   RaidDevice State       0       8       22        0      active sync   /dev/sdb6       1       8       23        1      active sync   /dev/sdb7       2       8       24        -      spare   /dev/sdb87. 查看raid状态    cat /proc/mdstat8. 将sdb6标识为损坏[root@localhost mnt]# mdadm /dev/md0 --fail /dev/sdb6mdadm: set /dev/sdb6 faulty in /dev/md0[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                    ...                    ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       0       8       22        -      faulty   /dev/sdb69. 在raid中移除sdb6[root@localhost mnt]# mdadm /dev/md0 --remove /dev/sdb6mdadm: hot removed /dev/sdb6 from /dev/md0[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                        ...                        ...Consistency Policy : resync              Name : localhost.localdomain:0  (local to host localhost.localdomain)              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72            Events : 37    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb710. 查看文件[root@localhost mnt]# cat inittab     # inittab is no longer used when using systemd.    #    # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.    ...  11. 在raid中添加磁盘[root@localhost mnt]# mdadm /dev/md0 --add /dev/sdb9mdadm: added /dev/sdb9[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                            ...                            ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       3       8       25        -      spare   /dev/sdb912. 停止raid[root@localhost /]# umount /dev/md0[root@localhost /]# mdadm -S /dev/md0mdadm: stopped /dev/md013. 重新挂载停止的raid[root@localhost /]# mdadm -A /dev/md0 /dev/sdb&#123;7,8,9&#125;mdadm: /dev/md0 has been started with 2 drives and 1 spare.[root@localhost /]# mdadm -D /dev/md0/dev/md0:                        ...                    ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       3       8       25        -      spare   /dev/sdb9 14. 查看文件 [root@localhost mnt]# cat inittab  # inittab is no longer used when using systemd. # # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.                         ... 15. 增长模式（将raid的热备磁盘增加到阵列工作磁盘中） mdadm -G /dev/md0 -n 4</code></pre><p>watch: 周期性地执行指定命令，并以全屏方式显示结果  </p><pre><code>-n #：指定周期长度，单位为秒，默认为2格式： watch -n # &#39;COMMAND&#39;</code></pre><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>LVM是逻辑卷管理，它是Linux下磁盘分区的一种管理机制。该功能可以实现用户在无需停机的情况下可以调整各个分区的大小。</p><ul><li>PV(物理卷): 对应于我们的实体分区或硬盘</li><li>VG(卷  组): PV的组合</li><li>LV(逻辑卷): VG会被切成LV.这个LV就是最后格式化后给用户使用的。</li><li>PE(物理盘区): LVM管理的基础存储单元。LVM会把PV分成一个个PE进行存储。</li></ul><p>VG(卷组)的边界大小取决于PV(物理卷)组合的大小。</p><p>虽然PV组合成了VG，但是要真正使用就要划分LV(逻辑卷).在VG上可以划分多个LV，但这多个LV的大小加起来的和不能超过VG。如果发现VG不够用了，可以增加PV（物理卷），如果LV中空间不足可以扩大LV。</p><p>对卷创建快照，实际上就是对逻辑卷创建快照，而快照卷必须和逻辑卷处于同一个卷组中。也就意味这，如果你要打算对某个LV逻辑卷创建快照，就必须在同一个卷组中预留出空间给其中的某个逻辑卷创建快照卷。</p><blockquote><p>为什么能够实现VG的扩展以及LV的扩展？其实将PV放入VG时就要把PV这个物理卷的所有空间划分成一个物理块，及一个个存储单元。 这个块不是文件系统块，而是PE(PhysicalExtend物理盘区)，只要物理卷加入VG后，新加卷中划分的PE一定是和VG原因的PE大小相同。所以在创建VG时要制定VG所使用多大的PE。</p></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>【MD】:Multi Device 多设备</p><p>Mdadm是一个用户空间工具，是RAID的管理工具，与真正的RAID工作没有太大关系。真正的RAID集成在linux内核中</p><p>【DM】Device Mapper设备映射也是linux中一种常用的管理机制</p><p>DM 与MD近似，也能够提供一种逻辑设备。DM比MD的功能要强大。因为DM不仅仅能提供MD的RAID的功能，它还是逻辑卷（LVM2）基础。同时，在逻辑卷的基础上我们也能实现RAID0,RAID1这样的功能。DM与MD中有某些功能是重叠的，但并不完全重叠。所以，我们通常使用MD做RAID用DM做LVM2。DM像MD一样也是有一个核心模块，和许多子模块组成的。例如MD的核心有RAID0,RAID1,RAID5,RAID1+0等，由多个子模块完成不同的级别。DM也是有多个子模块完成不同的组织方式。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB89700cb2e26795cf3122f1060d00709e?method=download&shareKey=69125b23b714204d3f30cced62ae321b" alt="image"></p><p>例如：</p><ul><li>linear:有点类似Jbod。能够将多个磁盘的存储空间拼接在一块，当做一个磁盘来使用。</li><li>mirror:类似于镜像。</li><li>Snapshot：快照，向虚拟机一样，能够保留数据在做快照那一刻时的状态。快照，也可以说是访问同一条数据的另外一条路径。（主要用途是数据备份）</li><li>Multipath：多路径。多路径需要借助于DM模块来配置，能够实现数据存储设备的寻路能够通过多跟不同线来完成。</li></ul><h3 id="LVM使用流程"><a href="#LVM使用流程" class="headerlink" title="LVM使用流程"></a>LVM使用流程</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd1ecce605925715ca45bf008c7828c25?method=download&shareKey=40e1bb6104763d539a75435d5898d461" alt="image"></p><h3 id="LVM相关操作"><a href="#LVM相关操作" class="headerlink" title="LVM相关操作"></a>LVM相关操作</h3><p><a href="https://www.cnblogs.com/klb561/p/9074168.html">https://www.cnblogs.com/klb561/p/9074168.html</a></p><p>练习：<br>1、创建一个2G的分区，文件系统为ext2，卷标为DATA，块大小为1024，预留管理空间为磁盘分区的8%；挂载至&#x2F;backup目录，要求使用卷标进行挂载，且在挂载时启动此文件系统上的acl功能；</p><pre><code># mke2fs -L DATA -b 1024 -m 8  /dev/sda7# mount -o acl LABEL=DATA /backup# tune2fs -o acl /dev/sda7# mount LABEL=DATA /backup</code></pre><p>2、将此文件系统的超级块中的信息中包含了block和inode的行保存至&#x2F;tmp&#x2F;partition.txt中；</p><pre><code># tune2fs -l | egrep -i  &quot;block|inode&quot; &gt;&gt; /tmp/partition.txt  # dumpe2fs -h |</code></pre><p>3、复制&#x2F;etc目录中的所有文件至此文件系统；而后调整此文件系统类型为ext3，要求不能损坏已经复制而来的文件；</p><pre><code># cp -r /etc/*  /backup# tune2-j /dev/sda7</code></pre><p>4、调整其预留百分比为3%；</p><pre><code># tune2fs -m 3 -L DATA /dev/sda7</code></pre><p>5、以重新挂载的方式挂载此文件系统为不更新访问时间戳(表示在读文件时不去更改文件的access time属性），并验正其效果；</p><pre><code># stat /backup/inittab# cat /backup/inittab# stat # mount -o remount,noatime /backup# cat # stat</code></pre><p>6、对此文件系统强行做一次检测；</p><pre><code>e2fsck -f /dev/sda7</code></pre><p>7、删除复制而来的所有文件，并将此文件系统重新挂载为同步(sync)；而后再次复制&#x2F;etc目录中的所有文件至此挂载点，体验其性能变化；</p><pre><code># rm -rf /backup/*# mount -o remount,sync /backup# cp -r /etc/* /backup</code></pre><p>8、创建一个5G的分区，文件系统为ext3，卷标为MYDATA，块大小为1024，预留管理空间为磁盘分区的3%，要求开机后可以自动挂载至&#x2F;data目录，并且自动挂载的设备要使用卷标进行引用；</p><p>9、创建一个本地回环文件&#x2F;var&#x2F;swaptemp&#x2F;swapfile来用于swap，要求大小为512MB，卷标为SWAP-FILE，且开机自动启用此交换设备；</p><pre><code># mkdir /var/swaptemp# dd if=/dev/zero of=/var/swaptemp/swapfile bs=1M count=512# mkswap LABLE=SWAP-FILE /var/swaptemp/swapfile/etc/fstab/var/swaptemp/swapfile  swapswapdefaults0 0</code></pre><p>10、上述第一问，如何让其自动挂载的同时启用ACL功能；</p><pre><code>/etc/fstabLABEL=&#39;MYDATA&#39;/dataext3defaults,acl0 0</code></pre><p>11、 创建一个空间大小为10G的RAID5设备；其chuck大小为32k；要求此设备开机时可以自动挂载至&#x2F;backup目录；</p><p>12、练习：创建一个由两个物理卷组成的大小为20G的卷组myvg，要求其PE大小为16M；而后在此卷组中创建一个大小为5G的逻辑卷lv1，此逻辑卷要能在开机后自动挂载至&#x2F;users目录，且支持ACL功能；</p><p>13、缩减前面创建的逻辑卷lv1的大小至2G；</p><p>写一个脚本(前提：请为虚拟机新增一块硬盘，假设它为&#x2F;dev&#x2F;sdb)，为指定的硬盘创建分区： </p><p>1、列出当前系统上所有的磁盘，让用户选择，如果选择quit则退出脚本；如  果用户选择错误，就让用户重新选择；</p><p>2、当用户选择后，提醒用户确认接下来的操作可能会损坏数据，并请用户确认；如果用户选择y就继续，n就退出；否则，让用户重新选择；  </p><p>3、抹除那块硬盘上的所有分区(提示，抹除所有分区后执行sync命令，并让脚本睡眠3秒钟后再分区)；并为其创建三个主分区，第一个为20M，第二个为512M, 第三个为128M，且第三个为swap分区类型；(提示：将分区命令通过echo传送给fdisk即可实现)  </p><pre><code>fdisk -l |grep &quot;dd if=/dev/zero of=/dev/sdb bs=512 count=1sync （程序在运行过程中会先修改内存，到达一定限制后才会从内存写入磁盘。此命令就是将内存中的改变写入磁盘）sleep 3（dd修改硬盘速度很快，防止磁盘接受指令过快导致不识别）</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p> 本文介绍了磁盘的组成、磁盘分区、文件系统、swap分区、xfs文件系统的备份和还原、raid、lvm相关内容。<p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 请描述一下MBR和GPT是什么？</p><p>3. CentOS7 为啥将默认文件系统改为xfs</p><p>4. raid？raid0？ raid1？ raid5？raid01？ raid10？</p><p>5. LVM的作用？LVM的组成？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 马哥Linux运维课程</p> <p>2. 鸟哥Linux私房菜-基础版</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="LVM" scheme="http://example.com/tags/LVM/"/>
    
    <category term="RAID" scheme="http://example.com/tags/RAID/"/>
    
    <category term="XFS" scheme="http://example.com/tags/XFS/"/>
    
    <category term="MBR" scheme="http://example.com/tags/MBR/"/>
    
    <category term="GPT" scheme="http://example.com/tags/GPT/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://example.com/2022/11/25/Linux-basic/"/>
    <id>http://example.com/2022/11/25/Linux-basic/</id>
    <published>2022-11-25T09:16:13.689Z</published>
    <updated>2022-11-25T09:16:13.688Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册</p></div><h2 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title="Linux的基本原则"></a>Linux的基本原则</h2><ul><li>一些皆文件</li><li>配置文件保存为纯文本格式</li><li>由目的单一的小程序组成，组合小程序完成复杂任务</li><li>尽量避免捕获用户接口（尽量减少与用户交互，比如如果命令运行成功则不会显示任何信息，没有消息是最好的消息）</li></ul><h2 id="Linux交互"><a href="#Linux交互" class="headerlink" title="Linux交互"></a>Linux交互</h2><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><p>Shell是用户和操作系统进行交互的软件。在Linux中它分为如下类型：  </p><blockquote><ul><li>GUI（图形界面交互）  <ul><li>Gnode  </li><li>KDE  </li><li>XFace</li></ul></li><li>CLI（命令行交互）  <ul><li>sh</li><li>bash</li><li>csh</li><li>zsh</li><li>ksh</li><li>tcsh</li></ul></li></ul></blockquote><p> 使用bash登陆Linux后会显示命令提示符（prompt）：</p><pre><code>[root@localhost ~]#    </code></pre><p>其中root是用户名，localhost是主机名，~代表家目录（&#x2F;代表根目录），#代表管理员（$代表普通用户）  </p><blockquote><p>虚拟终端(terminal)：Ctrl+Alt+F1-F6。Linux中有六个虚拟终端，每个虚拟终端都是一个Shell程序。一个用户可以在多个虚拟终端中同时登陆互不影响。CentOS 7之前可以使用init 3命令将图形shell转换为命令行Shell，使用init 5则相反。CentOS 7之后使用systemctl isolate multi-user.target或者systemctl isolate graphical.target切换</p></blockquote><h3 id="bash特性"><a href="#bash特性" class="headerlink" title="bash特性"></a>bash特性</h3><p>1、命令历史、命令补全 </p><pre><code>  history：查看命令历史 -c：清空命令历史 -d OFFSET [n]: 删除指定位置的命令 -w：保存命令历史至历史文件中  HISTSIZE环境变量: 命令历史缓冲区大小 ~/.bash_history：命令历史文件路径 命令历史的使用技巧：  !n      ：执行命令历史中的第n条命令； !-n     :执行命令历史中的倒数第n条命令；  !!      : 执行上一条命令； !string ：执行命令历史中最近一个以指定字符串开头的命令 !$      :引用前一个命令的最后一个参数;  Esc, .  :引用前一个命令的最后一个参数，先按Esc，再按.； Alt+. :引用前一个命令的最后一个参数，只在linux终端中可以； 命令、路径补全： 命令补全：搜索PATH环境变量所指定的每个路径下以我们给出的字符串开头的可执行文件，如果多于一个，两次tab，可以给出列表；否则将直接补全； 路径补全：搜索我们给出的起始路径下的每个文件名，并试图补全；</code></pre><p>2、管道、重定向<br>3、命令别名  </p><pre><code>alias CMDALIAS=&#39;COMMAND [options] [arguments]&#39; 定义别名在shell中定义的别名仅在当前shell生命周期中有效；别名的有效范围仅为当前shell进程；ualias CMDALIAS 解除别名\CMD ： 执行原命令</code></pre><p>4、命令行编辑  </p><pre><code>光标跳转：  Ctrl+a：跳到命令行首Ctrl+e：跳到命令行尾Ctrl+u: 删除光标至命令行首的内容Ctrl+k: 删除光标至命令行尾的内容Ctrl+l: 清屏</code></pre><p>5、命令行展开  </p><pre><code>命令替换: $(COMMAND), 反引号：`COMMAND`把命令中某个子命令替换为其执行结果的过程,如：：file-2013-02-28-14-53-31.txtbash支持的引号：``: 命令替换&quot;&quot;: 弱引用，可以实现变量替换&#39;&#39;: 强引用，不完成变量替换命令行展开：&#123;a,d&#125;_&#123;b,c&#125;mkdir -pv /mnt/test/&#123;x/m,y&#125;cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>6、文件名通配  </p><pre><code> globbing *: 任意长度的任意字符 ?：任意单个字符 []：匹配指定范围内的任意单个字符     [abc], [a-m], [a-z], [A-Z], [0-9], [a-zA-Z], [0-9a-zA-Z]     [:space:]：空白字符     [:punct:]：标点符号     [:lower:]：小写字母     [:upper:]: 大写字母     [:alpha:]: 大小写字母     [:digit:]: 数字     [:alnum:]: 数字和大小写字母  # man 7 glob  [^]: 匹配指定范围之外的任意单个字符  [[:alpha:]]*[[:space:]]*[^[:alpha:]]  注：文件通配符并不能匹配所有情况，比如：显示所有以数字结尾且文件名中不包含空白的文件；ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>7、变量<br>8、编程  </p><blockquote><p>注：&#x2F;etc&#x2F;shells：指定了当前系统可用的安全shell  </p></blockquote><div class="note green icon-padding flat"><p>练习：</p><p>1、创建a123, cd6, c78m, c1 my, m.z, k 67, 8yu, 789等文件；注意，以上文件是以逗号隔开的，其它符号都是文件名的组成部分；  </p><p>2、显示所有以a或m开头的文件；  </p><pre><code>ls [am]*  </code></pre><p>3、显示所有文件名中包含了数字的文件； </p> <pre><code>ls *[0-9]*   ls *[[:digit:]]*  </code></pre><p>4、显示所有以数字结尾且文件名中不包含空白的文件； </p> <pre><code>ls *[^[:space:]]*[0-9]   ?????????  </code></pre><p>5、显示文件名中包含了非字母或数字的特殊符号的文件； </p> <pre><code>ls *[^[:alnum:]]*</code></pre></div><h3 id="登陆式shell和非登陆式shell"><a href="#登陆式shell和非登陆式shell" class="headerlink" title="登陆式shell和非登陆式shell"></a>登陆式shell和非登陆式shell</h3><p>站在用户登录的角度来说，SHELL的类型：</p><ul><li><p>登录式shell:</p><ul><li>正常通过某终端登录</li><li>su - USERNAME </li><li>su -l USERNAME</li></ul></li><li><p>非登录式shell:</p><ul><li>su USERNAME</li><li>图形终端下打开命令窗口</li><li>自动执行的shell脚本</li></ul></li></ul><p>bash的配置文件：</p><ul><li><p>全局配置</p><pre><code>  /etc/profile    /etc/profile.d/*.sh    /etc/bashrc </code></pre></li><li><p>个人配置</p><pre><code>  ~/.bash_profile   ~/.bashrc</code></pre></li></ul><p>profile类的文件：  </p><ul><li>设定环境变量</li><li>运行命令或脚本</li></ul><p>bashrc类的文件：  </p><ul><li>设定本地变量</li><li>定义命令别名</li></ul><p>登录式shell如何读取配置文件？  </p><pre><code>/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</code></pre><p>非登录式shell如何配置文件?</p><pre><code>~/.bashrc --&gt; /etc/basrc --&gt; /etc/profile.d/*.sh</code></pre><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><p>Linux的一级目录如下：  </p><ul><li>&#x2F;boot: 系统启动相关的文件，如内核、initrd，以及grub(bootloader)  </li><li>&#x2F;dev: 设备文件  </li><li>设备文件：  <ul><li>块设备：随机访问，数据块  </li><li>字符设备：线性访问，按字符为单位  </li><li>设备号：主设备号（major）和次设备号（minor）</li></ul></li><li>&#x2F;etc：配置文件  </li><li>&#x2F;home：用户的家目录，每一个用户的家目录通常默认为&#x2F;home&#x2F;USERNAME  </li><li>&#x2F;root：管理员的家目录；  </li><li>&#x2F;lib：库文件  <ul><li>静态库,  .a   </li><li>动态库， .dll, .so (shared object)</li></ul></li><li>&#x2F;lib&#x2F;modules：内核模块文件  </li><li>&#x2F;media：挂载点目录，移动设备  </li><li>&#x2F;mnt：挂载点目录，额外的临时文件系统  </li><li>&#x2F;opt：可选目录，第三方程序的安装目录  </li><li>&#x2F;proc：伪文件系统，内核映射文件  </li><li>&#x2F;sys：伪文件系统，跟硬件设备相关的属性映射文件  </li><li>&#x2F;tmp：临时文件, &#x2F;var&#x2F;tmp  </li><li>&#x2F;var：可变化的文件  </li><li>&#x2F;bin: 可执行文件, 用户命令  </li><li>&#x2F;sbin：管理命令</li></ul><p>&#x2F;usr：shared, read-only  </p><ul><li>&#x2F;usr&#x2F;bin  </li><li>&#x2F;usr&#x2F;sbin  </li><li>&#x2F;usr&#x2F;lib</li></ul><p>&#x2F;usr&#x2F;local：  </p><ul><li>&#x2F;usr&#x2F;local&#x2F;bin  </li><li>&#x2F;usr&#x2F;local&#x2F;sbin  </li><li>&#x2F;usr&#x2F;local&#x2F;lib</li></ul><p>Linux中文件命名规则：  </p><ol><li>长度不能超过255个字符；  </li><li>不能使用&#x2F;当文件名  </li><li>严格区分大小写</li></ol><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>1、命令格式：</p><blockquote><p>命令 选项 参数</p><p>选项  </p><ul><li>短选项：- (多个选项可以组合 -a -b &#x3D; -ab)</li><li>长选项：- -</li></ul><p>参数：命令的作用对象</p></blockquote><p>2、命令类型：  </p><ul><li>内置命令(shell内置)，内部，内建  </li><li>外部命令：在文件系统的某个路径下有一个与命令名称相应的可执行文件</li></ul><p>3、type: 显示指令属于哪种类型</p><pre><code>[root@localhost ~]# type lsls is aliased to `ls --color=auto&#39; (命令别名)[root@localhost ~]# type cdcd is a shell builtin  （内部命令）[root@localhost ~]# type vivi is /usr/bin/vi （外部命令，对应文件）</code></pre><p>4、环境变量：命名的内存空间  </p><pre><code>变量赋值:NAME=Jerry  PATH: 使用冒号分隔的路径，命令的默认搜索路径  </code></pre><h3 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h3><blockquote><p>获得命令的使用帮助：<br>内部命令：help COMMAND<br>外部命令：COMMAND –help<br>在线手册：info COMMAND  (不常用)<br>文    档：&#x2F;usr&#x2F;share&#x2F;doc<br>命令手册：man COMMAND  </p><p>注：帮助中符号的意思<br>&lt;&gt;：必选     [] ：可选    … : 可以出现多次     | ：多选一    {} ：分组  </p></blockquote><p>man [指定章节数字] COMMAND  </p><pre><code>[root@localhost ~]# man DATEDATE(1)（1代表章节）                                                            User Commands                                                                   DATE(1)NAME（命令名称及功能简要说明）       date - print or set the system date and timeSYNOPSIS（用法说明，包括可用的选项）       date [OPTION]... [+FORMAT]       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION（命令功能的详尽说明，可能包括每一个选项的意义）     OPTIONS：说明每一个选项的意义         Display the current time in the given FORMAT, or set the system date.       Mandatory arguments to long options are mandatory for short options too.       -d, --date=STRING              display time described by STRING, not &#39;now&#39;FILES：此命令相关的配置文件        ......BUGS：       ......EXAMPLES：使用示例        ......SEE ALSO：另外参照      ...... 注：man文档查看方法    翻屏：        向后翻一屏：SPACE        向前翻一屏：b        向后翻一行：ENTER        向前翻一行：k    查找：        /KEYWORD: 向后            n: 下一个            N：前一个             ?KEYWORD：向前        n: 下一个        N：前一个         q: 退出</code></pre><p>man帮助中分章节，每个章节中存放不同类型的命令。比如1和5章节中都包含passwd。man命令如果不指定章节数，则默认显示最小章节的命令。查看5章节的passwd帮助使用man 5 passwd：  </p><ul><li>1：用户命令(&#x2F;bin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;bin)  </li><li>2：系统调用  </li><li>3：库用户  </li><li>4：特殊文件(设备文件)  </li><li>5：文件格式(配置文件的语法)  </li><li>6：游戏  </li><li>7：杂项(Miscellaneous)  </li><li>8: 管理命令(&#x2F;sbin, &#x2F;usr&#x2F;sbin, &#x2F;usr&#x2F;local&#x2F;sbin)</li></ul><p>whatis COMMAND：查看命令属于那些章节  </p><pre><code>[root@localhost ~]# whatis date  date (1)             - print or set the system date and time  date (1p)            - write the date and time</code></pre><div class="note blue icon-padding flat"><p>练习：</p>  <p>1. 使用date单独获取系统当前的年份、月份、日、小时、分钟、秒  </p>  <p>2. echo和printf是内部命令还是外部命令？  </p>  <p>3. echo和printf作用？  </p>  <p>4. echo和printf如何显示“The year is 2013. Today is 26.”为两行？  </p>  <p>5. file命令及其用法？</p>  </div><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>Linux时间有两种。一种是硬件时钟，另一种是系统时钟。</p><blockquote><ul><li>硬件时钟：CPU内置振荡器确定时间，同时CPU内置纽扣电源为振荡器提供电量。</li><li>系统时钟：Linux系统启动后，读取硬件时间并以软件方式模拟一个振荡器。date查看的便是系统时钟。</li></ul></blockquote><p>date：时间管理  </p><blockquote><p>-d 后跟字符串，显示字符串指定的时间 </p></blockquote><pre><code>[root@localhost ~]# date -d &quot;2 days ago&quot;  Fri Nov 19 02:05:54 EST 2021  [root@localhost ~]# date -d &quot;2021/11/21&quot;  Sun Nov 21 00:00:00 EST 2021    \\\\ 指定时间输出格式：  [root@localhost ~]# date -d &quot;10 days ago&quot; +&quot;The day is %Y-%m-%d %H:%M:%S%nThe day is %A&quot;  The day is 2021-11-11 02:27:09  The day is Thursday  \\\\ 修改时间  [root@localhost ~]# date -s &quot;2019-01-01 08:08:08&quot;Tue Jan  1 08:08:08 EST 2019</code></pre><p>clock、hwclock：硬件时钟</p><pre><code>-s 将系统时间更新为硬件时钟-w 将硬件时钟更新为系统时间</code></pre><p>cal：查看日历</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>ls（list）：列出指定路径下的文件  </p><pre><code> -l：长格式      文件类型：          -：普通文件 (f)          d: 目录文件          b: 块设备文件 (block)          c: 字符设备文件 (character)          l: 符号链接文件(symbolic link file)          p: 命令管道文件(pipe)          s: 套接字文件(socket)      文件权限：9位，每3位一组，每一组：rwx(读，写，执行), r--      文件硬链接的次数      文件的属主(owner)      文件的属组(group)      文件大小(size)，单位是字节      时间戳(timestamp)：最近一次被修改的时间          访问:access，文件最近访问时间          修改:modify，文件内容发生了改变          改变:change，metadata，元数据（如文件名、文件权限等属性改变）  -h：做单位转换，提高信息可读性  -a: 显示以.开头的隐藏文件      . 表示当前目录      .. 表示父目录  -A  显示以.开头的隐藏文件（除.和..目录）  -d: 显示目录自身属性，而不是目录下的内容。只显示当前文件或目录的属性  -i: index node, inode  -r: 逆序显示  -R: 递归(recursive)显示  </code></pre><p>pwd（Printing Working directory）：输出当前工作路径  </p><p>cd: change directory  </p><pre><code>cd ~: 进入指定用户的家目录  cd -:在当前目录和前一次所在的目录之间来回切换  </code></pre><p>mkdir：创建空目录  </p><pre><code>-p: 目录已存在不报错，父路径不存在自动创建  -v: verbose 打印出创建的每个目录mkdir -pv /mnt/test2/&#123;a,d&#125;_&#123;b,c&#125;：命令行展开，创建a_b, a_c, d_b, d_c目录</code></pre><p>tree：查看目录树</p><p>rmdir (remove directory)：删除空目录  </p><pre><code>-p: 如果父目录为空也会自动删除</code></pre><p>du ： 用于显示目录或文件的大小  </p><pre><code>-s 仅显示总计  -h 做单位换算，提高信息可读性</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>touch  修改文件的访问时间或修改时间为当前时间</p><pre><code> -a  仅仅改变访问时间   -m  仅仅改变修改时间   -t  指定[[CC]YY]MMDDhhmm[.ss]，代替当前时间   -c  不创建任何文件  </code></pre><blockquote><p>注：修改访问或修改任何一个时间都会自动修改改变时间为当前时间</p></blockquote><p>stat  展示文件或文件系统属性</p><pre><code>[root@localhost Music]# stat 11.txt   File: &#39;11.txt&#39;  Size: 14              Blocks: 8          IO Block: 4096   regular fileDevice: fd00h/64768d    Inode: 3169019     Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2019-01-01 01:01:00.000000000 -0500Modify: 2019-01-01 01:01:00.000000000 -0500Change: 2021-11-21 06:07:26.151522828 -0500 Birth: - </code></pre><p>nano：文本编辑器，不常用。</p><p>rm  删除文件或目录  </p><pre><code>-i 每一次删除之前都提示    -f 忽略不存在的文件，强制删除不提示  -r 递归删除</code></pre><p>cp SRC DEST 复制文件  </p><pre><code>-r：递归拷贝目录下内容  -d：复制时保留链接，如果是链接文件复制后依然是链接文件。  -i：存在目标文件则提示是否覆盖  -f：覆盖已经存在的目标文件而不给出提示。-p（小写）：保留这个文件原来的权限、属主、属组、时间戳。注：目前我用普通用户复制属主和属组还是变化。-P（大写）：如果是链接复制为链接-a：归档复制，常用于备份，相当于-dR --preserve=all多个文件到一个目录cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>mv SRC DEST  移动文件<br>mv -t DEST SRC  -t 是将源和目标位置反向</p><p>install  复制文件并可以设置属性  </p><pre><code> install -d DIRECOTRY ... ：创建目录     install -m ：可以指定权限   install SRC DEST 复制文件，复制之后会有执行权限   install -t DIRECTORY SRC...  </code></pre><h3 id="查看文本"><a href="#查看文本" class="headerlink" title="查看文本"></a>查看文本</h3><p>cat：连接文件并显示  </p><pre><code>-n 显示行号   -E 显示每一行的结束符$ [root@localhost Music]# cat file1 file2  this file is one.  this file is two.   [root@localhost Music]# cat -n file1 file2       1  this file is one.       2  this file is two.  [root@localhost Music]# cat -E file1 file2  this file is one.$  this file is two.$  [root@localhost Music]# cat -nE file1 file2       1  this file is one.$       2  this file is two.$</code></pre><p>tac: 将文件内容倒着显示</p><pre><code>[root@localhost Music]# tac file1this file is one, the line is 6.this file is one, the line is 5.this file is one, the line is 4.this file is one, the line is 3.this file is one, the line is 2.this file is one, the line is 1.</code></pre><p>more：以一页一页的方式查看文本，到文件末尾会自动退出。详细使用见man命令</p><p>less：less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。到文件末尾不会自动退出。</p><p>head:查看前n行   </p><pre><code>-n: 指定行数，默认为10  </code></pre><p>tail:查看后n行  </p><pre><code>-n: 指定行数，默认为10  -f: 会把文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>file： 辨识文件类型  </p><p>测试文件内容：</p><pre><code>Tom:25:male:2013/05/06  Jack:24:famale:2013/05/06Json:23:male:2013/05/06Mark:26:famale:2013/05/06</code></pre><p>cut:  分割文件中的每一行，并只显示选择字段</p><pre><code>-d: 指定字段分隔符，默认是空格-f: 指定要显示的字段    -f 1,3    -f 1-3[root@localhost Music]# cut -d : -f 1,3 file3Tom:maleJack:famaleJson:maleMark:famale</code></pre><p>sort：文本排序</p><pre><code>-n：数值排序-r: 降序-t: 字段分隔符-k: 以哪个字段为关键字进行排序-u: 排序后相同的行只显示一次-f: 排序时忽略字符大小写[root@localhost Music]# sort -n -t : -k 2 file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06WangWu:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06ZhaoLiu:26:male:2013/05/06LiSi:111:male:2013/05/06[root@localhost Music]# sort -n -t : -k 2 -u file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06LiSi:111:male:2013/05/06</code></pre><p>uniq:去重，去重时两行相邻并且内容一致才会认定是重复</p><pre><code>-c: 显示文件中行重复的次数-d: 只显示重复的行</code></pre><p>wc (word count)：文本统计，打印文件的行数、单词数、字节数</p><pre><code> -l：打印行数 -w：打印单词数 -c：打印字节数 -L：打印最长行的长度</code></pre><p>tr —— 转换或删除字符  </p><pre><code>tr [OPTION]... SET1 [SET2]      -d: 删除出现在字符集中的所有字符tr ab AB ：将文档中的a全部转换为A，将b全部转换为B，并不是ab转AB</code></pre><h3 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h3><p>locate: 非实时，模糊匹配，查找是根据全系统文件数据库进行的，速度快；<br>updatedb: 手动生成文件数据库（比较慢）</p><p>find：实时、精确、支持众多查找标准、遍历指定目录中的所有文件完成查找，速度慢；</p><pre><code>find 查找路径 匹配标准 查找到以后的处理运作查找路径：默认为当前目录匹配标准：默认为指定路径下的所有文件处理运作：默认为显示匹配标准：-name &#39;FILENAME&#39;：对文件名作精确匹配    文件名通配：        *：任意长度的任意字符        ?:任意单个字符        []:匹配指定范围内的任意单个字符-iname &#39;FILENAME&#39;: 文件名匹配时不区分大小写-regex PATTERN：基于正则表达式进行文件名匹配-user USERNAME: 根据属主查找-group GROUPNAME: 根据属组查找-uid UID: 根据UID查找-gid GID: 根据GID查找-nouser：查找没有属主的文件(删除用户之后，文件的属主则会变为用户对应的uid)-nogroup: 查找没有属组的文件(删除组之后，文件的属组则会变为用户对应的gid)-type     f: 普通文件    d：目录文件    c：字符设备文件    b：块设备文件    l：符号链接文件    p：命名管道文件    s：套接字文件-size [+|-] 大小 +大于 -小于    #k    #M    #G -mtime：在过去n天修改过的文件（单位：天）-ctime：在过去n天改变过的文件-atime：在过去n天访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-mmin：在过去n分钟修改过的文件（单位：分钟）-cmin：在过去n分钟改变过的文件-amin：在过去n分钟访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-maxdepth:递归层数-perm MODE：精确匹配    /MODE: 任意一位匹配即满足条件    -MODE: 文件权限能完全包含此MODE时才符合条件        -644    644: rw-r--r--    755: rwxr-xr-x    750: rwxr-x---    find ./ -perl -001 组合条件：以上条件之间的逻辑，    -a：与    -o：或    -not： 非     \( \)：括号要转义运作：    -print: 显示    -ls：类似ls -l的形式显示每一个文件的详细    -ok COMMAND &#123;&#125; \; 每一次操作都需要用户确认，命令中需要文件名的地方用&#123;&#125;代替    -exec COMMAND &#123;&#125; \;每一次操作都不需要用户确认，命令中需要文件名的地方用&#123;&#125;代替</code></pre><div class="note green icon-padding flat"><p>练习：  </p><p>1)在/mnt下创建boot和sysroot； </p> <p>2)在/mnt/boot下创建grub；  </p><p>3)在/mnt/sysroot下创建proc, sys, bin, sbin, lib, usr, var, etc, dev, home, root, tmp  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a)在/mnt/sysroot/usr下创建bin, sbin, lib  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b)在/mnt/sysroot/lib下创建modules  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)在/mnt/sysroot/var下创建run, log, lock  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d)在/mnt/sysroot/etc下创建init.d  </p><p>4)创建目录/backup；  </p><p>5)复制目录/etc至/backup目录中，并重命名为“etc-当前日期”，如etc-2013-02-26；要求保留文件原来的属性，保持链接文件；   </p><p>6）复制文件/etc/inittab为/tmp/inittab.new，并删除inittab.new文件的后两行； </p> <pre><code>  # cp /etc/inittab  /tmp/inittab.new    # nano /tmp/inittab.new</code></pre><p>7）描述GPL, BSD, Apache三个开源协定的大体联系及区别。</p><p>8）如何获取Linux当前最新的内核版本号？  </p>      <pre><code>  www.kernel.org</code></pre><p>9）列出你所了解的Linux发行版，并说明其跟Linux内核的关系。</p>  <pre><code>Linux, GNU: GNU/Linux, 源代码发行版：Fedora, RedHat(CentOS), SUSE, Debian(Ubuntu, Mint), Gentoo, LFS(Linux From Scratch)</code></pre><p>10）、查找/var目录下属主为root并且属组为mail的所有文件；</p><pre><code>find /var -user root -group mail</code></pre><p>11）、查找/usr目录下不属于root,bin或student的文件；</p><pre><code>find /usr -not -user root -a -not -user bin -a -not -user studentfind /usr -not \( -user root -o -user bin -o -user student \)</code></pre><p>12）、查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件；</p><pre><code>find /etc -mtime -7 -not \ ( -user root -o -user student \)find /etc -mtime -7 -not -user root -a -not -user student</code></pre><p>13）、查找当前系统上没有属主或属组且最近1天内曾被访问过的文件，并将其属主属组均修改为root；</p>    <pre><code>find / \( -nouser -o -nogroup \) -a -atime -1 -exec chown root:root &#123;&#125; \; </code></pre><p>14）、查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中；</p>    <pre><code>find /etc -size +1M &gt;&gt; /tmp/etc.largefiles</code></pre><p>15）、查找/etc目录下所有用户都没有写权限的文件，显示出其详细信息；</p><pre><code>find /etc -not -perm /222 -ls</code></pre></div><h3 id="用户、权限和组基础"><a href="#用户、权限和组基础" class="headerlink" title="用户、权限和组基础"></a>用户、权限和组基础</h3><p>Linux的用户管理使用如下机制：  </p><blockquote><p>认证机制：Authentication（使用用户名密码）<br>授权：Authorization（使用权限管理）<br>审计：Audition (日志)</p></blockquote><p>权限：  r, w, x</p><ul><li><p>文件：  </p><ul><li>r：可读，可以使用类似cat等命令查看文件内容；  </li><li>w：可写，可以编辑或删除此文件；  </li><li>x: 可执行，exacutable，可以命令提示符下当作命令提交给内核运行；</li></ul></li><li><p>目录：  </p><ul><li>r: 可以对此目录执行ls以列出内部的所有文件；  </li><li>w: 可以在此目录创建文件；  </li><li>x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；</li></ul></li></ul><p>权限和数字对应关系：</p><pre><code> 0 000 ---: 无权限 1 001 --x: 执行 2 010 -w-: 写 3 011 -wx: 写和执行 4 100 r--: 只读 5 101 r-x: 读和执行 6 110 rw-: 读写 7 111 rwx: 读写执行 755：rwxr-xr-x 640：rw-r-----  660: rw-rw---- 775: rwxrwxr-x</code></pre><p>用户：UID, &#x2F;etc&#x2F;passwd  </p><pre><code>account: 登录名password: 密码UID：GID：基本组IDcomment: 注释HOME DIR：家目录SHELL：用户的默认shell</code></pre><p>组：GID, &#x2F;etc&#x2F;group  </p><pre><code>组名：  密码：  GID:  以此组为其附加组的用户列表：</code></pre><p>影子口令：  </p><ul><li><p>用户：&#x2F;etc&#x2F;shadow</p><pre><code>  account: 登录名    encrypted password: 加密的密码    date of last password change：最近一次修改密码的时间  minimum password age：最短使用期限  maximum password age：最长使用期限  password warning period：警告时间  password inactivity period：非活动时间  account expiration date：账号过期时间</code></pre></li><li><p>组：&#x2F;etc&#x2F;gshadow</p></li></ul><p>影子文件中存储的密码都会进行相应的单向加密，加密算法分类如下：  </p><ul><li>对称加密：加密和解密使用同一个密码  </li><li>公钥加密：每个密码都成对儿出现，一个为私钥(secret key)，一个为公钥(public key)  </li><li>单向加密，散列加密：提取数据特征码，常用于数据完整性校验  <ul><li>1、雪崩效应  </li><li>2、定长输出  </li><li>MD5：Message Digest, 128位定长输出  </li><li>SHA1：Secure Hash Algorithm, 160位定长输出</li></ul></li></ul><p>用户类别：</p><ul><li>管理员：0  </li><li>普通用户： 1-65535  </li><li>系统用户：1-499  </li><li>一般用户：500-60000</li></ul><p>用户组类别：</p><ul><li>私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组  </li><li>基本组：创建用户时，指定的用户的默认组  </li><li>附加组，额外组：默认组以外的其它组</li></ul><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>useradd  [options]  USERNAME 添加用户  </p><pre><code> -u UID（用户ID） -g GID（基本组ID\基本组名，组必须存在） -G GID,...  （附加组） -c &quot;COMMENT&quot; （注释） -d /path/to/directory （家目录） -s SHELL （指定SHELL） -m -k （创建家目录。-k将/etc/skel下内容复制到家目录中） -M （不创建家目录） -r: 添加系统用户</code></pre><p>&#x2F;etc&#x2F;login.defs</p><blockquote><p>用于在Linux创建用户时，对用户的一些基本属性做默认设置。该配置对root用户无效。并且，当此文件中的配置与 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 文件中的用户信息有冲突时，系统会以&#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 为准。  </p></blockquote><p>userdel [option] USERNAME 删除用户  </p><pre><code> -r: 同时删除用户的家目录</code></pre><p>id：查看用户的帐号属性信息  </p><pre><code> -u: 显示用户ID -g: 显示基本组ID -G: 显示附加组ID -n: 每个选项不显示ID，显示名称[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><p>finger USERNAME：查看用户账号信息</p><p>usermod ： 修改用户帐号属性</p><pre><code>   -u UID 修改用户ID-g GID 修改基本组-a -G GID：不使用-a选项，会覆盖此前的附加组；-c：修改用户账户备注文字-d -m：修改用户的家目录，-m选项是将原来家目录中的内容复制新的家目录-s：修改用户shell-l：修改用户帐号名称-L：锁定帐号-U：解锁帐号usermod -a -G GROUPNAME，... USERNAME</code></pre><p>chage ： 修改用户密码信息</p><pre><code>-d: 最近一次的修改时间-E: 过期时间-I：非活动时间-m: 最短使用期限-M: 最长使用期限-W: 警告时间</code></pre><p>chsh: 修改用户的默认shell</p><p>chfn：修改注释信息</p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>passwd [USERNAME]</p><pre><code> --stdin ： 从标准输入中读入，主要用于管道传入 -l：锁定帐号  -u：解锁帐号   -d: 删除用户密码</code></pre><p>pwck：检查用户帐号完整性</p><pre><code>[root@localhost ~]# pwckuser &#39;ftp&#39;: directory &#39;/var/ftp&#39; does not existuser &#39;saslauth&#39;: directory &#39;/run/saslauthd&#39; does not existuser &#39;gluster&#39;: directory &#39;/run/gluster&#39; does not existuser &#39;pulse&#39;: directory &#39;/var/run/pulse&#39; does not existuser &#39;gnome-initial-setup&#39;: directory &#39;/run/gnome-initial-setup/&#39; does not existpwck: no changes</code></pre><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><p>groupadd 添加组</p><pre><code> -g GID 指定组ID -r：添加为系统组</code></pre><p>groupmod 修改组</p><pre><code> -g GID 修改组ID -n GRPNAME 更改组名称</code></pre><p>groupdel 删除组  </p><p>gpasswd：为组设定密码  </p><pre><code>gpasswd -d A GROUP ：将用户A从GROUP组移除  </code></pre><p>newgrp GRPNAME &lt;–&gt; exit：为用户指定临时基本组，需要指定组密码，用exit退出。</p><pre><code>[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ newgrp hadoop Password: [demo@localhost ~]$ iduid=1000(demo) gid=1001(hadoop) groups=1001(hadoop),1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ exitexit[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、创建一个用户mandriva，其ID号为2002，基本组为distro（组ID为3003），附加组为linux； </p>  <pre><code># groupadd -g 3003 distro# groupadd linux# useradd -u 2002 -g distro -G linux mandriva</code></pre><p>2、创建一个用户fedora，其全名为Fedora Community，默认shell为tcsh；</p>   <pre><code># useradd -c &quot;Fedora Community&quot; -s /bin/tcsh fedora</code></pre><p>3、修改mandriva的ID号为4004，基本组为linux，附加组为distro和fedora；</p> <pre><code># usermod -u 4004 -g linux -G distro,fedora mandriva</code></pre><p>4、给fedora加密码，并设定其密码最短使用期限为2天，最长为50天；</p> <pre><code># passwd -n 2 -x 50 fedora</code></pre><p>5、将mandriva的默认shell改为/bin/bash; </p> <pre><code>usermod -s /bin/bash mandirva</code></pre><p>6、添加系统用户hbase，且不允许其登录系统；</p> <pre><code># useradd -r -s /sbin/nologin hbase</code></pre></div><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>chown USERNAME file,…  改变文件属主(只有管理员可以使用此命令)  </p><pre><code> -R: 修改目录及其内部文件的属主 --reference=/path/to/somefile file,...：将文件的属主和属组和参照文件保持一致  chown    :GRPNAME file,...      ：改变文件属组信息 chown    .GRPNAME file,...      ：改变文件属组信息 chown USERNAME:GRPNAME file,... ：改变文件属主、属组信息 chown USERNAME.GRPNAME file,... ：改变文件属主、属组信息</code></pre><p>chgrp GRPNAME file,… 改变文件属组(只有管理员可以使用此命令)  </p><pre><code>-R: 修改目录及其内部文件的属组--reference=/path/to/somefile file,...：将文件的属组和参照文件保持一致  </code></pre><p>chmod MODE file,… 修改文件的权限</p><pre><code>-R: 修改目录及其内部文件的权限--reference=/path/to/somefile file,... ：将文件的权限和参照文件保持一致 修改文件权限：chmod  MODE file,...chomd  755 /home/demo/11.txt修改某类用户用户权限：u（属主）,g（属组）,o（其他）,a（所有）chmod 用户类别=MODE file,...chomd  u=rw /home/demo/11.txt修改某类用户的某位或某些位权限：u,g,o,achmod 用户类别+|-MODE file,...chmod u+w /home/demo/11.txtchmod ug+w /home/demo/11.txtchmod u+w,g+r /home/demo/11.txt</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、新建一个没有家目录的用户openstack；  </p>  <pre><code># useradd -M openstack  </code></pre><p>2、复制/etc/skel为/home/openstack；  </p>  <pre><code># cp -r /etc/skel /home/openstack  </code></pre><p>3、改变/home/openstack及其内部文件的属主属组均为openstack； </p>   <pre><code># chown -R openstack:openstack /home/openstack  </code></pre><p>4、/home/openstack及其内部的文件，属组和其它用户没有任何访问权限  </p>  <pre><code># chmod -R go= /home/openstack  （不修改属主的权限） </code></pre><p>5、不用命令如何添加一个用户  </p>  <pre><code>在/etc/passwd、/etc/shadow、/etc/group中分别添加一条记录使用openssl passwd -1 -salt xxxxxxxx（八位随机数） password 获取加密密码使用如上步骤</code></pre></div><h3 id="umask-遮掩码"><a href="#umask-遮掩码" class="headerlink" title="umask(遮掩码)"></a>umask(遮掩码)</h3><p>每个用户都会有一个遮掩码，遮掩码的作用是设置用户创建文件或目录的权限。Linux文件默认不具有执行权限。</p><pre><code>文件权限：666-umask （文件不具有执行权限） 目录权限：777-umask建议用权限位相减</code></pre><p>umask: 023</p><pre><code>文件：666-023=643 X （文件默认不能具有执行权限，如果算得的结果中有执行权限，则将其权限加1；故结果应为644）目录：777-023=754</code></pre><p>注：umask：027 创建的文件或目录其它用户无任何权限</p><h3 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h3><p>程序在运行过程中需要和I&#x2F;O设备打交道，而程序一般是不直接指定具体的输入和输出设备的。因此系统为我们提供了一些默认的输入和输出设置。</p><ul><li>默认输出设备：标准输出，STDOUT, 1（文件描述符），显示器</li><li>默认输入设备：标准输入, STDIN, 0（文件描述符） ，键盘  </li><li>标准错误输出：STDERR, 2（文件描述符）  ，显示器</li></ul><p>I&#x2F;O重定向就是修改程序的输入和输出的位置。</p><pre><code>&gt;:  标准输出覆盖输出&gt;&gt;：标准输出追加输出2&gt;: 重定向错误输出2&gt;&gt;:重定向错误输出追加方式&amp;&gt;: 重定向标准输出或错误输出至同一个文件&lt;：输入重定向&lt;&lt;：Here Document 此处生成文档    使用：&lt;&lt;EOF或者END         cat &lt;&lt; EOF         cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        [root@localhost ~]# cat        this is my first line.        this is my first line.        this is my secondary line.        this is my secondary line.        ^C        [root@localhost ~]# cat &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        this is my first line.        this is my secondary line.        [root@localhost ~]# cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        [root@localhost ~]# cat /tmp/myfile.txt         this is my first line.        this is my secondary line.</code></pre><p>tee：将标准输入写入标准输出和文件<br>        echo “hello world”|tee &#x2F;tmp&#x2F;hello.out</p><p>set可以对系统的某些功能性选项进行开启或关闭。 </p><pre><code>set -C: 禁止对已经存在文件使用覆盖重定向；  强制覆盖输出，则使用 &gt;|set +C: 关闭上述功能</code></pre><p>管道：一端流入，一端流出。即前一个命令的输出，作为后一个命令的输入。</p><pre><code>命令1 | 命令2 | 命令3 | ...echo “redhat” | passwd -stdin hive：使用命令行修改用户密码</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、统计/usr/bin/目录下的文件个数；</p><pre><code> # ls /usr/bin | wc -l</code></pre><p>2、取出当前系统上所有用户的shell，要求，每种shell只显示一次，并且按顺序进行显示；</p><pre><code> # cut -d: -f7 /etc/passwd | sort -u</code></pre><p>3、思考：如何显示/var/log目录下每个文件的内容类型？</p><pre><code> # file /var/log/* # file &#39;ls /var/log&#39;</code></pre><p>4、取出/etc/inittab文件的第6行；</p><pre><code> # head -6 /etc/inittab | tail -1</code></pre><p>5、取出/etc/passwd文件中倒数第9个用户的用户名和shell，显示到屏幕上并将其保存至/tmp/users文件中；</p><pre><code> # tail -9 /etc/passwd | head -1 | cut -d: -f1,7 | tee /tmp/users</code></pre><p>6、显示/etc目录下所有以pa开头的文件，并统计其个数；</p><pre><code># ls -d /etc/pa* | wc -l</code></pre><p>7、不使用文本编辑器，将alias cls=clear一行内容添加至当前用户的.bashrc文件中；</p><pre><code># echo &quot;alias cls=clear&quot; &gt;&gt; ~/.bashrc</code></pre></div><h2 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h2><h3 id="常规正则表达式"><a href="#常规正则表达式" class="headerlink" title="常规正则表达式"></a>常规正则表达式</h3><p>grep: 根据模式搜索文本，并将符合模式的文本行显示出来。</p><p>Pattern（模式）: 文本字符和正则表达式的元字符组合而成匹配条件</p><p>grep [options] PATTERN [FILE…]</p><pre><code>-i:忽略大小写--color : 匹配到的字符串亮色显示-v: 显示没有被模式匹配到的行-o：只显示被模式匹配到的字符串-E：使用扩展正则表达式-A：显示匹配字符串的前N行-B：显示匹配字符串的后N行-C：显示匹配字符串的前后N行</code></pre><p>Pattern（模式）元字符如下：</p><pre><code>字符匹配：：    .: 匹配任意单个字符    []: 匹配指定范围内的任意单个字符    [^]：匹配指定范围外的任意单个字符    字符集合：[:digit:], [:lower:], [:upper:], [:punct:], [:space:], [:alpha:], [:alnum:]匹配次数（贪婪模式）    *: 匹配其前面的字符任意次    \?: 匹配其前面的字符1次或0次    \&#123;m,n\&#125;:匹配其前面的字符至少m次，至多n次        a, b, ab, aab, acb, adb, amnb        a*b， a?b        a.*b            .*: 任意长度的任意字符        \&#123;1,\&#125;        \&#123;0,3\&#125;位置锚定：    ^: 锚定行首，此字符后面的任意内容必须出现在行首    $: 锚定行尾，此字符前面的任意内容必须出现在行尾    ^$: 空白行    \&lt;或\b: 锚定词首，其后面的任意字符必须作为单词首部出现    \&gt;或\b: 锚定词尾，其前面的任意字符必须作为单词的尾部出现分组：    \(\)    \(ab\)* 后向引用        \1: 引用第一个左括号以及与之对应的右括号所包括的所有内容如：demo    He love his lover.    She like her liker.    He like his lover.[root@localhost ~]# grep &quot;\(l..e\).*\1r\.&quot; demoHe love his lover.She like her liker.</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示/proc/meminfo文件中以不区分大小的s开头的行；</p><pre><code>grep -i &#39;^s&#39; /proc/meminfogrep &#39;^[sS]&#39; /proc/meminfo</code></pre><p>2、显示/etc/passwd中以nologin结尾的行;</p> <pre><code>grep &#39;nologin$&#39; /etc/passwd</code></pre><p>3、取出默认shell为/sbin/nologin的用户列表</p><pre><code>grep &quot;nologin$&#39; /etc/passwd | cut -d: -f1</code></pre><p>4、取出默认shell为bash，且其用户ID号最小的用户的用户名</p><pre><code>grep &#39;bash$&#39; /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1</code></pre><p>5、显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；</p>    <pre><code>grep &quot;^#[[:space:]]\&#123;1,\&#125;[^[:space:]]&quot; /etc/inittab</code></pre><p>6、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；</p>    grep ':[0-9]:' /etc/inittab<p>7、显示/boot/grub/grub.conf文件中以一个或多个空白字符开头的行；</p>    <pre><code>grep &#39;^[[:space:]]\&#123;1,\&#125;&#39; /boot/grub/grub.conf</code></pre><p>8、显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；</p><pre><code>grep &#39;^\([0-9]\).*\1$&#39; /etc/inittab</code></pre><p>9、找出某文件中的，1位数，或2位数；</p><pre><code>grep &#39;[0-9]\&#123;1,2\&#125;&#39; /proc/cpuinfogrep --color &#39;\&lt;[0-9]\&#123;1,2\&#125;\&gt;&#39; /proc/cpuinfo</code></pre><p>10、找出ifconfig命令结果中的1-255之间的整数；</p>  <p>9、查找当前系统上名字为student(必须出现在行首)的用户的帐号的相关信息, 文件为/etc/passwd</p>    <pre><code>grep &#39;^student\&gt;&#39; /etc/passwd | cut -d: -f3id -u student</code></pre><p>10、 分析/etc/inittab文件中如下文本中前两行的特征(每一行中出现在数字必须相同)，请写出可以精确找到类似两行的模式：</p><pre><code>l1:1:wait:/etc/rc.d/rc 1l3:3:wait:/etc/rc.d/rc 3grep &#39;^l\([0-9]\):\1.*\1$&#39; /etc/inittab</code></pre></div><h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h3><pre><code>grep -E = egrep    字符匹配：        .        []        [^]    次数匹配：        *:         ?:        +: 匹配其前面的字符至少1次        &#123;m,n&#125;    位置锚定：        ^        $        \&lt;        \&gt;    分组：        ()：分组        \1, \2, \3, ...    或者        |: or        C|cat: 为 C或cat 不是 Cat或cat</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示所有以数字结尾且文件名中不包含空白的文件；</p>    <pre><code>ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>2、找出/boot/grub/grub.conf文件中1-255之间的数字；</p>    <pre><code>\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;ifconfig | egrep &#39;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39; ifconfig | egrep --color &#39;(\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.)&#123;3&#125;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39;只查找前三类IP地址：（1-223）\&lt;([1-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[01][0-9]|22[0-3])\&gt;(\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;)&#123;2&#125;\.\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;</code></pre></div><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>   su [-l] 用户名：切换用户<br>   sudo COMMAND：完成部分特权指令</p><pre><code>配置文件/etc/sudoers文件中的如下行： 106 ## Allows people in group wheel to run all commands107 %wheel  ALL=(ALL)       ALL</code></pre><h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>SUID: 运行某程序时，相应进程的属主是程序文件自身的属主，而不是启动者；</p><pre><code>chmod u+s FILEchmod u-s FILE    如果FILE本身原来就有执行权限，则SUID显示为s；否则显示S；</code></pre><p>SGID: 运行某程序时，相应进程的属组是程序文件自身的属组，而不是启动者所属的基本组；同时该文件夹下所创建文件的属组是文件夹的属组，而不是创建用户的属组。</p><pre><code>chmod g+s FILEchmod g-s FILE    develop team, hadoop, hbase, hive    /tmp/project/        develop</code></pre><p>Sticky: 在一个公共目录，每个都可以创建文件，删除自己的文件，但不能删除别人的文件；</p><pre><code>chmod o+t DIRchmod o-t DIR</code></pre><p>注：以上三种权限就像rwx一样，也可以使用数字表示。比如 chmod 5755 &#x2F;backup&#x2F;test，而且umask的第一位数字代表的就是这三种权限。</p><h2 id="文件系统访问列表"><a href="#文件系统访问列表" class="headerlink" title="文件系统访问列表"></a>文件系统访问列表</h2><p>FACL(Filesystem Access Control List):利用文件扩展保存额外的访问控制权限 </p><p>setfacl</p><pre><code>-m: 设定    u:UID:perm    d:u：UID：perm 对目录有用，该目录下的新建文件拥有此默认权限    g:GID:perm    d:g：GID：perm 对目录有用，该目录下的新建文件拥有此默认权限-x：取消    u:UID    g:GID</code></pre><p>getfacl：查看文件系统访问权限</p><pre><code>[demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-group::rw-mask::rw- (这个会根据自动变化，为文件的最大权限)other::r--[demo@localhost ~]$ setfacl -m u:demo2:rwx demo.txt [demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-user:demo2:rwxgroup::rw-mask::rwx (这个会根据自动变化，为文件的最大权限)other::r--// 目录下设置默认权限[demo@localhost ~]$ setfacl -m d:u:demo2:rw- Desktop/[demo@localhost ~]$ cd Desktop/[demo@localhost Desktop]$ lltotal 0[demo@localhost Desktop]$ touch demo2.txt[demo@localhost Desktop]$ getfacl demo2.txt # file: demo2.txt# owner: demo# group: demouser::rw-user:demo2:rw-group::r-x#effective:r--mask::rw-other::r--[demo@localhost ~]$ lltotal 4-rw-rwxr--+ 1 demo demo 18 Dec 17 11:28 demo.txt  （具有acl属性权限结尾会有+）drwxr-xr-x+ 2 demo demo 23 Dec 25 04:42 Desktop</code></pre><h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><p>压缩算法不同，压缩比也会不同。常见的压缩格式有：gz, bz2, xz, zip, Z</p><p>Z格式（只能压缩单个文件。如果是文件夹，则是压缩文件夹内的每个文件）</p><pre><code>compress FILENAMEuncompress [demo@localhost ~]$ compress inittab -rw-r--r--. 1 demo demo 390 Dec 29 09:24 inittab.Z[demo@localhost ~]$ uncompress inittab.Z -rw-r--r--. 1 demo demo 511 Dec 29 09:24 inittab</code></pre><p>gz格式（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>gzip /PATH/TO/SOMEFILE：压缩完成后会删除原文件    -d：解压    -#：1-9，指定压缩比，默认是6；gunzip /PATH/TO/SOMEFILE.gz: 解压完成后会删除原文件zcat /PATH/TO/SOMEFILE.gz： 不解压的情况，查看文本文件的内容[demo@localhost ~]$ gzip inittab-rw-r--r--. 1 demo demo 316 Dec 29 09:24 inittab.gz</code></pre><p>bz2格式，该格式比gz有着更大压缩比（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>bzip2 /PATH/TO/SOMEFILE        -d: 解压        -#: 1-9,默认是6        -k: 压缩时保留原文件        bunzip2 /PATH/TO/SOMEFILE.bz2  解压完成后会删除原文件bzcat 不解压的情况，查看文本文件的内容[demo@localhost ~]$ bzip2 inittab -rw-r--r--. 1 demo demo 349 Dec 29 09:24 inittab.bz2</code></pre><p>xz格式：（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>xz /PATH/TO/SOMEFILE    -d：解压    -#: 1-9, 默认是6    -k: 压缩时保留原文件        unxz：解压xzdec:解压xzcat：不解压的情况，查看文本文件的内容。[demo@localhost ~]$ xz inittab -rw-r--r--. 1 demo demo 372 Dec 29 09:24 inittab.xz</code></pre><p>注：以上压缩和解压会删除原文件  </p><p>zip: 既归档（可以指定文件夹压缩）又压缩的工具  </p><pre><code>zip FILENAME.zip FILE1 FILE2 ...: 压缩后不删除原文件unzip FILENAME.zip ：解压</code></pre><p>tar: 归档工具, .tar</p><pre><code>-c: 创建归档文件-f FILE.tar: 操作的归档文件（压缩时是压缩后文件名，解压时是解压的文件名）-x: 展开归档--xattrs: 归档时，保留文件的扩展属性信息-t: 不展开归档，直接查看归档了哪些文件-C: 在解压时指定解压后文件的存放位置-zcf: 归档并调用gzip压缩-zxf: 调用gzip解压缩并展开归档，-z选项可省略-jcf: 归档并调用bzip2压缩-jxf:-Jcf: 归档并调xz压缩-Jxf:[demo@localhost etc]$ tar -Jcf conf.tar.xz ./etc  压缩[demo@localhost etc]$ tar -zxf conf.tar.xz -C ./etc/ 解压</code></pre><p>cpio: 归档工具，不常用</p><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><p>w：显示目前登陆系统的用户信息（su 切换用户还是显示原用户）</p><pre><code>[demo@localhost ~]$ w 04:52:09 up 33 min,  2 users,  load average: 0.00, 0.03, 0.13USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATdemo     :0       :0               04:20   ?xdm?   1:12   0.26s /usr/libexec/gndemo     pts/0    :0               04:21    1.00s  0.49s  0.01s w</code></pre><p>who：显示当前登录系统的用户（w的简化版）</p><pre><code>[demo2@localhost demo]$ whodemo     :0           2021-12-25 04:20 (:0)demo     pts/0        2021-12-25 04:21 (:0)</code></pre><p>sleep #：等待多少秒<br>whoami：显示当前用户</p><pre><code>[demo2@localhost demo]$ whoamidemo2</code></pre><p>last，显示&#x2F;var&#x2F;log&#x2F;wtmp文件，显示用户登录历史及系统重启历史  </p><pre><code>-n #: 显示最近#次的相关信息[demo2@localhost demo]$ lastdemo     pts/0        :0               Sat Dec 25 04:21   still logged in   demo     :0           :0               Sat Dec 25 04:20   still logged in   demo     :0           :0               Sat Dec 25 04:20 - 04:20  (00:00)    reboot   system boot  3.10.0-1062.el7. Sat Dec 25 04:19 - 04:57  (00:38)    demo     pts/0        :0               Fri Dec 17 11:27 - 11:34  (00:06)    demo     :0           :0               Fri Dec 17 11:25 - crash (7+16:53) </code></pre><p>lastb，&#x2F;var&#x2F;log&#x2F;btmp文件，显示用户错误的登录尝试  </p><pre><code>-n #:[root@localhost demo]# lastbdemo2    pts/0                         Sat Dec 25 04:59 - 04:59  (00:00)    btmp begins Sat Dec 25 04:59:30 2021</code></pre><p>lastlog: 显示每一个用户最近一次的成功登录信息；</p><pre><code>-u USERNAME: 显示特定用户最近的登录信息[root@localhost demo]# lastlogUsername         Port     From             Latestroot             pts/0                     Sat Dec 25 04:59:06 -0500 2021bin                                        **Never logged in**daemon                                     **Never logged in**adm                                        **Never logged in**lp                                         **Never logged in**</code></pre><p>basename：获取文件名</p><pre><code>$0: 执行脚本时的脚本路径及名称[root@localhost demo]# basename /home/demo/demo.txtdemo.txt</code></pre><p>mail：发送邮件</p><pre><code>[root@localhost demo]# mail -s &quot;first&quot; demo &lt; demo.txt [root@localhost demo]# su - demoLast login: Sat Dec 25 04:59:21 EST 2021 on pts/0[demo@localhost ~]$ mailHeirloom Mail version 12.5 7/5/10.  Type ? for help.&quot;/var/spool/mail/demo&quot;: 1 message 1 new&gt;N  1 root                  Sat Dec 25 05:10  18/617   &quot;first&quot;&amp; 1Message  1:From root@localhost.localdomain  Sat Dec 25 05:10:07 2021Return-Path: &lt;root@localhost.localdomain&gt;X-Original-To: demoDelivered-To: demo@localhost.localdomainDate: Sat, 25 Dec 2021 05:10:06 -0500To: demo@localhost.localdomainSubject: firstUser-Agent: Heirloom mailx 12.5 7/5/10Content-Type: text/plain; charset=us-asciiFrom: root@localhost.localdomain (root)Status: Rthis is new file.&amp; 注：用户邮件目录在/var/spool/mail</code></pre><p>hostname: 显示主机名</p><pre><code>如果当前主机的主机名不是www.magedu.com，就将其改为www.magedu.com如果当前主机的主机名是localhost，就将其改为www.magedu.com如果当前主机的主机名为空，或者为(none)，或者为localhost，就将其改为www.magedu.com[ -z `hostname` ] || [ `hostname` == &#39;(none)&#39; -o `hostname` == &#39;localhost&#39; ] &amp;&amp; hostname www.magedu.com</code></pre><p>生成随机数RANDOM: 0-32768</p><pre><code>随机数生成器：熵池(收集系统产生中断的时间作为随机数)/dev/random:(收集系次产生中断的时间作为随机数，如果不足需要等待)/dev/urandom:(收集系统产生中断的时间作为随机数，如果不足则自行生成随机数)[demo@localhost mail]$ echo $RANDOM12963</code></pre><p>ln [-s -v] SRC DEST：建立符号链接</p><pre><code>-s：建立软链接-v：建立硬链接[demo@localhost ~]$ ln -s /etc/inittab ./[root@localhost demo]# ln -v /etc/inittab inittab1 ‘inittab1’ =&gt; ‘/etc/inittab’[root@localhost demo]# lltotal 8-rw-rwxr--+ 1 demo demo  18 Dec 17 11:28 demo.txtdrwxr-xr-x+ 2 demo demo  23 Dec 25 04:42 Desktopdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Documentsdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Downloadslrwxrwxrwx. 1 demo demo  12 Dec 25 05:48 inittab -&gt; /etc/inittab-rw-r--r--. 2 root root 511 Aug  8  2019 inittab1drwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Musicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Picturesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Publicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Templatesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Videos硬链接：（存储文件的inode）    1、只能对文件创建，不能应用于目录；    2、不能跨文件系统；    3、创建硬链接会增加文件被链接的次数；    符号链接：（存储文件的字符串）    1、可应用于目录；    2、可以跨文件系统；    3、不会增加被链接文件的链接次数；    4、其大小为指定的路径所包含的字符个数；</code></pre><p>du </p><pre><code>-s ：查看文件夹总大小-h ：单位换算[root@localhost etc]# du20./fonts/conf.d24./fonts72./grub.d12./pki/rpm-gpg156./pki/ca-trust/extracted/java......42436[root@localhost etc]# du -s42436.[root@localhost etc]# du -sh42M</code></pre><p>df: </p><pre><code>-h：查看各文件系统的存储  -i：查看各文件系统inode的使用量[root@localhost etc]# df -hFilesystem               Size  Used Avail Use% Mounted ondevtmpfs                 470M     0  470M   0% /devtmpfs                    487M     0  487M   0% /dev/shmtmpfs                    487M  8.7M  478M   2% /runtmpfs                    487M     0  487M   0% /sys/fs/cgroup/dev/mapper/centos-root   17G  4.2G   13G  25% //dev/sda1               1014M  171M  844M  17% /boottmpfs                     98M  4.0K   98M   1% /run/user/42tmpfs                     98M   28K   98M   1% /run/user/1000/dev/sr0                 4.4G  4.4G     0 100% /run/media/demo/CentOS 7 x86_64tmpfs                     98M     0   98M   0% /run/user/0[root@localhost etc]# df -iFilesystem               Inodes  IUsed   IFree IUse% Mounted ondevtmpfs                 120210    391  119819    1% /devtmpfs                    124468      1  124467    1% /dev/shmtmpfs                    124468    995  123473    1% /runtmpfs                    124468     16  124452    1% /sys/fs/cgroup/dev/mapper/centos-root 8910848 155245 8755603    2% //dev/sda1                524288    340  523948    1% /boottmpfs                    124468      6  124462    1% /run/user/42tmpfs                    124468     19  124449    1% /run/user/1000/dev/sr0                      0      0       0     - /run/media/demo/CentOS 7 x86_64tmpfs                    124468      1  124467    1% /run/user/0</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>终端类型：</p><pre><code>console: 控制台 直接连接在计算机上的显示器、鼠标、键盘pty: 物理终端 (VGA) tty#: 虚拟终端 (VGA) 服务器ttyS#: 串行终端pts/#: 伪终端 通过ssh等登陆到linux主机上所使用的终端</code></pre><p>计算机总线：  </p><ul><li>地址总线：内存寻址  </li><li>数据总线：传输数据  </li><li>控制总线：控制指令</li></ul><p>进程：在每个进程看来，当前主机上只存在内核和当前进程。进程是程序的副本，进程是程序执行实例  </p><p>环境变量：  </p><pre><code>PATH  HISTSIZE  SHELL：用户当前使用SHELL  </code></pre><p>LANG&#x3D;en 修改Linux编码  </p><p>read ： 从标准输入中读取数据，并以空格切分。将分割结果存入后面参数中的变量。具体使用参见：<br><a href="https://www.runoob.com/linux/linux-comm-read.html">https://www.runoob.com/linux/linux-comm-read.html</a>  </p><pre><code>-p “PROMPT&quot;: 给出提示    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;Linux的基本原则&quot;&gt;&lt;a href=&quot;#Linux的基本原则</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://example.com/2022/11/24/MakeBlog/"/>
    <id>http://example.com/2022/11/24/MakeBlog/</id>
    <published>2022-11-24T13:58:42.850Z</published>
    <updated>2022-11-24T13:58:42.850Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。</p><p></p><p>为什么选择个人博客？我搭建个人博客的原因是由于个人博客的样式可控。</p></div><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>机器环境: CentOS Linux release 7.7.1908 (Core)  </li><li>内核环境: 3.10.0-1062.el7.x86_64</li></ul><p>本博客采用nodejs平台+hexo框架+Butterfly主题+Github Pages搭建</p><ul><li>nodejs 是一个javascirpt的运行环境。我的理解为js原本是在浏览器上运行的脚本语言，有了nodejs之后，js就可以像shell脚本一样直接在机器上运行。</li><li>hexo框架是一个基于node.js的快速生成静态博客的框架</li><li>Butterfly是hexo博客的一款主题。</li><li>Github Pages是github提供的一项静态站点托管服务。</li></ul><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="搭建本地Hexo"><a href="#搭建本地Hexo" class="headerlink" title="搭建本地Hexo"></a>搭建本地Hexo</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>本文采用nodejs的二进制安装方式，由于我的Linux机器为CentOS 7，安装最新版会报错，因此我选择安装12.15.0这个版本。  </p><pre><code># 进入根目录cd /usr/local/# 获取二进制安装包wget https://nodejs.org/download/release/v12.15.0/node-v12.15.0-linux-x64.tar.gz# 解压tar -xf node-v12.15.0-linux-x64.tar.gzrm -rf node-v12.15.0-linux-x64.tar.gz# 创建软件包链接ln -sv node-v12.15.0-linux-x64/ nodejs# 让命令可以直接执行ln -sv /usr/local/nodejs/bin/node /usr/local/binln -sv /usr/local/nodejs/bin/npm /usr/local/bin# 检查是否能够运行[root@localhost bin]# node -vv12.15.0[root@localhost bin]# npm -v6.13.4</code></pre><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>查看是否安装git。hexo初始化的时候需要使用git命令从github下载hexo相关代码，后期将博客部署到github上也依赖git。</p><pre><code>[root@localhost bin]# git --versiongit version 1.8.3.1</code></pre><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>在家目录下建立blob目录作为hexo的根目录</p><pre><code># 建立目录mkdir ~/blobcd ~/blob# 永久设置npm源（不修改执行的时候会卡住）npm config set registry https://registry.npm.taobao.org# 安装hexo-cli，nodejs的npm相当于Linux的yum[root@localhost blob]# npm install -g hexo-cli/usr/local/node-v12.15.0-linux-x64/bin/hexo -&gt; /usr/local/node-v12.15.0-linux-x64/lib/node_modules/hexo-cli/bin/hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-cli@4.3.0added 59 packages from 51 contributors in 5.498s# 初始化文件夹hexo init# 安装 hexo 所需要的依赖包npm install</code></pre><p>在安装中遇到如下问题：Error: ENOENT: no such file or directory, uv_cwd</p><p>解决方案：重启终端</p><h4 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h4><p>hexo 常用命令：</p><ul><li>hexo g 生成静态网站</li><li>hexo s 启动服务器</li><li>hexo d 部署</li><li>hexo clean 清理生成的静态网站</li></ul><p>部署：</p><pre><code>[root@192 blob]# hexo g &amp;&amp; hexo sINFO  Validating configINFO  Start processingINFO  Files loaded in 130 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2022/index.htmlINFO  Generated: archives/2022/11/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/jquery.fancybox.min.cssINFO  Generated: js/script.jsINFO  Generated: css/style.cssINFO  Generated: 2022/11/21/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.woff2INFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.min.jsINFO  Generated: js/jquery-3.4.1.min.jsINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: css/images/banner.jpgINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  17 files generated in 410 msINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</code></pre><p>访问网站：<br><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204625063.png" alt="images"></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo的主题可以在github仓库中搜索hexo-theme或者hexo官网查找，本文使用的主题为butterfly。</p><pre><code># 从github仓库中下载主题（hexo根目录中）：git https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly# 修改hexo根目录下_config.xml 配置文件theme: landscape 改为 theme: butterfly# 重新部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>在浏览器中打开报如下问题：</p><pre><code># 显示内容：extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pug解决方案（hexo根目录）：npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></pre><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c51af39bb0820efc4ea19d42c7252b2?method=download&shareKey=577f858ad5b22a1545471f53e5f2416e" alt="image"></p><h3 id="优化主题"><a href="#优化主题" class="headerlink" title="优化主题"></a>优化主题</h3><p>至此，上面的博客已经具有了一个框架。下面我们进行相应的优化。参考博客：  </p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>更改博客主题、描述、作者、语言、时区（hexo根目录下配置文件）</p><pre><code># Sitetitle: 知与行subtitle: &#39;&#39;description: &#39;学而不思则惘，思而不学则殆&#39;keywords:  author: QiYanlanguage: zh-CNtimezone: Asia/Shanghai</code></pre><p>图像修改：背景图下载地址<a href="https://wallhaven.cc/">https://wallhaven.cc/</a> ，图像放到hexo_root&#x2F;themes&#x2F;主题名&#x2F;source&#x2F;img&#x2F;。如下修改的是主题配置文件（hexo_root&#x2F;theme&#x2F;主题名&#x2F;_config.xml）。</p><pre><code># 主页图index_img: /img/background.jpg    # 头像：avatar:  img: /img/avatar.png#文档图（cover:  # display the cover or not (是否顯示文章封面)  index_enable: false  aside_enable: false  archives_enable: false  # the position of cover in home page (封面顯示的位置)  # left/right/both  position: both  # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)  default_cover: </code></pre><p>cover中设置default_cover之后，文件列表和文章内容的top图都是同一张图。<br>解决方案：<a href="https://blog.csdn.net/zzq0523/article/details/122954271">https://blog.csdn.net/zzq0523/article/details/122954271</a>）</p><p>修改菜单：</p><pre><code>menu:   首页: / || fas fa-home   归档: /archives/ || fas fa-archive   标签: /tags/ || fas fa-tags   分类: /categories/ || fas fa-folder-open  # List||fas fa-list:  #   Music: /music/ || fas fa-music  #   Movie: /movies/ || fas fa-video  # Link: /link/ || fas fa-link   关于: /about/ || fas fa-heart</code></pre><p>创建相关页面</p><pre><code>#前往你的 Hexo 博客的根目錄hexo new page tags#找到source/tags/index.md這個文件添加 type: &quot;tags&quot;并将title后的名字改为中文 ---title: 標籤date: 2018-01-05 00:00:00type: &quot;tags&quot;---# 添加分类页hexo new page categories---title: 分类date: 2022-11-21 08:20:51types: &quot;categories&quot;---</code></pre><p>添加动态文字：</p><pre><code>subtitle:  enable: true  # Typewriter Effect (打字效果)  effect: true  # Effect Speed Options (打字效果速度參數)  startDelay: 300 # time before typing starts in milliseconds  typeSpeed: 150 # type speed in milliseconds  backSpeed: 50 # backspacing speed in milliseconds  # loop (循環打字)  loop: true  # source 調用第三方服務  # source: false 關閉調用  # source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/  # source: 2  調用今日詩詞（簡體） https://www.jinrishici.com/  # subtitle 會先顯示 source , 再顯示 sub 的內容  source: false  # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字  sub:    - 今日事&amp;#44;今日畢    - Never put off till tomorrow what you can do today</code></pre><p>安装搜索框</p><pre><code>[root@192 butterfly]# npm install hexo-generator-search --savenpm notice created a lockfile as package-lock.json. You should commit this file.+ hexo-generator-search@2.4.3added 6 packages from 5 contributors in 1.551s# 修改主题配置文件local_search:  enable: true# 重启hexo否则会报错hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>添加字数统计功能：</p><pre><code>npm install hexo-wordcount --save# 修改主题配置文件wordcount:     enable: true# 重启hexo</code></pre><p>给文章列表添加字数统计：  </p><p><a href="http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/">http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/</a></p><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p><a href="https://imbhj.com/25c13146/">https://imbhj.com/25c13146/</a><br><a href="https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/">https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/</a></p><h2 id="托管静态页面"><a href="#托管静态页面" class="headerlink" title="托管静态页面"></a>托管静态页面</h2><h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><p>首先在github中注册账号  </p><p>创建仓库。每个用户只能创建一个github pages，因此仓库名称必须为&lt;用户名&gt;.github.io，否则创建的为普通仓库</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224741804.png" alt="image">、</p><p>在github pages仓库中创建一个index.html文件用于测试  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225639083.png" alt="image"></p><p>在浏览器页面输入https:&#x2F;&#x2F;用户名.github.io&#x2F; 查看是否访问成功  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229230057034.png" alt="image"></p><h3 id="免密登录github"><a href="#免密登录github" class="headerlink" title="免密登录github"></a>免密登录github</h3><p>CentOS中生成登录密钥：</p><pre><code># 其中 邮箱名 是你注册 GitHub 的邮箱ssh-keygen -t rsa -C &quot;邮箱名&quot; # 后面输入三个回车</code></pre><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image"></p><p>CentOS 进入~&#x2F;.ssh目录，复制id_rsa.pub中的内容。将公钥复制到github中。</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235220955.png" alt="image"></p><p>测试是否能够正常连接：</p><pre><code>[root@192 images]# ssh -T git@github.comHi qiyankuo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>安装部署插件</p><pre><code># 这样执行会报错[root@192 blob]# npm install hexo-deplyer-gitnpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmmirror.com/hexo-deplyer-git - [NOT_FOUND] hexo-deplyer-git not foundnpm ERR! 404 npm ERR! 404  &#39;hexo-deplyer-git@latest&#39; is not in the npm registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404 npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     /root/.npm/_logs/2022-11-22T02_25_42_682Z-debug.log# 正确方式[root@192 blob]# npm install hexo-deployer-git --save# 修改hexo根目录下配置文件deploy:  type: &#39;git&#39;  repo: git@github.com:用户名/仓库名  #如：git@github.com:qiyankuo/qiyankuo.github.io.git  branch: main# 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </code></pre><p>在浏览器中输入https:&#x2F;&#x2F;用户名.github.io&#x2F;进行测试（这个可能会有些延迟）</p><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><h3 id="git相关概念"><a href="#git相关概念" class="headerlink" title="git相关概念"></a>git相关概念</h3><p><a href="https://www.runoob.com/git/git-workspace-index-repo.html">https://www.runoob.com/git/git-workspace-index-repo.html</a></p><h3 id="创建仓库并上传图片"><a href="#创建仓库并上传图片" class="headerlink" title="创建仓库并上传图片"></a>创建仓库并上传图片</h3><p>在github中新建仓库images</p><p>在CentOS下关联github仓库，进行图片管理</p><pre><code># 先进入准备放置github仓库的目录cd ...# 克隆仓库git clone 仓库地址 # 如：https://github.io/qiyankuo/images# 将需要添加的图片移动到仓库目录中mv ... ...git add 文件名  # 添加xyz文件至indexgit commit -m &quot;描述&quot;  # 提交git remote origin git@github.com:qiyankuo/images.git  # 设置远程连接别名git push origin main  # 将本地内容提交到github中</code></pre><h3 id="引用图片地址"><a href="#引用图片地址" class="headerlink" title="引用图片地址"></a>引用图片地址</h3><p>在github中找到图像发现无法显示，在图片上右键在新标签中打开图像显示url如下：<a href="https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg">https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg</a></p><p>参照网上教程使用免费的CDN服务jsDriver进行github加速，但是我发现这个好像不能用。故我采用如下方式：</p><ul><li><p>github镜像 <a href="https://hub.nuaa.cf/">https://hub.nuaa.cf/</a> 访问上面的图片将githubusercontent.com修改为nuaa.cf。即</p><pre><code>  https://raw.nuaa.cf/qiyankuo/images/main/hexo/betterfly.jpg  注：这种方式发现本地部署和github pages中都无法查看</code></pre></li><li><p>Github RAW 加速服务<a href="https://www.7ed.net/start/raw-cdn.html">https://www.7ed.net/start/raw-cdn.html</a>，在githubusercontent中添加上s就可以了。即</p><pre><code>  [https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg](https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg)  注：这种方式发现本地部署可以查看，浏览器也可以查看，但是github pages页面中无法查看</code></pre></li><li><p>最终采用有道云笔记存储图片，或者可以用gitee存储图片。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>    经过了三四天的时间终于将自己的个人博客搭建完成。搭建博客的过程中也遇到了很多问题。首先，原本准备使用next主题，但是这个主题有一些地方无法调整，当时想过放弃或者先搭建一个后期再通过学习前端进行修改。之后当看到51cto的博客样式，这个博客已经满足我的基本需要。当我无意中找到butterfly官网的文章之后，感觉这就是我想要的文章样式。</p><p>    其次，起初采用github搭建，但是考虑到github国内访问速度较慢。开始转gitee上搭建，但是gitee需要实名认证（被拒了）。继续github进行搭建。</p><p>    搭建完之后发现jsDriver不能使用，最终找到了Github RAW 加速服务进行替换。后期计划的话博客样式应该还会不断的进行调整。最后，准备使用typora和picgo搭建书写博客的环境，typora收费，picgo官网上说仅在Windows和macos进行了测试。</p><p>    目前更新了文章之后发布都是手动发布的，图片也是手动上传。我准备做一个shell脚本，自动完成图片的上传替换以及自动发布功能。当然，博客搭建完了。更重要的是不断的更新自己的知识，不断的发布博客。即不能为了发博客而写博客，也不能因为忙而不写博客。</p></div><div class="note green icon-padding flat"><p>参考文档：</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://butterfly.js.org/posts/dc584b87</p><p>https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;为什么选择个人博客？我搭建个人博客的原因是由于个人博客</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/11/21/hello-world/"/>
    <id>http://example.com/2022/11/21/hello-world/</id>
    <published>2022-11-21T09:22:02.494Z</published>
    <updated>2022-11-21T09:22:02.491Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
