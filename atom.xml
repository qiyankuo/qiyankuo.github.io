<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知与行</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-27T07:40:39.725Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>QiYan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://example.com/2022/11/27/Linux-file/"/>
    <id>http://example.com/2022/11/27/Linux-file/</id>
    <published>2022-11-27T07:40:39.738Z</published>
    <updated>2022-11-27T07:40:39.725Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相成。同时，文件系统也是一个操作系统的重要组成部分。</P></div><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在Linux中一切皆文件</p><pre><code>[demo@localhost dev]$ ll文件类型                   主设备号 次设备号crw-rw-rw-. 1 root tty       5,     0 Dec 25 04:19 ttycrw--w----. 1 root tty       4,     0 Dec 25 04:19 tty0crw--w----. 1 root tty       4,     1 Dec 25 04:19 tty1brw-rw----. 1 root disk      8,     0 Dec 25 04:19 sdabrw-rw----. 1 root disk      8,     1 Dec 25 04:19 sda1brw-rw----. 1 root disk      8,     2 Dec 25 04:19 sda2                         设备文件类型：b: 按块为单位，随机访问的设备；c：按字符为单位，线性设备；主设备号 （major number）    标识设备类型次设备号 （minor number）    标识同一种类型中不同设备</code></pre><p>创建特殊文件</p><pre><code>mknod [OPTION]... NAME TYPE MAJOR（主设备号） MINOR（次设备号）    -m MODE ： 指定权限[root@localhost dev]# mknod sda3 b 8 3[root@localhost dev]# mknod -mode 660 sda4 b 8 3</code></pre><p>磁盘设备的设备文件名：</p><pre><code>IDE, ATA：hdSATA：sdSCSI: sdUSB: sd同种设备以a，b，c...来区分同一种类型下的不同设备，即sda, sdb, sdc, ...IDE:     第一个IDE口：主、从        /dev/hda, /dev/hdb    第二个IDE口：主、从        /dev/hdc, /dev/hdd</code></pre><p>同一磁盘设备文件分区名:</p><pre><code>如hda:     hda1: 第一个主分区    hda2: 第二个主分区    hda3: 第三个主分区    hda4: 第四个主分区（MBR中的扩展分区）    hda5: 第一个逻辑分区</code></pre><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h3><p>首先了解一下磁盘的物理结构。磁盘是由一个个光盘结合在一起，每个光盘上都有一些同心圆。这些同心圆我们称之为磁道，然后将磁道划分为一个个的扇区作为基本存储单元。同时每一个光盘的同一扇区称之为柱面。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB362e3b95a3888dcdf1fc43d21c8daa00?method=download&shareKey=974939cf6495a01ed31327a286a5aa35" alt="image"></p><p>磁盘刚被创建出来后，没有任何信息。磁盘在出厂的时候会进行低级格式化。格式化之后的扇区由前导码（包括柱面号、扇区号等）、数据区和ECC（数据纠错码）组成。</p><p>大部分的磁盘能够划分出一到多个分区，叫做磁盘分区。每个分区都有独立的文件系统，每块分区的文件系统都可以不同。目前磁盘的分区组织方式有两种，分别为MBR和GPT。  </p><h3 id="分区组织方式"><a href="#分区组织方式" class="headerlink" title="分区组织方式"></a>分区组织方式</h3><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>磁盘的0号分区称为主引导记录（MBR），位于磁盘的第一扇区。MBR由Bootloader（446bytes）、Partition Table（64bytes，每个16个字节记录一个分区）、Magic Number（2个字节）组成。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB373eb090e2c333bc226709ac8b7ff105?method=download&shareKey=06a6b63acbf2ef85453d7227a63f4643" alt="image"></p><ol><li><p>Bootloader:用于标识操作系统的放置方式和位置，以便可以将其加载到计算机的内存中。    </p></li><li><p>Partition Table:由于Partition Table最多只能包含四条记录。如果磁盘分区大于4，需要将最后一条记录添加为扩展分区。扩展分区可以存储更多的分区记录。</p></li><li><p>Magic Number：如果为0x55 0xAA，则代表该设备MBR中含有Bootloader。</p></li></ol><p>在计算机启动过程中会首先启动BIOS检查各种硬件环境，之后根据BIOS的配置挨个查看存储设备的前512字节是不是以0x55 0xAA结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载该磁盘MBR中的Bootloader。并将控制权转移到相应设备（U盘、硬盘）的引导加载程序(Bootloader)。</p><p>MBR存在如下限制：</p><ol><li>操作系统无法抓取到2.2T以上的磁盘容量</li><li>MBR仅有一个区块。若被破坏后，经常无法或很难救援</li><li>MBR内存开机管理程序的区块仅446Bytes，无法容纳较多的程序码</li></ol><h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p>GPT不存在如上所述的限制。</p><blockquote><p>过去一个扇区的大小为512Bytes，目前已经有4K的扇区出现。为了相容于所有的磁盘，所以引入了逻辑区块位址（LBA)的概念。GPT将磁盘所有扇区以此LBA（默认为512Bytes喔！）来规划，而第一个LBA称为LBA0.</p></blockquote><p>GPT使用了34个LBA区块来记录分区信息。同时整个磁盘的最后33个LBA也拿来作为一个备份。GPT结构如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB1a6a41e7d27580e02d1060e36902cd66?method=download&shareKey=9aa1e15262c5049a57738d48448694f5" alt="image"></p><p>LBA0 (MBR兼容）</p><p>与MBR模式相似的，这个相容区块也分为两个部分。一个就是根之前446Bytes相似的区块，存储了第一阶段的开机管理程序。而在原本的分区表的记录区内放入了一个特殊标志，用来表示此磁盘为GPT格式。而不懂GPT分区表的磁盘管理程序，就不会认识这颗磁盘。除非用户有特别要求要处理这颗磁盘。</p><p>LBA1 （GPT表头）</p><p>记录了备份用的GPT分区放置的位置，同时放置了分区表的校验机制码。操作系统可以根据这个校验码来判断GPT是否正确。若有错误，还可以通过这个记录区来取得备份的GPT来恢复GPT的正常运行。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>磁盘在使用之前要进行高级格式化，高级格式化即在分区上分配文件系统。</p><h4 id="ext-系列"><a href="#ext-系列" class="headerlink" title="ext 系列"></a>ext 系列</h4><p>每个文件系统的结构如下：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd28a8793ae46cdcd002c271e2f45bcac?method=download&shareKey=255b05b4812120ce65529dfddcf1bb03" alt="image"></p><ul><li>引导块：为了一致性，每个分区都要从引导块开始，即使引导块不包括操作系统。引导块占据文件系统的前4096个字节，从磁盘上的字节偏移量0开始。引导块可用于启动操作系统。  </li><li>超级块：描述整个分区的文件系统信息。例如块大小、文件系统的大小、文件系统的块数等。  </li><li>空闲空间管理：块位图和inode位图。块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块。其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用</li><li>inode：一个文件除了数据需要存储之外，一些描述信息也需要存储。例如文件类型（常规、目录、符号链接等），权限，文件大小，创建&#x2F;修改&#x2F;访问时间等。也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中</li><li>根目录：存放文件系统目录树的根部。</li><li>文件和目录：存储文件和目录的数据。</li></ul><p>文件系统逻辑结构图：</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8fafced3dd9b543ffa04545dfc65680e?method=download&shareKey=c8803f0b05537d766c6ad7f60b7588da" alt="image"></p><p>Linux支持的文件系统</p><ul><li>ext3, ext4, ext2: extended</li><li>reiserfs</li><li>iso9660, swap, cifs, nfs</li><li>xfs, jfs</li><li>ocfs2, gfs2</li><li>fat32, ntfs</li></ul><h4 id="xfs文件系统"><a href="#xfs文件系统" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><p>CentOS 7 开始，默认的文件系统已经由原本的Ext4 变成了xfs 这个较适合大容量磁盘与巨型文件性能较佳的文件系统了。</p><p>Ext文件系统采用的是预先规划出所有的inode&#x2F;block&#x2F;metadata等数据，这些数据未来系统可以直接使用。xfs则是根据需要动态分配inode和block数据。当磁盘容量达到TB以上等级时，传统ext家族在文件系统格式化时预先规划inode和block就需要消耗好多的时间。</p><p>xfs文件系统的组成：</p><ol><li>数据区：这个区域和ext文件系统的block群组一样，只不过inode和block是动态产生的，并非是一开始格式化就分配好的</li><li>文件系统活动登录区：日志区。文件的变化会记录到这里。当变化完整的写入数据区后，该笔记录才会被终结。</li><li>实时运行区：当有文件要被创建时，xfs会在这个区段里面找一个到数个extent区块，将文件放置在这个区块中，等到动态分配完毕后，再写入到数据区的inode和block中。这个extent区块的大小要在格式化的时候就指定，最小值4k最大可到1G。建议不要乱动，具有磁盘阵列stripe的情况下，则建议extent设置为与stripe一样大比较好。</li></ol><p>查看xfs文件系统信息：</p><pre><code>[root@study ~]# xfs_info 挂载点|设备文件名范例一：找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录[root@study ~]# df -T /bootFilesystem Type 1K-blocks Used Available Use% Mounted on/dev/vda2 xfs 1038336 133704 904632 13% /boot# 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！[root@study ~]# xfs_info /dev/vda21 meta-data=/dev/vda2 isize=256 agcount=4, agsize=65536 blks2 = sectsz=512 attr=2, projid32bit=13 = crc=0 finobt=04 data = bsize=4096 blocks=262144, imaxpct=255 = sunit=0 swidth=0 blks6 naming =version 2 bsize=4096 ascii-ci=0 ftype=07 log =internal bsize=4096 blocks=2560, version=28 = sectsz=512 sunit=0 blks, lazy-count=19 realtime =none extsz=4096 blocks=0, rtextents=0第 1 行里面的 isize 指的是 inode 的容量，每个有 256Bytes 这么大。至于 agcount 则是前面谈到的储存区群组 （allocation group） 的个数，共有 4 个， agsize 则是指每个储存区群组具有 65536 个 block 。配合第 4 行的 block 设置为 4K，因此整个文件系统的容量应该就是 4655364K 这么大！第 2 行里面 sectsz 指的是逻辑扇区 （sector） 的容量设置为 512Bytes 这么大的意思。第 4 行里面的 bsize 指的是 block 的容量，每个 block 为 4K 的意思，共有 262144 个block 在这个文件系统内。第 5 行里面的 sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。这部份我们下面格式化的时候会举一个例子来说明。第 7 行里面的 internal 指的是这个登录区的位置在文件系统内，而不是外部设备的意思。且占用了 4K * 2560 个 block，总共约 10M 的容量。第 9 行里面的 realtime 区域，里面的 extent 容量为 4K。不过目前没有使用。</code></pre><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="分区命令"><a href="#分区命令" class="headerlink" title="分区命令"></a>分区命令</h3><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区！parted &#x2F;dev&#x2F;xxx print可以找出内部的分区表类型，之后再用 gdisk 或 fdisk 来操作系统。</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk -l [&#x2F;dev&#x2F;to&#x2F;some_device_file] ：查看当前系统识别了几块硬盘  </p><pre><code>[root@localhost dev]# fdisk -lDisk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0001d65a   Device Boot      Start         End      Blocks   Id  System/dev/sda1   *        2048     2099199     1048576   83  Linux（分区）/dev/sda2         2099200    41943039    19921920   8e  Linux LVM（分区）Disk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors （硬盘）Units = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytes</code></pre><p>fdisk &#x2F;dev&#x2F;sda  </p><pre><code>p: 显示当前硬件的分区，包括没保存的改动n: 创建新分区    e: 扩展分区（创建扩展分区，将所有空间分配给它）    p: 主分区d: 删除一个分区w: 保存退出q: 不保存退出t: 修改分区类型L: （查看分区类型）l: 显示所支持的所有类型[root@localhost ~]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xc8f76ed0.Command (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  SystemCommand (m for help): nPartition type:   p   primary (0 primary, 0 extended, 4 free)   e   extendedSelect (default p): pPartition number (1-4, default 1):   First sector (2048-41943039, default 2048): Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +1GPartition 1 of type Linux and of size 1 GiB is set... //再建立两个主分区Command (m for help): nPartition type:   p   primary (3 primary, 0 extended, 1 free)   e   extendedSelect (default e): eSelected partition 4First sector (6293504-41943039, default 6293504): Using default value 6293504Last sector, +sectors or +size&#123;K,M,G&#125; (6293504-41943039, default 41943039): Using default value 41943039Partition 4 of type Extended and of size 17 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  System/dev/sdb1            2048     2099199     1048576   83  Linux/dev/sdb2         2099200     4196351     1048576   83  Linux/dev/sdb3         4196352     6293503     1048576   83  Linux/dev/sdb4         6293504    41943039    17824768    5  ExtendedCommand (m for help): nAll primary partitions are in useAdding logical partition 5First sector (6295552-41943039, default 6295552):  Using default value 6295552Last sector, +sectors or +size&#123;K,M,G&#125; (6295552-41943039, default 41943039): +1GPartition 5 of type Linux and of size 1 GiB is setCommand (m for help): pDisk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc8f76ed0   Device Boot      Start         End      Blocks   Id  System/dev/sdb1            2048     2099199     1048576   83  Linux/dev/sdb2         2099200     4196351     1048576   83  Linux/dev/sdb3         4196352     6293503     1048576   83  Linux/dev/sdb4         6293504    41943039    17824768    5  Extended/dev/sdb5         6295552     8392703     1048576   83  Linux</code></pre><p>cat &#x2F;proc&#x2F;partitions ：查看系统有哪些分区<br>partprobe [&#x2F;dev&#x2F;sda]：重新加载设备分区</p><h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><pre><code>[root@study ~]# gdisk 设备名称范例：由前一小节的 lsblk 输出，我们知道系统有个 /dev/vda，请观察该磁盘的分区与相关数据[root@study ~]# gdisk /dev/vda  #仔细看，不要加上数字喔！GPT fdisk （gdisk） version 0.8.6Partition table scan:MBR: protectiveBSD: not presentAPM: not presentGPT: presentFound valid GPT with protective MBR; using GPT. &amp;lt;==找到了 GPT 的分区表！Command （? for help）: #这里可以让你输入指令动作，可以按问号 （?） 来查看可用指令Command （? for help）: ?b back up GPT data to a filec change a partition&#39;s named delete a partition # 删除一个分区i show detailed information on a partitionl list known partition typesn add a new partition # 增加一个分区o create a new empty GUID partition table （GPT）p print the partition table # 印出分区表 （常用）q quit without saving changes  # 不储存分区就直接离开 gdiskr recovery and transformation options （experts only）s sort partitionst change a partition&#39;s type codev verify diskw write table to disk and exit  # 储存分区操作后离开 gdiskx extra functionality （experts only）? print this menuCommand （? for help）:</code></pre><h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>查看当前内核所支持文件系统类型：</p><pre><code>cat /proc/filesystems  </code></pre><h4 id="ext系列文件系统"><a href="#ext系列文件系统" class="headerlink" title="ext系列文件系统"></a>ext系列文件系统</h4><p>专门管理ext系列文件：<br>mkdfs.ext4<br>mke2fs  </p><pre><code>-j: 创建ext3类型文件系统-b BLOCK_SIZE: 指定块大小，默认为4096；可用取值为1024、2048或4096；-L LABEL：指定分区卷标；-m #: 指定预留给超级用户的块数百分比-i #: 用于指定用多少字节的空间创建一个inode，默认为8192；这里给出的数值应该为块大小的2^n倍；-N #: 指定inode个数；-F: 强制创建文件系统；-E: 用户指定额外文件系统属性; [root@localhost ~]# mkfs -t ext2 /dev/sdb1mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65536 inodes, 262144 blocks13107 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8192 inodes per groupSuperblock backups stored on blocks: （超级块备份存储的块地址）    32768, 98304, 163840, 229376Allocating group tables: done                            Writing inode tables: done                            Writing superblocks and filesystem accounting information: done</code></pre><h4 id="xfs文件系统-1"><a href="#xfs文件系统-1" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><pre><code>[root@study ~]# mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \[-r parms] 设备名称选项与参数：关于单位：下面只要谈到“数值”时，没有加单位则为 Bytes 值，可以用 k,m,g,t,p （小写）等来解释比较特殊的是 s 这个单位，它指的是 sector 的“个数”喔！-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！-d ：后面接的是重要的 data section 的相关参数值，主要的值有：    agcount=数值 ：设置需要几个储存群组的意思（AG），通常与 CPU 有关    agsize=数值 ：每个 AG 设置为多少容量的意思，通常 agcount/agsize 只选一个设置即可    file ：指的是“格式化的设备是个文件而不是个设备”的意思！（例如虚拟磁盘）    size=数值 ：data section 的容量，亦即你可以不将全部的设备容量用完的意思    su=数值 ：当有 RAID 时，那个 stripe 数值的意思，与下面的 sw 搭配使用    sw=数值 ：当有 RAID 时，用于储存数据的磁盘数量（须扣除备份碟与备用碟）    sunit=数值 ：与 su 相当，不过单位使用的是“几个 sector（512Bytes大小）”的意思    swidth=数值 ：就是 su*sw 的数值，但是以“几个 sector（512Bytes大小）”来设置-f ：如果设备内已经有文件系统，则需要使用这个 -f 来强制格式化才行！-i ：与 inode 有较相关的设置，主要的设置值有：    size=数值 ：最小是 256Bytes 最大是 2k，一般保留 256 就足够使用了！    internal=[0&amp;#124;1]：log 设备是否为内置？默认为 1 内置，如果要用外部设备，使用下面设置    logdev=device ：log 存储为后面接的那个设备上头的意思，需设置 internal=0 才可！    size=数值 ：指定这块登录区的容量，通常最小得要有 512 个 block，大约 2M 以上才行！-L ：后面接这个文件系统的标头名称 Label name 的意思！-r ：指定 realtime section 的相关设置值，常见的有：    extsize=数值 ：就是那个重要的 extent 数值，一般不须设置，但有 RAID 时，    最好设置与 swidth 的数值相同较佳！最小为 4K 最大为 1G 。    范例：将前一小节分区出来的 /dev/vda4 格式化为 xfs 文件系统[root@study ~]# mkfs.xfs /dev/vda4meta-data=/dev/vda4 isize=256 agcount=4, agsize=65536 blks= sectsz=512 attr=2, projid32bit=1= crc=0 finobt=0data = bsize=4096 blocks=262144, imaxpct=25= sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal log bsize=4096 blocks=2560, version=2= sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0# 很快格是化完毕！都用默认值！较重要的是 inode 与 block 的数值[root@study ~]# blkid /dev/vda4/dev/vda4: UUID=&quot;39293f4f-627b-4dfd-a015-08340537709c&quot; TYPE=&quot;xfs&quot;# 确定创建好 xfs 文件系统了！</code></pre><p>XFS文件系统for RAID性能优化</p><p>磁盘阵列 （RAID） 就是通过将文件先细分为数个小型的分区区块 （stripe） 之后，然后将众多的 stripes 分别放到磁盘阵列里面的所有磁盘， 所以一个文件是被同时写入到多个磁盘去，当然性能会好一些。为了文件的保全性，所以在这些磁盘里面，会保留数个（与磁盘阵列的规划有关） 备份磁盘 （parity disk）， 以及可能会保留一个以上的备用磁盘（spare disk）。</p><p>文件系统的读写要能够有最优化，最好能够搭配磁盘阵列的参数来设计，这样性能才能够起来！也就是说，你可以先在文件系统就将 stripe 规划好， 那交给 RAID 去存取时，它就无须重复进行文件的 stripe 过程，性能当然会更好！那格式化时，最优化性能与什么咚咚有关呢？我们来假设个环境好了：</p><blockquote><p>我有两个线程的 CPU 数量，所以 agcount 最好指定为 2</p><p>当初设置 RAID 的 stripe 指定为 256K 这么大，因此 su 最好设置为 256k</p><p>设置的磁盘阵列有 8 颗，因为是 RAID5 的设置，所以有一个 parity （备份碟），因此指定 sw 为 7</p><p>由上述的数据中，我们可以发现数据宽度 （swidth） 应该就是 256K*7 得到 1792K，以指定 extsize 为 1792k</p></blockquote><blockquote><p>重新创建文件系统会损坏原有文件  </p></blockquote><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>mkfs: make file system  </p><pre><code>-t FSTYPE 文件系统类型    mkfs -t ext2 = mkfs.ext2mkfs -t ext3 = mkfs.ext3</code></pre><p>parted：创建文件系统，ext和xfs都可以</p><pre><code>parted [设备] [指令 [参数]]新增分区：mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束显示分区：print删除分区：rm [partition]范例一：以 parted 列出目前本机的分区表数据[root@study ~]# parted /dev/vda printModel: Virtio Block Device （virtblk） &amp;lt;==磁盘接口与型号Disk /dev/vda: 42.9GB &amp;lt;==磁盘文件名与容量Sector size （logical/physical）: 512B/512B &amp;lt;==每个扇区的大小Partition Table: gpt &amp;lt;==是 GPT 还是 MBR 分区Disk Flags: pmbr_bootNumber Start End Size File system Name Flags1 1049kB 3146kB 2097kB bios_grub2 3146kB 1077MB 1074MB xfs3 1077MB 33.3GB 32.2GB lvm4 33.3GB 34.4GB 1074MB xfs Linux filesystem5 34.4GB 35.4GB 1074MB ext4 Microsoft basic data6 35.4GB 36.0GB 537MB linux-swap（v1） Linux swap[ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ]</code></pre><h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><blockquote><p>修复文件系统时不能被挂载</p></blockquote><h4 id="xfs-repair"><a href="#xfs-repair" class="headerlink" title="xfs_repair"></a>xfs_repair</h4><p>检查并修复 XFS 文件系统</p><pre><code>[root@study ~]# xfs_repair [-fnd] 设备名称选项与参数：-f ：后面的设备其实是个文件而不是实体设备-n ：单纯检查并不修改文件系统的任何数据 （检查而已）-d ：通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作！很危险！不要随便使用范例：检查一下刚刚创建的 /dev/vda4 文件系统[root@study ~]# xfs_repair /dev/vda4Phase 1 - find and verify superblock...Phase 2 - using internal logPhase 3 - for each AG...Phase 4 - check for duplicate blocks...Phase 5 - rebuild AG headers and trees...Phase 6 - check inode connectivity...Phase 7 - verify and correct link counts...done# 共有 7 个重要的检查流程！详细的流程介绍可以 man xfs_repair 即可！</code></pre><h4 id="其它文件系统自检"><a href="#其它文件系统自检" class="headerlink" title="其它文件系统自检"></a>其它文件系统自检</h4><p>fsck: 检查并修复Linux文件系统</p><pre><code>-t FSTYPE: 指定文件系统类型-a: 自动修复</code></pre><p>e2fsck: 专用于修复ext2&#x2F;ext3文件系统</p><pre><code>-f: 强制检查；-p: 自动修复；[root@localhost ~]# e2fsck /dev/sdb1e2fsck 1.42.9 (28-Dec-2013)filesystem: clean, 11/65536 files, 4443/262144 blocks</code></pre><h3 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h3><p>blkid: 查询或查看磁盘设备的相关属性 UUID、TYPE（文件系统）、LABEL</p><pre><code>[root@localhost ~]# blkid/dev/sda1: UUID=&quot;63389af9-2128-4b68-b072-0b3d7aaca50d&quot; TYPE=&quot;xfs&quot; /dev/sda2: UUID=&quot;UN0Ex0-C5Bz-oeCn-RbEP-RR1a-x79t-Ikyjh3&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb1: UUID=&quot;224f048a-76cf-4320-89b8-4458d6b96def&quot; TYPE=&quot;ext2&quot; /dev/sr0: UUID=&quot;2019-09-11-18-50-31-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; /dev/mapper/centos-root: UUID=&quot;827a53b1-31be-4ab8-b5a2-3310ee209a81&quot; TYPE=&quot;xfs&quot; /dev/mapper/centos-swap: UUID=&quot;f03a485d-b51a-4f0a-ad29-1262c359686f&quot; TYPE=&quot;swap&quot; </code></pre><p>e2label: 用于查看或定义卷标（应该只能查看ext格式的文件系统）</p><pre><code>e2label 设备文件 卷标: 设定卷标[root@localhost ~]# e2label /dev/sdb1 filesystem[root@localhost ~]# e2label /dev/sdb1filesystem</code></pre><p>tune2fs: 调整文件系统的相关属性</p><pre><code>-j: 不损害原有数据，将ext2升级为ext3；不能反方向执行-L LABEL: 设定或修改卷标; -m #: 调整预留百分比；（预留给超级用户）-r #: 指定预留块数；（预留给超级用户）-o: 设定默认挂载选项；    acl 开启文件系统acl选项-c #：指定挂载次数达到#次之后进行自检，0或-1表关闭此功能；-i #: 每挂载使用多少天后进行自检；0或-1表示关闭此功能；-l: 显示超级块中的信息；[root@localhost ~]# tune2fs -l /dev/sdb1tune2fs 1.42.9 (28-Dec-2013)Filesystem volume name:   filesystemLast mounted on:          &lt;not available&gt;Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96defFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_fileFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              65536Block count:              262144Reserved block count:     13107Free blocks:              257701Free inodes:              65525First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      63Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Filesystem created:       Sun Dec 26 07:12:40 2021Last mount time:          n/aLast write time:          Sun Dec 26 07:24:57 2021Mount count:              0Maximum mount count:      -1Last checked:             Sun Dec 26 07:12:40 2021Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:          256Required extra isize:     28Desired extra isize:      28Default directory hash:   half_md4Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4f</code></pre><p>dumpe2fs: 显示文件系统属性信息</p><pre><code>-h: 只显示超级块中的信息[root@localhost ~]# dumpe2fs /dev/sdb1dumpe2fs 1.42.9 (28-Dec-2013)Filesystem volume name:   filesystemLast mounted on:          &lt;not available&gt;Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96defFilesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_fileFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              65536Block count:              262144Reserved block count:     13107Free blocks:              257701Free inodes:              65525First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      63Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Filesystem created:       Sun Dec 26 07:12:40 2021Last mount time:          n/aLast write time:          Sun Dec 26 07:24:57 2021Mount count:              0Maximum mount count:      -1Last checked:             Sun Dec 26 07:12:40 2021Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:          256Required extra isize:     28Desired extra isize:      28Default directory hash:   half_md4Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4fGroup 0: (Blocks 0-32767)  Primary superblock at 0, Group descriptors at 1-1  Reserved GDT blocks at 2-64  Block bitmap at 65 (+65), Inode bitmap at 66 (+66)  Inode table at 67-578 (+67)  32183 free blocks, 8181 free inodes, 2 directories  Free blocks: 585-32767  Free inodes: 12-8192Group 1: (Blocks 32768-65535)  Backup superblock at 32768, Group descriptors at 32769-32769  Reserved GDT blocks at 32770-32832  Block bitmap at 32833 (+65), Inode bitmap at 32834 (+66)  Inode table at 32835-33346 (+67)  32189 free blocks, 8192 free inodes, 0 directories  Free blocks: 33347-65535  Free inodes: 8193-16384</code></pre><p>xfs_admin:修改xfs文件系统：</p><pre><code>[root@study ~]# xfs_admin [-lu] [-L label] [-U uuid] 设备文件名选项与参数：-l ：列出这个设备的 label name-u ：列出这个设备的 UUID-L ：设置这个设备的 Label name-U ：设置这个设备的 UUID 喔！范例：设置 /dev/vda4 的 label name 为 vbird_xfs，并测试挂载[root@study ~]# xfs_admin -L vbird_xfs /dev/vda4writing all SBsnew label = &quot;vbird_xfs&quot; # 产生新的 LABEL 名称啰！[root@study ~]# xfs_admin -l /dev/vda4label = &quot;vbird_xfs&quot;[root@study ~]# mount LABEL=vbird_xfs /data/xfs/范例：利用 uuidgen 产生新 UUID 来设置 /dev/vda4，并测试挂载[root@study ~]# umount /dev/vda4 # 使用前，请先卸载！[root@study ~]# uuidgene0fa7252-b374-4a06-987a-3cb14f415488 # 很有趣的指令！可以产生新的 UUID 喔！[root@study ~]# xfs_admin -u /dev/vda4UUID = e0a6af55-26e7-4cb7-a515-826a8bd29e90[root@study ~]# xfs_admin -U e0fa7252-b374-4a06-987a-3cb14f415488 /dev/vda4Clearing log and setting UUIDwriting all SBsnew UUID = e0fa7252-b374-4a06-987a-3cb14f415488[root@study ~]# mount UUID=e0fa7252-b374-4a06-987a-3cb14f415488 /data/x</code></pre><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载：将新的文件系统关联至当前根文件系统，挂载完成后，要通过挂载点访问对应文件系统上的文件；</p><p>卸载：将某文件系统与当前根文件系统的关联关系预以移除；</p><p>mount：挂载</p><pre><code>mount 设备 挂载点    设备：        设备文件：/dev/sda5        卷标：LABEL=“”        UUID： UUID=“”    挂载点：目录        要求：            1、此目录没有被其它进程使用；            2、目录得事先存在；            3、目录中的原有的文件将会暂时隐藏；mount [options] [-o options] DEVICE MOUNT_POINT    -a: 表示挂载/etc/fstab文件中定义的所有文件系统    -n: 默认情况下，mount命令每挂载一个设备，都会把挂载的设备信息保存至/etc/mtab文件；使用—n选项意味着挂载设备时，不把信息写入此文件；    -t FSTYPE: 指定正在挂载设备上的文件系统的类型；不使用此选项时，mount会调用blkid命令获取对应文件系统的类型；    -r: 只读挂载，挂载光盘时常用此选项    -w: 读写挂载        -o: 指定额外的挂载选项，也即指定文件系统启用的属性；        remount: 重新挂载当前文件系统        ro: 挂载为只读        rw: 读写挂载</code></pre><p>umount: 卸载某文件系统</p><pre><code>umount 设备umount 挂载点卸载注意事项：    挂载的设备没有进程使用；</code></pre><p>mount -o loop 文件地址 MOUNT_POINT: 挂载本地回环设备（比如iso文件）</p><p>文件系统的配置文件&#x2F;etc&#x2F;fstab  </p><pre><code>OS在初始时，会自动挂载此文件中定义的每个文件系统要挂载的设备挂载点文件系统类型挂载选项（文件系统选项）转储频率(每多少天做一次完全备份)文件系统检测次序(只有根可以为1)/dev/sda5/mnt/testext3defaults0 0文件系统参数：async/sync 非同步/同步        设置磁盘是否以非同步方式运行！默认为 async（性能较佳）auto/noauto 自动/非自动    当下达 mount -a 时，此文件系统是否会被主动测试挂载。默认为 auto。rw/ro 可读写/只读    让该分区以可读写或者是只读的型态挂载上来，如果你想要分享的数据是不给使用者随意变更的， 这里也能够设置为只读。则不论在此文件系统的文件是否设置 w 权限，都无法写入喔！exec/noexec可执行/不可执行    限制在此文件系统内是否可以进行“执行”的工作？如果是纯粹用来储存数据的目录, 那么可以设置为 noexec 会比较安全。不过，这个参数也不能随便使用，因为你不知道该目录下是否默认会有可执行文件。举例来说，如果你将 noexec 设置在 /var ，当某些软件将一些可执行文件放置于 /var 下时，那就会产生很大的问题喔！ 因此，建议这个 noexec 最多仅设置于你自订或分享的一般数据目录。user/nouser允许/不允许    使用者挂载是否允许使用者使用 mount指令来挂载呢？一般而言，我们当然不希望一般身份的 user 能使用 mount 啰，因为太不安全了，因此这里应该要设置为 nouser 啰！suid/nosuid具有/不具有suid 权限    该文件系统是否允许 SUID 的存在？如果不是可执行文件放置目录，也可以设置为 nosuid 来取消这个功能！defaults 同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。默认情况使用 defaults 设置即可！</code></pre><p>mount -a：挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统  </p><p>fuser: 验正进程正在使用的文件或套接字文件  </p><pre><code>-v: 查看某文件上正在运行的进程-k: 杀死访问进程的文件-m: 指定MOUNT_POINTfuser -km MOUNT_POINT：终止正在访问此挂载点的所有进程</code></pre><h3 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h3><p>Swap（交换分区）：把不常访问的内存先写到磁盘中，然后释放这些内存，给其它更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</p><p>free :查看内存容量  </p><pre><code>-m ：以M为单位显示-g ：以g为单位显示-h ：单位换算[demo@localhost ~]$ free -h              total        used        free      shared  buff/cache   availableMem:           972M        625M        122M         16M        225M        191MSwap:          2.0G         51M        1.9Gfree是真正尚未被使用的物理内存数量。avaliable是从应用程序的角度看到的可用内存数量。Linux内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的buffer和cache。所以对于内核来说，buffer和cache都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的free内存可以用，内核就会从buffer和cache中回收内存来满足应用程序的请求。</code></pre><h4 id="创建swap实体分区"><a href="#创建swap实体分区" class="headerlink" title="创建swap实体分区"></a>创建swap实体分区</h4><ol><li><p>在硬盘中创建Swap分区</p></li><li><p>调整Swap分区类型为82</p><pre><code>fdisk 调整分区类型为 82gdisk 调整为8200</code></pre></li><li><p>开始创建Swap格式</p><pre><code> mkswap /dev/sda8  创建交换分区：      -L LABEL [root@localhost ~]# free          total        used        free      shared  buff/cache   availableMem:         995748      648288       73440       17184      274020      187264Swap:       2097148       51976     2045172</code></pre></li><li><p>开启Swap分区</p><pre><code> swapon /dev/sda8  开启交换分区 -a: 启用所有的定义在/etc/fstab文件中的交换设备 -s: 查看交换分区由哪些文件或者分区组成 [root@localhost ~]# swapon /dev/sdb5 [root@localhost ~]# free -h total        used        free      shared  buff/cache   available Mem:           972M        633M         71M         16M        267M        182M Swap:          3.0G         50M        3.0G [root@localhost var]# swapon -s FilenameType Size UsedPriority /dev/dm-1              partition   2097148 30652   -2 /var/swapfile           file   1048572   0      -3</code></pre></li></ol><p>swapoff &#x2F;dev&#x2F;sda8 关闭交换分区  </p><h4 id="创建swap文件分区"><a href="#创建swap文件分区" class="headerlink" title="创建swap文件分区"></a>创建swap文件分区</h4><p>如何在一个分区中创建一个文件，并把它添加到swap交换分区中  </p><blockquote><p>回环设备loopback, 使用软件来模拟实现硬件</p></blockquote><p>dd ： 读取、转换并输出数据</p><pre><code>if=数据来源of=数据存储目标bs=1 读取或输出的块大小count=2 拷贝多少个块seek=#: 创建数据文件时，创建文件跳过的空间大小dd if=/dev/sda of=/mnt/usb/mbr.backup bs=512 count=1dd if=/mnt/usb/mbr.backup of=/dev/sda bs=512 count=1</code></pre><p>首先，创建一个镜像文件：&#x2F;dev&#x2F;zero 读出的都是0</p><pre><code>dd if=/dev/zero of=/var/swapfile bs=1M count=1024 </code></pre><p>其次，将文件创建为swap分区</p><pre><code>[root@localhost var]# mkswap /var/swapfile Setting up swapspace version 1, size = 1048572 KiBno label, UUID=86213827-3a91-4171-9892-e9c8efd42e2b</code></pre><p>最后，开启swap分区文件</p><pre><code>[root@localhost var]# swapon /var/swapfileswapon: /var/swapfile: insecure permissions 0644, 0600 suggested.[root@localhost var]# free -h              total        used        free      shared  buff/cache   availableMem:           972M        631M         67M         16M        274M        182MSwap:          3.0G         50M        3.0G</code></pre><h3 id="xfs文件备份与还原"><a href="#xfs文件备份与还原" class="headerlink" title="xfs文件备份与还原"></a>xfs文件备份与还原</h3><h4 id="xfsdump备份"><a href="#xfsdump备份" class="headerlink" title="xfsdump备份"></a>xfsdump备份</h4><p>xfsdumcp是xfs文件系统备份工具，可以进行完整备份和增量备份。同时xfsdumcp是通过文件系统的UUID来分辨各个备份文件的，因此不能备份两个具有相同UUID的文件系统。</p><pre><code>[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据选项与参数：-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ （默认为 0，即完整备份）-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 设备文件名或其他一般文件文件名等-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态</code></pre><p>完整备份</p><pre><code># 1\. 先确定 /boot 是独立的文件系统喔！[root@study ~]# df -h /bootFilesystem Size Used Avail Use% Mounted on/dev/vda2 1014M 131M 884M 13% /boot # 挂载 /boot 的是 /dev/vda 设备！# 看！确实是独立的文件系统喔！ /boot 是挂载点！# 2\. 将完整备份的文件名记录成为 /srv/boot.dump ：[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /bootxfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /bootxfsdump: using file dump （drive_simple） strategyxfsdump: version 3.1.4 （dump format 3.0） - type ^C for status and controlxfsdump: level 0 dump of study.centos.vbird:/boot # 开始备份本机/boot系统xfsdump: dump date: Wed Jul 1 18:43:04 2015 # 备份的时间xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1 # 这次dump的IDxfsdump: session label: &quot;boot_all&quot; # 简单给予一个名字记忆xfsdump: ino map phase 1: constructing initial dump list # 开始备份程序xfsdump: ino map phase 2: skipping （no pruning necessary）xfsdump: ino map phase 3: skipping （only one dump stream）xfsdump: ino map construction completexfsdump: estimated dump size: 103188992 Bytesxfsdump: creating dump session media file 0 （media 0, file 0）xfsdump: dumping ino mapxfsdump: dumping directoriesxfsdump: dumping non-directory filesxfsdump: ending media filexfsdump: media file size 102872168 Bytesxfsdump: dump size （non-dir files） : 102637296 Bytesxfsdump: dump complete: 1 seconds elapsedxfsdump: Dump Summary:xfsdump: stream 0 /srv/boot.dump OK （success）xfsdump: Dump Status: SUCCESS# 在指令的下达方面，你也可以不加 -L 及 -M 的，只是那就会进入互动模式，要求你 enter！# 而执行 xfsdump 的过程中会出现如上的一些讯息，您可以自行仔细的观察！[root@study ~]# ll /srv/boot.dump-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump[root@study ~]# ll /var/lib/xfsdump/inventory-rw-r--r--. 1 root root 5080 Jul 1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj-rw-r--r--. 1 root root 312 Jul 1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex-rw-r--r--. 1 root root 576 Jul 1 18:43 fstab# 使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔！</code></pre><p>累积备份</p><pre><code># 0\. 看一下有没有任何文件系统被 xfsdump 过的数据？[root@study ~]# xfsdump -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:43:04 2015session label: &quot;boot_all&quot;session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1level: 0resumed: NOsubtree: NOstreams: 1stream 0:pathname: /srv/boot.dumpstart: ino 132 offset 0end: ino 2138243 offset 0interrupted: NOmedia files: 1media file 0:mfile index: 0mfile type: datamfile size: 102872168mfile start: ino 132 offset 0mfile end: ino 2138243 offset 0media label: &quot;boot_all&quot;media id: a6168ea6-1ca8-44c1-8d88-95c863202eabxfsdump: Dump Status: SUCCESS# 我们可以看到目前仅有一个 session 0 的备份数据而已！而且是 level 0 喔！# 1\. 先恶搞一下，创建一个大约 10 MB 的文件在 /boot 内：[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=1010+0 records in10+0 records out10485760 Bytes （10 MB） copied, 0.166128 seconds, 63.1 MB/s# 2\. 开始创建差异备份文件，此时我们使用 level 1 吧：[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot....（中间省略）....[root@study ~]# ll /srv/boot*-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump-rw-r--r--. 1 root root 10510952 Jul 1 18:46 /srv/boot.dump1# 看看文件大小，岂不是就是刚刚我们所创建的那个大文件的容量吗？ ^_^# 3\. 最后再看一下是否有记录 level 1 备份的时间点呢？[root@study ~]# xfsdump -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2....（中间省略）....session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1resumed: NOsubtree: NOstreams: 1stream 0:pathname: /srv/boot.dump1start: ino 455518 offset 0....（下面省略）....</code></pre><h4 id="xfsrestore还原"><a href="#xfsrestore还原" class="headerlink" title="xfsrestore还原"></a>xfsrestore还原</h4><pre><code>[root@study ~]# xfsrestore -I &amp;lt;==用来察看备份文件数据[root@study ~]# xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录 &amp;lt;==单一文件全系统复原[root@study ~]# xfsrestore [-f 备份文件] -r 待复原目录 &amp;lt;==通过累积备份文件来复原系统[root@study ~]# xfsrestore [-f 备份文件] -i 待复原目录 &amp;lt;==进入互动模式选项与参数：-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等-f ：后面接的就是备份文件！企业界很有可能会接 /dev/st0 等磁带机！我们这里接文件名！-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，需要这东西来达成累积复原-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！</code></pre><p>用xfsrestore查看xfsdump备份数据</p><pre><code>[root@study ~]# xfsrestore -Ifile system 0:fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837csession 0:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:43:04 2015session label: &quot;boot_all&quot;session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1level: 0pathname: /srv/boot.dumpmfile size: 102872168media label: &quot;boot_all&quot;session 1:mount point: study.centos.vbird:/bootdevice: study.centos.vbird:/dev/vda2time: Wed Jul 1 18:46:21 2015session label: &quot;boot_2&quot;session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8level: 1pathname: /srv/boot.dump1mfile size: 10510952media label: &quot;boot_2&quot;xfsrestore: Restore Status: SUCCESS</code></pre><p>完全备份还原</p><pre><code># 1\. 直接将数据给它还原回去即可！[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/bootxfsrestore: using file dump （drive_simple） strategyxfsrestore: version 3.1.4 （dump format 3.0） - type ^C for status and controlxfsrestore: using online session inventoryxfsrestore: searching media for directory dumpxfsrestore: examining media file 0xfsrestore: reading directoriesxfsrestore: 8 directories and 327 entries processedxfsrestore: directory post-processingxfsrestore: restoring non-directory filesxfsrestore: restore complete: 1 seconds elapsedxfsrestore: Restore Summary:xfsrestore: stream 0 /srv/boot.dump OK （success） # 是否是正确的文件啊？xfsrestore: Restore Status: SUCCESS如果只想要复原某一个目录或文件的话，直接加上“ -s 目录 ”这个选项与参数即可！</code></pre><p>部分备份还原</p><pre><code># 继续复原 level 1 到 /tmp/boot 当中！[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot</code></pre><p>仅还原部分文件的 xfsrestore 互动模式</p><pre><code># 1\. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！[root@study ~]# mkdir /tmp/boot3[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3========================== subtree selection dialog ==========================the following commands are available:pwdls [ &amp;lt;path&amp;gt; ]cd [ &amp;lt;path&amp;gt; ]add [ &amp;lt;path&amp;gt; ] # 可以加入复原文件列表中delete [ &amp;lt;path&amp;gt; ] # 从复原列表拿掉文件名！并非删除喔！extract # 开始复原动作！quithelp-&amp;gt; ls455517 initramfs-3.10.0-229.el7.x86_64kdump.img138 initramfs-3.10.0-229.el7.x86_64.img141 initrd-plymouth.img140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img137 vmlinuz-3.10.0-229.el7.x86_64136 symvers-3.10.0-229.el7.x86_64.gz135 config-3.10.0-229.el7.x86_64134 System.map-3.10.0-229.el7.x86_64133 .vmlinuz-3.10.0-229.el7.x86_64.hmac1048704 grub2/131 grub/-&amp;gt; add grub-&amp;gt; add grub2-&amp;gt; add config-3.10.0-229.el7.x86_64-&amp;gt; extract[root@study ~]# ls -l /tmp/boot3-rw-r--r--. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64drwxr-xr-x. 2 root root 26 May 4 17:52 grubdrwxr-xr-x. 6 root root 104 Jun 25 00:02 grub2# 就只会有 3 个文件名被复原，当然，如果文件名是目录，那下面的子文件当然也会被还原回来的！</code></pre><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>RAID中文名称为独立磁盘冗余阵列，简称为磁盘阵列。简单的说，RAID是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。RAID的主要优势有如下几点：大容量、高性能、可靠性、可管理性（它将多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器）。实现RAID的关键技术为镜像、数据条带、数据校验技术。RAID的每种级别仅代表磁盘组织方式不同，没有上下之分。  </p><p>一般来说， RAID 不可作为数据备份的替代方案，它对非磁盘故障等造成的数据丢失无能为力，比如病毒、人为破坏、意外删除等情形。此时的数据丢失是相对操作系统、文件系统、卷管理器或者应用系统来说的，对于 RAID 系统来身，数据都是完好的，没有发生丢失。所以，数据备份、灾 备等数据保护措施是非常必要的，与 RAID 相辅相成，保护数据在不同层次的安全性，防止发生数据丢失。</p><p>从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及软硬混合 RAID 三种。软 RAID 所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片，效率自然最低。硬 RAID 配备了专门的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片以及阵列缓冲，不占用 CPU 资源，但成本很高。软硬混合 RAID 具备 RAID 控制 &#x2F; 处理芯片，但缺乏 I&#x2F;O 处理芯片，需要 CPU 和驱动程序来完成，性能和成本 在软 RAID 和硬 RAID 之间。不建议使用软RAID。</p><p>常见raid级别如下，具体可参见文章<a href="https://blog.csdn.net/ensp1/article/details/81318135">https://blog.csdn.net/ensp1/article/details/81318135</a>，以上关于raid内容也是摘取自这篇文章。</p><h4 id="raid-0"><a href="#raid-0" class="headerlink" title="raid 0"></a>raid 0</h4><p>raid 0基于条带化技术。将数据按照stripe大小切分之后存放到各磁盘中</p><p><img src="https://img-blog.csdnimg.cn/20200701102411750.png" alt="image"></p><pre><code>    性能提升: 读，写    冗余能力（容错能力）: 无    空间利用率：nS    至少2块盘</code></pre><h4 id="raid-1"><a href="#raid-1" class="headerlink" title="raid 1"></a>raid 1</h4><p>raid 1基于镜像技术。将数据复制为N份存放到各磁盘中。</p><p><img src="https://img-blog.csdnimg.cn/20200701102427735.png" alt="image"></p><pre><code>    性能表现：写性能下降，读性能提升    冗余能力：有    空间利用率：1/2    至少2块盘</code></pre><h4 id="raid-5"><a href="#raid-5" class="headerlink" title="raid 5"></a>raid 5</h4><p>raid 5采用的是条带化和校验技术。将数据按照stripe大小切分并且计算数据校验信息然后分别存放到各磁盘中。当一个磁盘损坏后可以根据其它磁盘数据进行恢复，而且该技术中校验信息不是存放到固定磁盘中的。</p><p><img src="https://img-blog.csdnimg.cn/20200701102535811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vuc3Ax,size_16,color_FFFFFF,t_70" alt="image"></p><pre><code>    性能表现：读，写提升    冗余能力：有    空间利用率：(n-1)/n    至少需要3块</code></pre><p>raid 5 并发问题<a href="https://forum.huawei.com/enterprise/zh/thread/580916590801731584">https://forum.huawei.com/enterprise/zh/thread/580916590801731584</a></p><h4 id="raid10"><a href="#raid10" class="headerlink" title="raid10"></a>raid10</h4><p>raid 10 从下往上是先采用raid 1的镜像技术，再采用raid 0 的条带化技术。</p><p><img src="https://img-blog.csdnimg.cn/2020070110262565.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：1/2    至少需要4块</code></pre><h4 id="raid-01"><a href="#raid-01" class="headerlink" title="raid 01"></a>raid 01</h4><p>raid 01 从下往上是先采用raid 0的条带化技术，再采用raid 1的镜像技术。<br><img src="https://img-blog.csdnimg.cn/20200701102612237.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：1/2    至少需要4块</code></pre><h4 id="raid-50"><a href="#raid-50" class="headerlink" title="raid 50"></a>raid 50</h4><p>raid 50 从下往上是先采用raid 5技术，再采用raid 0 技术。<br><img src="https://img-blog.csdnimg.cn/20200701102710274.png" alt="image"></p><pre><code>    性能表现：读、写提升    冗余能力：有    空间利用率：(n-2)/n    至少需要6块</code></pre><h4 id="jbod"><a href="#jbod" class="headerlink" title="jbod"></a>jbod</h4><p>jbod并不是一个raid技术，它仅仅只是将几个磁盘组成一个大的存储设备。</p><p><img src="https://img-blog.csdnimg.cn/20200701102345894.png" alt="image"></p><pre><code>    性能表现：无提升    冗余能力：无    空间利用率：100%    至少需要2块</code></pre><h4 id="软件raid练习"><a href="#软件raid练习" class="headerlink" title="软件raid练习"></a>软件raid练习</h4><p>以下我们使用逻辑RAID作为练习，软件RAID在Linux中的设备名为&#x2F;dev&#x2F;md</p><p>mdadm：将任何块设备做成RAID </p><pre><code>模式化的命令：    创建模型        -C             专用选项：                -l: 级别                -n #: 设备个数（raid使用的磁盘数量）                -a &#123;yes|no&#125;: 是否自动为其创建设备文件                -c: CHUNK大小, 2^n，默认为64K                -x #: 指定空闲盘个数    管理模式        --add,         --remove,         --fail        mdadm /dev/md# --fail /dev/sda7    监控模式        -F：    增长模式        -G：    装配模式        -A:</code></pre><p>查看RAID阵列的详细信息</p><pre><code>mdadm -D /dev/md#    --detail</code></pre><p>停止阵列：</p><pre><code>mdadm -S /dev/md#    --stop</code></pre><p>将当前RAID信息保存至配置文件，以便以后进行装配：</p><pre><code>mdamd -D --scan &gt; /etc/mdadm.conf</code></pre><p>使用软raid操作如下：</p><pre><code>1. 在磁盘/dev/sdb上创建四个磁盘分区（6，7,8,9），每个分区的类型修改为fd[root@localhost var]# fdisk /dev/sdbWelcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): nAll primary partitions are in useAdding logical partition 6First sector (8394752-41943039, default 8394752): Using default value 8394752Last sector, +sectors or +size&#123;K,M,G&#125; (8394752-41943039, default 41943039): +1GPartition 6 of type Linux and of size 1 GiB is setCommand (m for help): tPartition number (1-8, default 8): fdPartition number (1-8, default 8): 6Hex code (type L to list all codes): fdChanged type of partition &#39;Linux&#39; to &#39;Linux raid autodetect&#39;2. 使用mdadm命令创建raid[root@localhost dev]# mdadm -C /dev/md0 -l 1 -n 2 -a yes -x 1 /dev/sdb&#123;6,7,8&#125;mdadm: Note: this array has metadata at the start and    may not be suitable as a boot device.  If you plan to    store &#39;/boot&#39; on this device please ensure that    your boot-loader understands md/v1.x metadata, or use    --metadata=0.90   （软raid不能作为启动分区）Continue creating array? Continue creating array? (y/n) ymdadm: Defaulting to version 1.2 metadatamdadm: array /dev/md0 started.[root@localhost dev]# ll -d /dev/md*brw-rw----. 1 root disk 9, 0 Jan  1 04:42 /dev/md03. 在raid上创建文件系统[root@localhost dev]# mke2fs /dev/md0mke2fs 1.42.9 (28-Dec-2013)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks65408 inodes, 261632 blocks13081 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=2684354568 block groups32768 blocks per group, 32768 fragments per group8176 inodes per groupSuperblock backups stored on blocks:     32768, 98304, 163840, 229376Allocating group tables: done                            Writing inode tables: done                            Writing superblocks and filesystem accounting information: done4. 挂载文件系统[root@localhost dev]# mount /dev/md0 /mnt5. 拷贝并查看文件[root@localhost mnt]# cp /etc/inittab ./[root@localhost mnt]# lltotal 20-rw-r--r--. 1 root root   511 Jan  1 04:47 inittabdrwx------. 2 root root 16384 Jan  1 04:46 lost+found[root@localhost mnt]# cat inittab # inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM....6. 查看raid信息[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:           Version : 1.2     Creation Time : Sat Jan  1 04:42:17 2022        Raid Level : raid1        Array Size : 1046528 (1022.00 MiB 1071.64 MB)     Used Dev Size : 1046528 (1022.00 MiB 1071.64 MB)      Raid Devices : 2     Total Devices : 3       Persistence : Superblock is persistent       Update Time : Sat Jan  1 04:47:39 2022             State : clean     Active Devices : 2   Working Devices : 3    Failed Devices : 0     Spare Devices : 1Consistency Policy : resync              Name : localhost.localdomain:0  (local to host localhost.localdomain)              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72            Events : 17    Number   Major   Minor   RaidDevice State       0       8       22        0      active sync   /dev/sdb6       1       8       23        1      active sync   /dev/sdb7       2       8       24        -      spare   /dev/sdb87. 查看raid状态    cat /proc/mdstat8. 将sdb6标识为损坏[root@localhost mnt]# mdadm /dev/md0 --fail /dev/sdb6mdadm: set /dev/sdb6 faulty in /dev/md0[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                    ...                    ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       0       8       22        -      faulty   /dev/sdb69. 在raid中移除sdb6[root@localhost mnt]# mdadm /dev/md0 --remove /dev/sdb6mdadm: hot removed /dev/sdb6 from /dev/md0[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                        ...                        ...Consistency Policy : resync              Name : localhost.localdomain:0  (local to host localhost.localdomain)              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72            Events : 37    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb710. 查看文件[root@localhost mnt]# cat inittab     # inittab is no longer used when using systemd.    #    # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.    ...  11. 在raid中添加磁盘[root@localhost mnt]# mdadm /dev/md0 --add /dev/sdb9mdadm: added /dev/sdb9[root@localhost mnt]# mdadm -D /dev/md0/dev/md0:                            ...                            ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       3       8       25        -      spare   /dev/sdb912. 停止raid[root@localhost /]# umount /dev/md0[root@localhost /]# mdadm -S /dev/md0mdadm: stopped /dev/md013. 重新挂载停止的raid[root@localhost /]# mdadm -A /dev/md0 /dev/sdb&#123;7,8,9&#125;mdadm: /dev/md0 has been started with 2 drives and 1 spare.[root@localhost /]# mdadm -D /dev/md0/dev/md0:                        ...                    ...    Number   Major   Minor   RaidDevice State       2       8       24        0      active sync   /dev/sdb8       1       8       23        1      active sync   /dev/sdb7       3       8       25        -      spare   /dev/sdb9 14. 查看文件 [root@localhost mnt]# cat inittab  # inittab is no longer used when using systemd. # # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.                         ... 15. 增长模式（将raid的热备磁盘增加到阵列工作磁盘中） mdadm -G /dev/md0 -n 4</code></pre><p>watch: 周期性地执行指定命令，并以全屏方式显示结果  </p><pre><code>-n #：指定周期长度，单位为秒，默认为2格式： watch -n # &#39;COMMAND&#39;</code></pre><h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>LVM是逻辑卷管理，它是Linux下磁盘分区的一种管理机制。该功能可以实现用户在无需停机的情况下可以调整各个分区的大小。</p><ul><li>PV(物理卷): 对应于我们的实体分区或硬盘</li><li>VG(卷  组): PV的组合</li><li>LV(逻辑卷): VG会被切成LV.这个LV就是最后格式化后给用户使用的。</li><li>PE(物理盘区): LVM管理的基础存储单元。LVM会把PV分成一个个PE进行存储。</li></ul><p>VG(卷组)的边界大小取决于PV(物理卷)组合的大小。</p><p>虽然PV组合成了VG，但是要真正使用就要划分LV(逻辑卷).在VG上可以划分多个LV，但这多个LV的大小加起来的和不能超过VG。如果发现VG不够用了，可以增加PV（物理卷），如果LV中空间不足可以扩大LV。</p><p>对卷创建快照，实际上就是对逻辑卷创建快照，而快照卷必须和逻辑卷处于同一个卷组中。也就意味这，如果你要打算对某个LV逻辑卷创建快照，就必须在同一个卷组中预留出空间给其中的某个逻辑卷创建快照卷。</p><blockquote><p>为什么能够实现VG的扩展以及LV的扩展？其实将PV放入VG时就要把PV这个物理卷的所有空间划分成一个物理块，及一个个存储单元。 这个块不是文件系统块，而是PE(PhysicalExtend物理盘区)，只要物理卷加入VG后，新加卷中划分的PE一定是和VG原因的PE大小相同。所以在创建VG时要制定VG所使用多大的PE。</p></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>【MD】:Multi Device 多设备</p><p>Mdadm是一个用户空间工具，是RAID的管理工具，与真正的RAID工作没有太大关系。真正的RAID集成在linux内核中</p><p>【DM】Device Mapper设备映射也是linux中一种常用的管理机制</p><p>DM 与MD近似，也能够提供一种逻辑设备。DM比MD的功能要强大。因为DM不仅仅能提供MD的RAID的功能，它还是逻辑卷（LVM2）基础。同时，在逻辑卷的基础上我们也能实现RAID0,RAID1这样的功能。DM与MD中有某些功能是重叠的，但并不完全重叠。所以，我们通常使用MD做RAID用DM做LVM2。DM像MD一样也是有一个核心模块，和许多子模块组成的。例如MD的核心有RAID0,RAID1,RAID5,RAID1+0等，由多个子模块完成不同的级别。DM也是有多个子模块完成不同的组织方式。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB89700cb2e26795cf3122f1060d00709e?method=download&shareKey=69125b23b714204d3f30cced62ae321b" alt="image"></p><p>例如：</p><ul><li>linear:有点类似Jbod。能够将多个磁盘的存储空间拼接在一块，当做一个磁盘来使用。</li><li>mirror:类似于镜像。</li><li>Snapshot：快照，向虚拟机一样，能够保留数据在做快照那一刻时的状态。快照，也可以说是访问同一条数据的另外一条路径。（主要用途是数据备份）</li><li>Multipath：多路径。多路径需要借助于DM模块来配置，能够实现数据存储设备的寻路能够通过多跟不同线来完成。</li></ul><h3 id="LVM使用流程"><a href="#LVM使用流程" class="headerlink" title="LVM使用流程"></a>LVM使用流程</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd1ecce605925715ca45bf008c7828c25?method=download&shareKey=40e1bb6104763d539a75435d5898d461" alt="image"></p><h3 id="LVM相关操作"><a href="#LVM相关操作" class="headerlink" title="LVM相关操作"></a>LVM相关操作</h3><p><a href="https://www.cnblogs.com/klb561/p/9074168.html">https://www.cnblogs.com/klb561/p/9074168.html</a></p><p>练习：<br>1、创建一个2G的分区，文件系统为ext2，卷标为DATA，块大小为1024，预留管理空间为磁盘分区的8%；挂载至&#x2F;backup目录，要求使用卷标进行挂载，且在挂载时启动此文件系统上的acl功能；</p><pre><code># mke2fs -L DATA -b 1024 -m 8  /dev/sda7# mount -o acl LABEL=DATA /backup# tune2fs -o acl /dev/sda7# mount LABEL=DATA /backup</code></pre><p>2、将此文件系统的超级块中的信息中包含了block和inode的行保存至&#x2F;tmp&#x2F;partition.txt中；</p><pre><code># tune2fs -l | egrep -i  &quot;block|inode&quot; &gt;&gt; /tmp/partition.txt  # dumpe2fs -h |</code></pre><p>3、复制&#x2F;etc目录中的所有文件至此文件系统；而后调整此文件系统类型为ext3，要求不能损坏已经复制而来的文件；</p><pre><code># cp -r /etc/*  /backup# tune2-j /dev/sda7</code></pre><p>4、调整其预留百分比为3%；</p><pre><code># tune2fs -m 3 -L DATA /dev/sda7</code></pre><p>5、以重新挂载的方式挂载此文件系统为不更新访问时间戳(表示在读文件时不去更改文件的access time属性），并验正其效果；</p><pre><code># stat /backup/inittab# cat /backup/inittab# stat # mount -o remount,noatime /backup# cat # stat</code></pre><p>6、对此文件系统强行做一次检测；</p><pre><code>e2fsck -f /dev/sda7</code></pre><p>7、删除复制而来的所有文件，并将此文件系统重新挂载为同步(sync)；而后再次复制&#x2F;etc目录中的所有文件至此挂载点，体验其性能变化；</p><pre><code># rm -rf /backup/*# mount -o remount,sync /backup# cp -r /etc/* /backup</code></pre><p>8、创建一个5G的分区，文件系统为ext3，卷标为MYDATA，块大小为1024，预留管理空间为磁盘分区的3%，要求开机后可以自动挂载至&#x2F;data目录，并且自动挂载的设备要使用卷标进行引用；</p><p>9、创建一个本地回环文件&#x2F;var&#x2F;swaptemp&#x2F;swapfile来用于swap，要求大小为512MB，卷标为SWAP-FILE，且开机自动启用此交换设备；</p><pre><code># mkdir /var/swaptemp# dd if=/dev/zero of=/var/swaptemp/swapfile bs=1M count=512# mkswap LABLE=SWAP-FILE /var/swaptemp/swapfile/etc/fstab/var/swaptemp/swapfile  swapswapdefaults0 0</code></pre><p>10、上述第一问，如何让其自动挂载的同时启用ACL功能；</p><pre><code>/etc/fstabLABEL=&#39;MYDATA&#39;/dataext3defaults,acl0 0</code></pre><p>11、 创建一个空间大小为10G的RAID5设备；其chuck大小为32k；要求此设备开机时可以自动挂载至&#x2F;backup目录；</p><p>12、练习：创建一个由两个物理卷组成的大小为20G的卷组myvg，要求其PE大小为16M；而后在此卷组中创建一个大小为5G的逻辑卷lv1，此逻辑卷要能在开机后自动挂载至&#x2F;users目录，且支持ACL功能；</p><p>13、缩减前面创建的逻辑卷lv1的大小至2G；</p><p>写一个脚本(前提：请为虚拟机新增一块硬盘，假设它为&#x2F;dev&#x2F;sdb)，为指定的硬盘创建分区： </p><p>1、列出当前系统上所有的磁盘，让用户选择，如果选择quit则退出脚本；如  果用户选择错误，就让用户重新选择；</p><p>2、当用户选择后，提醒用户确认接下来的操作可能会损坏数据，并请用户确认；如果用户选择y就继续，n就退出；否则，让用户重新选择；  </p><p>3、抹除那块硬盘上的所有分区(提示，抹除所有分区后执行sync命令，并让脚本睡眠3秒钟后再分区)；并为其创建三个主分区，第一个为20M，第二个为512M, 第三个为128M，且第三个为swap分区类型；(提示：将分区命令通过echo传送给fdisk即可实现)  </p><pre><code>fdisk -l |grep &quot;dd if=/dev/zero of=/dev/sdb bs=512 count=1sync （程序在运行过程中会先修改内存，到达一定限制后才会从内存写入磁盘。此命令就是将内存中的改变写入磁盘）sleep 3（dd修改硬盘速度很快，防止磁盘接受指令过快导致不识别）</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p> 本文介绍了磁盘的组成、磁盘分区、文件系统、swap分区、xfs文件系统的备份和还原、raid、lvm相关内容。<p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 请描述一下MBR和GPT是什么？</p><p>3. CentOS7 为啥将默认文件系统改为xfs</p><p>4. raid？raid0？ raid1？ raid5？raid01？ raid10？</p><p>5. LVM的作用？LVM的组成？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. 马哥Linux运维课程</p> <p>2. 鸟哥Linux私房菜-基础版</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="LVM RAID XFS" scheme="http://example.com/tags/LVM-RAID-XFS/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://example.com/2022/11/25/Linux-basic/"/>
    <id>http://example.com/2022/11/25/Linux-basic/</id>
    <published>2022-11-25T09:16:13.689Z</published>
    <updated>2022-11-25T09:16:13.688Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册</p></div><h2 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title="Linux的基本原则"></a>Linux的基本原则</h2><ul><li>一些皆文件</li><li>配置文件保存为纯文本格式</li><li>由目的单一的小程序组成，组合小程序完成复杂任务</li><li>尽量避免捕获用户接口（尽量减少与用户交互，比如如果命令运行成功则不会显示任何信息，没有消息是最好的消息）</li></ul><h2 id="Linux交互"><a href="#Linux交互" class="headerlink" title="Linux交互"></a>Linux交互</h2><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><p>Shell是用户和操作系统进行交互的软件。在Linux中它分为如下类型：  </p><blockquote><ul><li>GUI（图形界面交互）  <ul><li>Gnode  </li><li>KDE  </li><li>XFace</li></ul></li><li>CLI（命令行交互）  <ul><li>sh</li><li>bash</li><li>csh</li><li>zsh</li><li>ksh</li><li>tcsh</li></ul></li></ul></blockquote><p> 使用bash登陆Linux后会显示命令提示符（prompt）：</p><pre><code>[root@localhost ~]#    </code></pre><p>其中root是用户名，localhost是主机名，~代表家目录（&#x2F;代表根目录），#代表管理员（$代表普通用户）  </p><blockquote><p>虚拟终端(terminal)：Ctrl+Alt+F1-F6。Linux中有六个虚拟终端，每个虚拟终端都是一个Shell程序。一个用户可以在多个虚拟终端中同时登陆互不影响。CentOS 7之前可以使用init 3命令将图形shell转换为命令行Shell，使用init 5则相反。CentOS 7之后使用systemctl isolate multi-user.target或者systemctl isolate graphical.target切换</p></blockquote><h3 id="bash特性"><a href="#bash特性" class="headerlink" title="bash特性"></a>bash特性</h3><p>1、命令历史、命令补全 </p><pre><code>  history：查看命令历史 -c：清空命令历史 -d OFFSET [n]: 删除指定位置的命令 -w：保存命令历史至历史文件中  HISTSIZE环境变量: 命令历史缓冲区大小 ~/.bash_history：命令历史文件路径 命令历史的使用技巧：  !n      ：执行命令历史中的第n条命令； !-n     :执行命令历史中的倒数第n条命令；  !!      : 执行上一条命令； !string ：执行命令历史中最近一个以指定字符串开头的命令 !$      :引用前一个命令的最后一个参数;  Esc, .  :引用前一个命令的最后一个参数，先按Esc，再按.； Alt+. :引用前一个命令的最后一个参数，只在linux终端中可以； 命令、路径补全： 命令补全：搜索PATH环境变量所指定的每个路径下以我们给出的字符串开头的可执行文件，如果多于一个，两次tab，可以给出列表；否则将直接补全； 路径补全：搜索我们给出的起始路径下的每个文件名，并试图补全；</code></pre><p>2、管道、重定向<br>3、命令别名  </p><pre><code>alias CMDALIAS=&#39;COMMAND [options] [arguments]&#39; 定义别名在shell中定义的别名仅在当前shell生命周期中有效；别名的有效范围仅为当前shell进程；ualias CMDALIAS 解除别名\CMD ： 执行原命令</code></pre><p>4、命令行编辑  </p><pre><code>光标跳转：  Ctrl+a：跳到命令行首Ctrl+e：跳到命令行尾Ctrl+u: 删除光标至命令行首的内容Ctrl+k: 删除光标至命令行尾的内容Ctrl+l: 清屏</code></pre><p>5、命令行展开  </p><pre><code>命令替换: $(COMMAND), 反引号：`COMMAND`把命令中某个子命令替换为其执行结果的过程,如：：file-2013-02-28-14-53-31.txtbash支持的引号：``: 命令替换&quot;&quot;: 弱引用，可以实现变量替换&#39;&#39;: 强引用，不完成变量替换命令行展开：&#123;a,d&#125;_&#123;b,c&#125;mkdir -pv /mnt/test/&#123;x/m,y&#125;cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>6、文件名通配  </p><pre><code> globbing *: 任意长度的任意字符 ?：任意单个字符 []：匹配指定范围内的任意单个字符     [abc], [a-m], [a-z], [A-Z], [0-9], [a-zA-Z], [0-9a-zA-Z]     [:space:]：空白字符     [:punct:]：标点符号     [:lower:]：小写字母     [:upper:]: 大写字母     [:alpha:]: 大小写字母     [:digit:]: 数字     [:alnum:]: 数字和大小写字母  # man 7 glob  [^]: 匹配指定范围之外的任意单个字符  [[:alpha:]]*[[:space:]]*[^[:alpha:]]  注：文件通配符并不能匹配所有情况，比如：显示所有以数字结尾且文件名中不包含空白的文件；ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>7、变量<br>8、编程  </p><blockquote><p>注：&#x2F;etc&#x2F;shells：指定了当前系统可用的安全shell  </p></blockquote><div class="note green icon-padding flat"><p>练习：</p><p>1、创建a123, cd6, c78m, c1 my, m.z, k 67, 8yu, 789等文件；注意，以上文件是以逗号隔开的，其它符号都是文件名的组成部分；  </p><p>2、显示所有以a或m开头的文件；  </p><pre><code>ls [am]*  </code></pre><p>3、显示所有文件名中包含了数字的文件； </p> <pre><code>ls *[0-9]*   ls *[[:digit:]]*  </code></pre><p>4、显示所有以数字结尾且文件名中不包含空白的文件； </p> <pre><code>ls *[^[:space:]]*[0-9]   ?????????  </code></pre><p>5、显示文件名中包含了非字母或数字的特殊符号的文件； </p> <pre><code>ls *[^[:alnum:]]*</code></pre></div><h3 id="登陆式shell和非登陆式shell"><a href="#登陆式shell和非登陆式shell" class="headerlink" title="登陆式shell和非登陆式shell"></a>登陆式shell和非登陆式shell</h3><p>站在用户登录的角度来说，SHELL的类型：</p><ul><li><p>登录式shell:</p><ul><li>正常通过某终端登录</li><li>su - USERNAME </li><li>su -l USERNAME</li></ul></li><li><p>非登录式shell:</p><ul><li>su USERNAME</li><li>图形终端下打开命令窗口</li><li>自动执行的shell脚本</li></ul></li></ul><p>bash的配置文件：</p><ul><li><p>全局配置</p><pre><code>  /etc/profile    /etc/profile.d/*.sh    /etc/bashrc </code></pre></li><li><p>个人配置</p><pre><code>  ~/.bash_profile   ~/.bashrc</code></pre></li></ul><p>profile类的文件：  </p><ul><li>设定环境变量</li><li>运行命令或脚本</li></ul><p>bashrc类的文件：  </p><ul><li>设定本地变量</li><li>定义命令别名</li></ul><p>登录式shell如何读取配置文件？  </p><pre><code>/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</code></pre><p>非登录式shell如何配置文件?</p><pre><code>~/.bashrc --&gt; /etc/basrc --&gt; /etc/profile.d/*.sh</code></pre><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><p>Linux的一级目录如下：  </p><ul><li>&#x2F;boot: 系统启动相关的文件，如内核、initrd，以及grub(bootloader)  </li><li>&#x2F;dev: 设备文件  </li><li>设备文件：  <ul><li>块设备：随机访问，数据块  </li><li>字符设备：线性访问，按字符为单位  </li><li>设备号：主设备号（major）和次设备号（minor）</li></ul></li><li>&#x2F;etc：配置文件  </li><li>&#x2F;home：用户的家目录，每一个用户的家目录通常默认为&#x2F;home&#x2F;USERNAME  </li><li>&#x2F;root：管理员的家目录；  </li><li>&#x2F;lib：库文件  <ul><li>静态库,  .a   </li><li>动态库， .dll, .so (shared object)</li></ul></li><li>&#x2F;lib&#x2F;modules：内核模块文件  </li><li>&#x2F;media：挂载点目录，移动设备  </li><li>&#x2F;mnt：挂载点目录，额外的临时文件系统  </li><li>&#x2F;opt：可选目录，第三方程序的安装目录  </li><li>&#x2F;proc：伪文件系统，内核映射文件  </li><li>&#x2F;sys：伪文件系统，跟硬件设备相关的属性映射文件  </li><li>&#x2F;tmp：临时文件, &#x2F;var&#x2F;tmp  </li><li>&#x2F;var：可变化的文件  </li><li>&#x2F;bin: 可执行文件, 用户命令  </li><li>&#x2F;sbin：管理命令</li></ul><p>&#x2F;usr：shared, read-only  </p><ul><li>&#x2F;usr&#x2F;bin  </li><li>&#x2F;usr&#x2F;sbin  </li><li>&#x2F;usr&#x2F;lib</li></ul><p>&#x2F;usr&#x2F;local：  </p><ul><li>&#x2F;usr&#x2F;local&#x2F;bin  </li><li>&#x2F;usr&#x2F;local&#x2F;sbin  </li><li>&#x2F;usr&#x2F;local&#x2F;lib</li></ul><p>Linux中文件命名规则：  </p><ol><li>长度不能超过255个字符；  </li><li>不能使用&#x2F;当文件名  </li><li>严格区分大小写</li></ol><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>1、命令格式：</p><blockquote><p>命令 选项 参数</p><p>选项  </p><ul><li>短选项：- (多个选项可以组合 -a -b &#x3D; -ab)</li><li>长选项：- -</li></ul><p>参数：命令的作用对象</p></blockquote><p>2、命令类型：  </p><ul><li>内置命令(shell内置)，内部，内建  </li><li>外部命令：在文件系统的某个路径下有一个与命令名称相应的可执行文件</li></ul><p>3、type: 显示指令属于哪种类型</p><pre><code>[root@localhost ~]# type lsls is aliased to `ls --color=auto&#39; (命令别名)[root@localhost ~]# type cdcd is a shell builtin  （内部命令）[root@localhost ~]# type vivi is /usr/bin/vi （外部命令，对应文件）</code></pre><p>4、环境变量：命名的内存空间  </p><pre><code>变量赋值:NAME=Jerry  PATH: 使用冒号分隔的路径，命令的默认搜索路径  </code></pre><h3 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h3><blockquote><p>获得命令的使用帮助：<br>内部命令：help COMMAND<br>外部命令：COMMAND –help<br>在线手册：info COMMAND  (不常用)<br>文    档：&#x2F;usr&#x2F;share&#x2F;doc<br>命令手册：man COMMAND  </p><p>注：帮助中符号的意思<br>&lt;&gt;：必选     [] ：可选    … : 可以出现多次     | ：多选一    {} ：分组  </p></blockquote><p>man [指定章节数字] COMMAND  </p><pre><code>[root@localhost ~]# man DATEDATE(1)（1代表章节）                                                            User Commands                                                                   DATE(1)NAME（命令名称及功能简要说明）       date - print or set the system date and timeSYNOPSIS（用法说明，包括可用的选项）       date [OPTION]... [+FORMAT]       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION（命令功能的详尽说明，可能包括每一个选项的意义）     OPTIONS：说明每一个选项的意义         Display the current time in the given FORMAT, or set the system date.       Mandatory arguments to long options are mandatory for short options too.       -d, --date=STRING              display time described by STRING, not &#39;now&#39;FILES：此命令相关的配置文件        ......BUGS：       ......EXAMPLES：使用示例        ......SEE ALSO：另外参照      ...... 注：man文档查看方法    翻屏：        向后翻一屏：SPACE        向前翻一屏：b        向后翻一行：ENTER        向前翻一行：k    查找：        /KEYWORD: 向后            n: 下一个            N：前一个             ?KEYWORD：向前        n: 下一个        N：前一个         q: 退出</code></pre><p>man帮助中分章节，每个章节中存放不同类型的命令。比如1和5章节中都包含passwd。man命令如果不指定章节数，则默认显示最小章节的命令。查看5章节的passwd帮助使用man 5 passwd：  </p><ul><li>1：用户命令(&#x2F;bin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;bin)  </li><li>2：系统调用  </li><li>3：库用户  </li><li>4：特殊文件(设备文件)  </li><li>5：文件格式(配置文件的语法)  </li><li>6：游戏  </li><li>7：杂项(Miscellaneous)  </li><li>8: 管理命令(&#x2F;sbin, &#x2F;usr&#x2F;sbin, &#x2F;usr&#x2F;local&#x2F;sbin)</li></ul><p>whatis COMMAND：查看命令属于那些章节  </p><pre><code>[root@localhost ~]# whatis date  date (1)             - print or set the system date and time  date (1p)            - write the date and time</code></pre><div class="note blue icon-padding flat"><p>练习：</p>  <p>1. 使用date单独获取系统当前的年份、月份、日、小时、分钟、秒  </p>  <p>2. echo和printf是内部命令还是外部命令？  </p>  <p>3. echo和printf作用？  </p>  <p>4. echo和printf如何显示“The year is 2013. Today is 26.”为两行？  </p>  <p>5. file命令及其用法？</p>  </div><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>Linux时间有两种。一种是硬件时钟，另一种是系统时钟。</p><blockquote><ul><li>硬件时钟：CPU内置振荡器确定时间，同时CPU内置纽扣电源为振荡器提供电量。</li><li>系统时钟：Linux系统启动后，读取硬件时间并以软件方式模拟一个振荡器。date查看的便是系统时钟。</li></ul></blockquote><p>date：时间管理  </p><blockquote><p>-d 后跟字符串，显示字符串指定的时间 </p></blockquote><pre><code>[root@localhost ~]# date -d &quot;2 days ago&quot;  Fri Nov 19 02:05:54 EST 2021  [root@localhost ~]# date -d &quot;2021/11/21&quot;  Sun Nov 21 00:00:00 EST 2021    \\\\ 指定时间输出格式：  [root@localhost ~]# date -d &quot;10 days ago&quot; +&quot;The day is %Y-%m-%d %H:%M:%S%nThe day is %A&quot;  The day is 2021-11-11 02:27:09  The day is Thursday  \\\\ 修改时间  [root@localhost ~]# date -s &quot;2019-01-01 08:08:08&quot;Tue Jan  1 08:08:08 EST 2019</code></pre><p>clock、hwclock：硬件时钟</p><pre><code>-s 将系统时间更新为硬件时钟-w 将硬件时钟更新为系统时间</code></pre><p>cal：查看日历</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>ls（list）：列出指定路径下的文件  </p><pre><code> -l：长格式      文件类型：          -：普通文件 (f)          d: 目录文件          b: 块设备文件 (block)          c: 字符设备文件 (character)          l: 符号链接文件(symbolic link file)          p: 命令管道文件(pipe)          s: 套接字文件(socket)      文件权限：9位，每3位一组，每一组：rwx(读，写，执行), r--      文件硬链接的次数      文件的属主(owner)      文件的属组(group)      文件大小(size)，单位是字节      时间戳(timestamp)：最近一次被修改的时间          访问:access，文件最近访问时间          修改:modify，文件内容发生了改变          改变:change，metadata，元数据（如文件名、文件权限等属性改变）  -h：做单位转换，提高信息可读性  -a: 显示以.开头的隐藏文件      . 表示当前目录      .. 表示父目录  -A  显示以.开头的隐藏文件（除.和..目录）  -d: 显示目录自身属性，而不是目录下的内容。只显示当前文件或目录的属性  -i: index node, inode  -r: 逆序显示  -R: 递归(recursive)显示  </code></pre><p>pwd（Printing Working directory）：输出当前工作路径  </p><p>cd: change directory  </p><pre><code>cd ~: 进入指定用户的家目录  cd -:在当前目录和前一次所在的目录之间来回切换  </code></pre><p>mkdir：创建空目录  </p><pre><code>-p: 目录已存在不报错，父路径不存在自动创建  -v: verbose 打印出创建的每个目录mkdir -pv /mnt/test2/&#123;a,d&#125;_&#123;b,c&#125;：命令行展开，创建a_b, a_c, d_b, d_c目录</code></pre><p>tree：查看目录树</p><p>rmdir (remove directory)：删除空目录  </p><pre><code>-p: 如果父目录为空也会自动删除</code></pre><p>du ： 用于显示目录或文件的大小  </p><pre><code>-s 仅显示总计  -h 做单位换算，提高信息可读性</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>touch  修改文件的访问时间或修改时间为当前时间</p><pre><code> -a  仅仅改变访问时间   -m  仅仅改变修改时间   -t  指定[[CC]YY]MMDDhhmm[.ss]，代替当前时间   -c  不创建任何文件  </code></pre><blockquote><p>注：修改访问或修改任何一个时间都会自动修改改变时间为当前时间</p></blockquote><p>stat  展示文件或文件系统属性</p><pre><code>[root@localhost Music]# stat 11.txt   File: &#39;11.txt&#39;  Size: 14              Blocks: 8          IO Block: 4096   regular fileDevice: fd00h/64768d    Inode: 3169019     Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2019-01-01 01:01:00.000000000 -0500Modify: 2019-01-01 01:01:00.000000000 -0500Change: 2021-11-21 06:07:26.151522828 -0500 Birth: - </code></pre><p>nano：文本编辑器，不常用。</p><p>rm  删除文件或目录  </p><pre><code>-i 每一次删除之前都提示    -f 忽略不存在的文件，强制删除不提示  -r 递归删除</code></pre><p>cp SRC DEST 复制文件  </p><pre><code>-r：递归拷贝目录下内容  -d：复制时保留链接，如果是链接文件复制后依然是链接文件。  -i：存在目标文件则提示是否覆盖  -f：覆盖已经存在的目标文件而不给出提示。-p（小写）：保留这个文件原来的权限、属主、属组、时间戳。注：目前我用普通用户复制属主和属组还是变化。-P（大写）：如果是链接复制为链接-a：归档复制，常用于备份，相当于-dR --preserve=all多个文件到一个目录cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>mv SRC DEST  移动文件<br>mv -t DEST SRC  -t 是将源和目标位置反向</p><p>install  复制文件并可以设置属性  </p><pre><code> install -d DIRECOTRY ... ：创建目录     install -m ：可以指定权限   install SRC DEST 复制文件，复制之后会有执行权限   install -t DIRECTORY SRC...  </code></pre><h3 id="查看文本"><a href="#查看文本" class="headerlink" title="查看文本"></a>查看文本</h3><p>cat：连接文件并显示  </p><pre><code>-n 显示行号   -E 显示每一行的结束符$ [root@localhost Music]# cat file1 file2  this file is one.  this file is two.   [root@localhost Music]# cat -n file1 file2       1  this file is one.       2  this file is two.  [root@localhost Music]# cat -E file1 file2  this file is one.$  this file is two.$  [root@localhost Music]# cat -nE file1 file2       1  this file is one.$       2  this file is two.$</code></pre><p>tac: 将文件内容倒着显示</p><pre><code>[root@localhost Music]# tac file1this file is one, the line is 6.this file is one, the line is 5.this file is one, the line is 4.this file is one, the line is 3.this file is one, the line is 2.this file is one, the line is 1.</code></pre><p>more：以一页一页的方式查看文本，到文件末尾会自动退出。详细使用见man命令</p><p>less：less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。到文件末尾不会自动退出。</p><p>head:查看前n行   </p><pre><code>-n: 指定行数，默认为10  </code></pre><p>tail:查看后n行  </p><pre><code>-n: 指定行数，默认为10  -f: 会把文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>file： 辨识文件类型  </p><p>测试文件内容：</p><pre><code>Tom:25:male:2013/05/06  Jack:24:famale:2013/05/06Json:23:male:2013/05/06Mark:26:famale:2013/05/06</code></pre><p>cut:  分割文件中的每一行，并只显示选择字段</p><pre><code>-d: 指定字段分隔符，默认是空格-f: 指定要显示的字段    -f 1,3    -f 1-3[root@localhost Music]# cut -d : -f 1,3 file3Tom:maleJack:famaleJson:maleMark:famale</code></pre><p>sort：文本排序</p><pre><code>-n：数值排序-r: 降序-t: 字段分隔符-k: 以哪个字段为关键字进行排序-u: 排序后相同的行只显示一次-f: 排序时忽略字符大小写[root@localhost Music]# sort -n -t : -k 2 file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06WangWu:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06ZhaoLiu:26:male:2013/05/06LiSi:111:male:2013/05/06[root@localhost Music]# sort -n -t : -k 2 -u file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06LiSi:111:male:2013/05/06</code></pre><p>uniq:去重，去重时两行相邻并且内容一致才会认定是重复</p><pre><code>-c: 显示文件中行重复的次数-d: 只显示重复的行</code></pre><p>wc (word count)：文本统计，打印文件的行数、单词数、字节数</p><pre><code> -l：打印行数 -w：打印单词数 -c：打印字节数 -L：打印最长行的长度</code></pre><p>tr —— 转换或删除字符  </p><pre><code>tr [OPTION]... SET1 [SET2]      -d: 删除出现在字符集中的所有字符tr ab AB ：将文档中的a全部转换为A，将b全部转换为B，并不是ab转AB</code></pre><h3 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h3><p>locate: 非实时，模糊匹配，查找是根据全系统文件数据库进行的，速度快；<br>updatedb: 手动生成文件数据库（比较慢）</p><p>find：实时、精确、支持众多查找标准、遍历指定目录中的所有文件完成查找，速度慢；</p><pre><code>find 查找路径 匹配标准 查找到以后的处理运作查找路径：默认为当前目录匹配标准：默认为指定路径下的所有文件处理运作：默认为显示匹配标准：-name &#39;FILENAME&#39;：对文件名作精确匹配    文件名通配：        *：任意长度的任意字符        ?:任意单个字符        []:匹配指定范围内的任意单个字符-iname &#39;FILENAME&#39;: 文件名匹配时不区分大小写-regex PATTERN：基于正则表达式进行文件名匹配-user USERNAME: 根据属主查找-group GROUPNAME: 根据属组查找-uid UID: 根据UID查找-gid GID: 根据GID查找-nouser：查找没有属主的文件(删除用户之后，文件的属主则会变为用户对应的uid)-nogroup: 查找没有属组的文件(删除组之后，文件的属组则会变为用户对应的gid)-type     f: 普通文件    d：目录文件    c：字符设备文件    b：块设备文件    l：符号链接文件    p：命名管道文件    s：套接字文件-size [+|-] 大小 +大于 -小于    #k    #M    #G -mtime：在过去n天修改过的文件（单位：天）-ctime：在过去n天改变过的文件-atime：在过去n天访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-mmin：在过去n分钟修改过的文件（单位：分钟）-cmin：在过去n分钟改变过的文件-amin：在过去n分钟访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-maxdepth:递归层数-perm MODE：精确匹配    /MODE: 任意一位匹配即满足条件    -MODE: 文件权限能完全包含此MODE时才符合条件        -644    644: rw-r--r--    755: rwxr-xr-x    750: rwxr-x---    find ./ -perl -001 组合条件：以上条件之间的逻辑，    -a：与    -o：或    -not： 非     \( \)：括号要转义运作：    -print: 显示    -ls：类似ls -l的形式显示每一个文件的详细    -ok COMMAND &#123;&#125; \; 每一次操作都需要用户确认，命令中需要文件名的地方用&#123;&#125;代替    -exec COMMAND &#123;&#125; \;每一次操作都不需要用户确认，命令中需要文件名的地方用&#123;&#125;代替</code></pre><div class="note green icon-padding flat"><p>练习：  </p><p>1)在/mnt下创建boot和sysroot； </p> <p>2)在/mnt/boot下创建grub；  </p><p>3)在/mnt/sysroot下创建proc, sys, bin, sbin, lib, usr, var, etc, dev, home, root, tmp  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a)在/mnt/sysroot/usr下创建bin, sbin, lib  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b)在/mnt/sysroot/lib下创建modules  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)在/mnt/sysroot/var下创建run, log, lock  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d)在/mnt/sysroot/etc下创建init.d  </p><p>4)创建目录/backup；  </p><p>5)复制目录/etc至/backup目录中，并重命名为“etc-当前日期”，如etc-2013-02-26；要求保留文件原来的属性，保持链接文件；   </p><p>6）复制文件/etc/inittab为/tmp/inittab.new，并删除inittab.new文件的后两行； </p> <pre><code>  # cp /etc/inittab  /tmp/inittab.new    # nano /tmp/inittab.new</code></pre><p>7）描述GPL, BSD, Apache三个开源协定的大体联系及区别。</p><p>8）如何获取Linux当前最新的内核版本号？  </p>      <pre><code>  www.kernel.org</code></pre><p>9）列出你所了解的Linux发行版，并说明其跟Linux内核的关系。</p>  <pre><code>Linux, GNU: GNU/Linux, 源代码发行版：Fedora, RedHat(CentOS), SUSE, Debian(Ubuntu, Mint), Gentoo, LFS(Linux From Scratch)</code></pre><p>10）、查找/var目录下属主为root并且属组为mail的所有文件；</p><pre><code>find /var -user root -group mail</code></pre><p>11）、查找/usr目录下不属于root,bin或student的文件；</p><pre><code>find /usr -not -user root -a -not -user bin -a -not -user studentfind /usr -not \( -user root -o -user bin -o -user student \)</code></pre><p>12）、查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件；</p><pre><code>find /etc -mtime -7 -not \ ( -user root -o -user student \)find /etc -mtime -7 -not -user root -a -not -user student</code></pre><p>13）、查找当前系统上没有属主或属组且最近1天内曾被访问过的文件，并将其属主属组均修改为root；</p>    <pre><code>find / \( -nouser -o -nogroup \) -a -atime -1 -exec chown root:root &#123;&#125; \; </code></pre><p>14）、查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中；</p>    <pre><code>find /etc -size +1M &gt;&gt; /tmp/etc.largefiles</code></pre><p>15）、查找/etc目录下所有用户都没有写权限的文件，显示出其详细信息；</p><pre><code>find /etc -not -perm /222 -ls</code></pre></div><h3 id="用户、权限和组基础"><a href="#用户、权限和组基础" class="headerlink" title="用户、权限和组基础"></a>用户、权限和组基础</h3><p>Linux的用户管理使用如下机制：  </p><blockquote><p>认证机制：Authentication（使用用户名密码）<br>授权：Authorization（使用权限管理）<br>审计：Audition (日志)</p></blockquote><p>权限：  r, w, x</p><ul><li><p>文件：  </p><ul><li>r：可读，可以使用类似cat等命令查看文件内容；  </li><li>w：可写，可以编辑或删除此文件；  </li><li>x: 可执行，exacutable，可以命令提示符下当作命令提交给内核运行；</li></ul></li><li><p>目录：  </p><ul><li>r: 可以对此目录执行ls以列出内部的所有文件；  </li><li>w: 可以在此目录创建文件；  </li><li>x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；</li></ul></li></ul><p>权限和数字对应关系：</p><pre><code> 0 000 ---: 无权限 1 001 --x: 执行 2 010 -w-: 写 3 011 -wx: 写和执行 4 100 r--: 只读 5 101 r-x: 读和执行 6 110 rw-: 读写 7 111 rwx: 读写执行 755：rwxr-xr-x 640：rw-r-----  660: rw-rw---- 775: rwxrwxr-x</code></pre><p>用户：UID, &#x2F;etc&#x2F;passwd  </p><pre><code>account: 登录名password: 密码UID：GID：基本组IDcomment: 注释HOME DIR：家目录SHELL：用户的默认shell</code></pre><p>组：GID, &#x2F;etc&#x2F;group  </p><pre><code>组名：  密码：  GID:  以此组为其附加组的用户列表：</code></pre><p>影子口令：  </p><ul><li><p>用户：&#x2F;etc&#x2F;shadow</p><pre><code>  account: 登录名    encrypted password: 加密的密码    date of last password change：最近一次修改密码的时间  minimum password age：最短使用期限  maximum password age：最长使用期限  password warning period：警告时间  password inactivity period：非活动时间  account expiration date：账号过期时间</code></pre></li><li><p>组：&#x2F;etc&#x2F;gshadow</p></li></ul><p>影子文件中存储的密码都会进行相应的单向加密，加密算法分类如下：  </p><ul><li>对称加密：加密和解密使用同一个密码  </li><li>公钥加密：每个密码都成对儿出现，一个为私钥(secret key)，一个为公钥(public key)  </li><li>单向加密，散列加密：提取数据特征码，常用于数据完整性校验  <ul><li>1、雪崩效应  </li><li>2、定长输出  </li><li>MD5：Message Digest, 128位定长输出  </li><li>SHA1：Secure Hash Algorithm, 160位定长输出</li></ul></li></ul><p>用户类别：</p><ul><li>管理员：0  </li><li>普通用户： 1-65535  </li><li>系统用户：1-499  </li><li>一般用户：500-60000</li></ul><p>用户组类别：</p><ul><li>私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组  </li><li>基本组：创建用户时，指定的用户的默认组  </li><li>附加组，额外组：默认组以外的其它组</li></ul><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>useradd  [options]  USERNAME 添加用户  </p><pre><code> -u UID（用户ID） -g GID（基本组ID\基本组名，组必须存在） -G GID,...  （附加组） -c &quot;COMMENT&quot; （注释） -d /path/to/directory （家目录） -s SHELL （指定SHELL） -m -k （创建家目录。-k将/etc/skel下内容复制到家目录中） -M （不创建家目录） -r: 添加系统用户</code></pre><p>&#x2F;etc&#x2F;login.defs</p><blockquote><p>用于在Linux创建用户时，对用户的一些基本属性做默认设置。该配置对root用户无效。并且，当此文件中的配置与 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 文件中的用户信息有冲突时，系统会以&#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 为准。  </p></blockquote><p>userdel [option] USERNAME 删除用户  </p><pre><code> -r: 同时删除用户的家目录</code></pre><p>id：查看用户的帐号属性信息  </p><pre><code> -u: 显示用户ID -g: 显示基本组ID -G: 显示附加组ID -n: 每个选项不显示ID，显示名称[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><p>finger USERNAME：查看用户账号信息</p><p>usermod ： 修改用户帐号属性</p><pre><code>   -u UID 修改用户ID-g GID 修改基本组-a -G GID：不使用-a选项，会覆盖此前的附加组；-c：修改用户账户备注文字-d -m：修改用户的家目录，-m选项是将原来家目录中的内容复制新的家目录-s：修改用户shell-l：修改用户帐号名称-L：锁定帐号-U：解锁帐号usermod -a -G GROUPNAME，... USERNAME</code></pre><p>chage ： 修改用户密码信息</p><pre><code>-d: 最近一次的修改时间-E: 过期时间-I：非活动时间-m: 最短使用期限-M: 最长使用期限-W: 警告时间</code></pre><p>chsh: 修改用户的默认shell</p><p>chfn：修改注释信息</p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>passwd [USERNAME]</p><pre><code> --stdin ： 从标准输入中读入，主要用于管道传入 -l：锁定帐号  -u：解锁帐号   -d: 删除用户密码</code></pre><p>pwck：检查用户帐号完整性</p><pre><code>[root@localhost ~]# pwckuser &#39;ftp&#39;: directory &#39;/var/ftp&#39; does not existuser &#39;saslauth&#39;: directory &#39;/run/saslauthd&#39; does not existuser &#39;gluster&#39;: directory &#39;/run/gluster&#39; does not existuser &#39;pulse&#39;: directory &#39;/var/run/pulse&#39; does not existuser &#39;gnome-initial-setup&#39;: directory &#39;/run/gnome-initial-setup/&#39; does not existpwck: no changes</code></pre><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><p>groupadd 添加组</p><pre><code> -g GID 指定组ID -r：添加为系统组</code></pre><p>groupmod 修改组</p><pre><code> -g GID 修改组ID -n GRPNAME 更改组名称</code></pre><p>groupdel 删除组  </p><p>gpasswd：为组设定密码  </p><pre><code>gpasswd -d A GROUP ：将用户A从GROUP组移除  </code></pre><p>newgrp GRPNAME &lt;–&gt; exit：为用户指定临时基本组，需要指定组密码，用exit退出。</p><pre><code>[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ newgrp hadoop Password: [demo@localhost ~]$ iduid=1000(demo) gid=1001(hadoop) groups=1001(hadoop),1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ exitexit[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、创建一个用户mandriva，其ID号为2002，基本组为distro（组ID为3003），附加组为linux； </p>  <pre><code># groupadd -g 3003 distro# groupadd linux# useradd -u 2002 -g distro -G linux mandriva</code></pre><p>2、创建一个用户fedora，其全名为Fedora Community，默认shell为tcsh；</p>   <pre><code># useradd -c &quot;Fedora Community&quot; -s /bin/tcsh fedora</code></pre><p>3、修改mandriva的ID号为4004，基本组为linux，附加组为distro和fedora；</p> <pre><code># usermod -u 4004 -g linux -G distro,fedora mandriva</code></pre><p>4、给fedora加密码，并设定其密码最短使用期限为2天，最长为50天；</p> <pre><code># passwd -n 2 -x 50 fedora</code></pre><p>5、将mandriva的默认shell改为/bin/bash; </p> <pre><code>usermod -s /bin/bash mandirva</code></pre><p>6、添加系统用户hbase，且不允许其登录系统；</p> <pre><code># useradd -r -s /sbin/nologin hbase</code></pre></div><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>chown USERNAME file,…  改变文件属主(只有管理员可以使用此命令)  </p><pre><code> -R: 修改目录及其内部文件的属主 --reference=/path/to/somefile file,...：将文件的属主和属组和参照文件保持一致  chown    :GRPNAME file,...      ：改变文件属组信息 chown    .GRPNAME file,...      ：改变文件属组信息 chown USERNAME:GRPNAME file,... ：改变文件属主、属组信息 chown USERNAME.GRPNAME file,... ：改变文件属主、属组信息</code></pre><p>chgrp GRPNAME file,… 改变文件属组(只有管理员可以使用此命令)  </p><pre><code>-R: 修改目录及其内部文件的属组--reference=/path/to/somefile file,...：将文件的属组和参照文件保持一致  </code></pre><p>chmod MODE file,… 修改文件的权限</p><pre><code>-R: 修改目录及其内部文件的权限--reference=/path/to/somefile file,... ：将文件的权限和参照文件保持一致 修改文件权限：chmod  MODE file,...chomd  755 /home/demo/11.txt修改某类用户用户权限：u（属主）,g（属组）,o（其他）,a（所有）chmod 用户类别=MODE file,...chomd  u=rw /home/demo/11.txt修改某类用户的某位或某些位权限：u,g,o,achmod 用户类别+|-MODE file,...chmod u+w /home/demo/11.txtchmod ug+w /home/demo/11.txtchmod u+w,g+r /home/demo/11.txt</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、新建一个没有家目录的用户openstack；  </p>  <pre><code># useradd -M openstack  </code></pre><p>2、复制/etc/skel为/home/openstack；  </p>  <pre><code># cp -r /etc/skel /home/openstack  </code></pre><p>3、改变/home/openstack及其内部文件的属主属组均为openstack； </p>   <pre><code># chown -R openstack:openstack /home/openstack  </code></pre><p>4、/home/openstack及其内部的文件，属组和其它用户没有任何访问权限  </p>  <pre><code># chmod -R go= /home/openstack  （不修改属主的权限） </code></pre><p>5、不用命令如何添加一个用户  </p>  <pre><code>在/etc/passwd、/etc/shadow、/etc/group中分别添加一条记录使用openssl passwd -1 -salt xxxxxxxx（八位随机数） password 获取加密密码使用如上步骤</code></pre></div><h3 id="umask-遮掩码"><a href="#umask-遮掩码" class="headerlink" title="umask(遮掩码)"></a>umask(遮掩码)</h3><p>每个用户都会有一个遮掩码，遮掩码的作用是设置用户创建文件或目录的权限。Linux文件默认不具有执行权限。</p><pre><code>文件权限：666-umask （文件不具有执行权限） 目录权限：777-umask建议用权限位相减</code></pre><p>umask: 023</p><pre><code>文件：666-023=643 X （文件默认不能具有执行权限，如果算得的结果中有执行权限，则将其权限加1；故结果应为644）目录：777-023=754</code></pre><p>注：umask：027 创建的文件或目录其它用户无任何权限</p><h3 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h3><p>程序在运行过程中需要和I&#x2F;O设备打交道，而程序一般是不直接指定具体的输入和输出设备的。因此系统为我们提供了一些默认的输入和输出设置。</p><ul><li>默认输出设备：标准输出，STDOUT, 1（文件描述符），显示器</li><li>默认输入设备：标准输入, STDIN, 0（文件描述符） ，键盘  </li><li>标准错误输出：STDERR, 2（文件描述符）  ，显示器</li></ul><p>I&#x2F;O重定向就是修改程序的输入和输出的位置。</p><pre><code>&gt;:  标准输出覆盖输出&gt;&gt;：标准输出追加输出2&gt;: 重定向错误输出2&gt;&gt;:重定向错误输出追加方式&amp;&gt;: 重定向标准输出或错误输出至同一个文件&lt;：输入重定向&lt;&lt;：Here Document 此处生成文档    使用：&lt;&lt;EOF或者END         cat &lt;&lt; EOF         cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        [root@localhost ~]# cat        this is my first line.        this is my first line.        this is my secondary line.        this is my secondary line.        ^C        [root@localhost ~]# cat &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        this is my first line.        this is my secondary line.        [root@localhost ~]# cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        [root@localhost ~]# cat /tmp/myfile.txt         this is my first line.        this is my secondary line.</code></pre><p>tee：将标准输入写入标准输出和文件<br>        echo “hello world”|tee &#x2F;tmp&#x2F;hello.out</p><p>set可以对系统的某些功能性选项进行开启或关闭。 </p><pre><code>set -C: 禁止对已经存在文件使用覆盖重定向；  强制覆盖输出，则使用 &gt;|set +C: 关闭上述功能</code></pre><p>管道：一端流入，一端流出。即前一个命令的输出，作为后一个命令的输入。</p><pre><code>命令1 | 命令2 | 命令3 | ...echo “redhat” | passwd -stdin hive：使用命令行修改用户密码</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、统计/usr/bin/目录下的文件个数；</p><pre><code> # ls /usr/bin | wc -l</code></pre><p>2、取出当前系统上所有用户的shell，要求，每种shell只显示一次，并且按顺序进行显示；</p><pre><code> # cut -d: -f7 /etc/passwd | sort -u</code></pre><p>3、思考：如何显示/var/log目录下每个文件的内容类型？</p><pre><code> # file /var/log/* # file &#39;ls /var/log&#39;</code></pre><p>4、取出/etc/inittab文件的第6行；</p><pre><code> # head -6 /etc/inittab | tail -1</code></pre><p>5、取出/etc/passwd文件中倒数第9个用户的用户名和shell，显示到屏幕上并将其保存至/tmp/users文件中；</p><pre><code> # tail -9 /etc/passwd | head -1 | cut -d: -f1,7 | tee /tmp/users</code></pre><p>6、显示/etc目录下所有以pa开头的文件，并统计其个数；</p><pre><code># ls -d /etc/pa* | wc -l</code></pre><p>7、不使用文本编辑器，将alias cls=clear一行内容添加至当前用户的.bashrc文件中；</p><pre><code># echo &quot;alias cls=clear&quot; &gt;&gt; ~/.bashrc</code></pre></div><h2 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h2><h3 id="常规正则表达式"><a href="#常规正则表达式" class="headerlink" title="常规正则表达式"></a>常规正则表达式</h3><p>grep: 根据模式搜索文本，并将符合模式的文本行显示出来。</p><p>Pattern（模式）: 文本字符和正则表达式的元字符组合而成匹配条件</p><p>grep [options] PATTERN [FILE…]</p><pre><code>-i:忽略大小写--color : 匹配到的字符串亮色显示-v: 显示没有被模式匹配到的行-o：只显示被模式匹配到的字符串-E：使用扩展正则表达式-A：显示匹配字符串的前N行-B：显示匹配字符串的后N行-C：显示匹配字符串的前后N行</code></pre><p>Pattern（模式）元字符如下：</p><pre><code>字符匹配：：    .: 匹配任意单个字符    []: 匹配指定范围内的任意单个字符    [^]：匹配指定范围外的任意单个字符    字符集合：[:digit:], [:lower:], [:upper:], [:punct:], [:space:], [:alpha:], [:alnum:]匹配次数（贪婪模式）    *: 匹配其前面的字符任意次    \?: 匹配其前面的字符1次或0次    \&#123;m,n\&#125;:匹配其前面的字符至少m次，至多n次        a, b, ab, aab, acb, adb, amnb        a*b， a?b        a.*b            .*: 任意长度的任意字符        \&#123;1,\&#125;        \&#123;0,3\&#125;位置锚定：    ^: 锚定行首，此字符后面的任意内容必须出现在行首    $: 锚定行尾，此字符前面的任意内容必须出现在行尾    ^$: 空白行    \&lt;或\b: 锚定词首，其后面的任意字符必须作为单词首部出现    \&gt;或\b: 锚定词尾，其前面的任意字符必须作为单词的尾部出现分组：    \(\)    \(ab\)* 后向引用        \1: 引用第一个左括号以及与之对应的右括号所包括的所有内容如：demo    He love his lover.    She like her liker.    He like his lover.[root@localhost ~]# grep &quot;\(l..e\).*\1r\.&quot; demoHe love his lover.She like her liker.</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示/proc/meminfo文件中以不区分大小的s开头的行；</p><pre><code>grep -i &#39;^s&#39; /proc/meminfogrep &#39;^[sS]&#39; /proc/meminfo</code></pre><p>2、显示/etc/passwd中以nologin结尾的行;</p> <pre><code>grep &#39;nologin$&#39; /etc/passwd</code></pre><p>3、取出默认shell为/sbin/nologin的用户列表</p><pre><code>grep &quot;nologin$&#39; /etc/passwd | cut -d: -f1</code></pre><p>4、取出默认shell为bash，且其用户ID号最小的用户的用户名</p><pre><code>grep &#39;bash$&#39; /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1</code></pre><p>5、显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；</p>    <pre><code>grep &quot;^#[[:space:]]\&#123;1,\&#125;[^[:space:]]&quot; /etc/inittab</code></pre><p>6、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；</p>    grep ':[0-9]:' /etc/inittab<p>7、显示/boot/grub/grub.conf文件中以一个或多个空白字符开头的行；</p>    <pre><code>grep &#39;^[[:space:]]\&#123;1,\&#125;&#39; /boot/grub/grub.conf</code></pre><p>8、显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；</p><pre><code>grep &#39;^\([0-9]\).*\1$&#39; /etc/inittab</code></pre><p>9、找出某文件中的，1位数，或2位数；</p><pre><code>grep &#39;[0-9]\&#123;1,2\&#125;&#39; /proc/cpuinfogrep --color &#39;\&lt;[0-9]\&#123;1,2\&#125;\&gt;&#39; /proc/cpuinfo</code></pre><p>10、找出ifconfig命令结果中的1-255之间的整数；</p>  <p>9、查找当前系统上名字为student(必须出现在行首)的用户的帐号的相关信息, 文件为/etc/passwd</p>    <pre><code>grep &#39;^student\&gt;&#39; /etc/passwd | cut -d: -f3id -u student</code></pre><p>10、 分析/etc/inittab文件中如下文本中前两行的特征(每一行中出现在数字必须相同)，请写出可以精确找到类似两行的模式：</p><pre><code>l1:1:wait:/etc/rc.d/rc 1l3:3:wait:/etc/rc.d/rc 3grep &#39;^l\([0-9]\):\1.*\1$&#39; /etc/inittab</code></pre></div><h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h3><pre><code>grep -E = egrep    字符匹配：        .        []        [^]    次数匹配：        *:         ?:        +: 匹配其前面的字符至少1次        &#123;m,n&#125;    位置锚定：        ^        $        \&lt;        \&gt;    分组：        ()：分组        \1, \2, \3, ...    或者        |: or        C|cat: 为 C或cat 不是 Cat或cat</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示所有以数字结尾且文件名中不包含空白的文件；</p>    <pre><code>ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>2、找出/boot/grub/grub.conf文件中1-255之间的数字；</p>    <pre><code>\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;ifconfig | egrep &#39;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39; ifconfig | egrep --color &#39;(\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.)&#123;3&#125;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39;只查找前三类IP地址：（1-223）\&lt;([1-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[01][0-9]|22[0-3])\&gt;(\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;)&#123;2&#125;\.\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;</code></pre></div><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>   su [-l] 用户名：切换用户<br>   sudo COMMAND：完成部分特权指令</p><pre><code>配置文件/etc/sudoers文件中的如下行： 106 ## Allows people in group wheel to run all commands107 %wheel  ALL=(ALL)       ALL</code></pre><h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>SUID: 运行某程序时，相应进程的属主是程序文件自身的属主，而不是启动者；</p><pre><code>chmod u+s FILEchmod u-s FILE    如果FILE本身原来就有执行权限，则SUID显示为s；否则显示S；</code></pre><p>SGID: 运行某程序时，相应进程的属组是程序文件自身的属组，而不是启动者所属的基本组；同时该文件夹下所创建文件的属组是文件夹的属组，而不是创建用户的属组。</p><pre><code>chmod g+s FILEchmod g-s FILE    develop team, hadoop, hbase, hive    /tmp/project/        develop</code></pre><p>Sticky: 在一个公共目录，每个都可以创建文件，删除自己的文件，但不能删除别人的文件；</p><pre><code>chmod o+t DIRchmod o-t DIR</code></pre><p>注：以上三种权限就像rwx一样，也可以使用数字表示。比如 chmod 5755 &#x2F;backup&#x2F;test，而且umask的第一位数字代表的就是这三种权限。</p><h2 id="文件系统访问列表"><a href="#文件系统访问列表" class="headerlink" title="文件系统访问列表"></a>文件系统访问列表</h2><p>FACL(Filesystem Access Control List):利用文件扩展保存额外的访问控制权限 </p><p>setfacl</p><pre><code>-m: 设定    u:UID:perm    d:u：UID：perm 对目录有用，该目录下的新建文件拥有此默认权限    g:GID:perm    d:g：GID：perm 对目录有用，该目录下的新建文件拥有此默认权限-x：取消    u:UID    g:GID</code></pre><p>getfacl：查看文件系统访问权限</p><pre><code>[demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-group::rw-mask::rw- (这个会根据自动变化，为文件的最大权限)other::r--[demo@localhost ~]$ setfacl -m u:demo2:rwx demo.txt [demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-user:demo2:rwxgroup::rw-mask::rwx (这个会根据自动变化，为文件的最大权限)other::r--// 目录下设置默认权限[demo@localhost ~]$ setfacl -m d:u:demo2:rw- Desktop/[demo@localhost ~]$ cd Desktop/[demo@localhost Desktop]$ lltotal 0[demo@localhost Desktop]$ touch demo2.txt[demo@localhost Desktop]$ getfacl demo2.txt # file: demo2.txt# owner: demo# group: demouser::rw-user:demo2:rw-group::r-x#effective:r--mask::rw-other::r--[demo@localhost ~]$ lltotal 4-rw-rwxr--+ 1 demo demo 18 Dec 17 11:28 demo.txt  （具有acl属性权限结尾会有+）drwxr-xr-x+ 2 demo demo 23 Dec 25 04:42 Desktop</code></pre><h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><p>压缩算法不同，压缩比也会不同。常见的压缩格式有：gz, bz2, xz, zip, Z</p><p>Z格式（只能压缩单个文件。如果是文件夹，则是压缩文件夹内的每个文件）</p><pre><code>compress FILENAMEuncompress [demo@localhost ~]$ compress inittab -rw-r--r--. 1 demo demo 390 Dec 29 09:24 inittab.Z[demo@localhost ~]$ uncompress inittab.Z -rw-r--r--. 1 demo demo 511 Dec 29 09:24 inittab</code></pre><p>gz格式（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>gzip /PATH/TO/SOMEFILE：压缩完成后会删除原文件    -d：解压    -#：1-9，指定压缩比，默认是6；gunzip /PATH/TO/SOMEFILE.gz: 解压完成后会删除原文件zcat /PATH/TO/SOMEFILE.gz： 不解压的情况，查看文本文件的内容[demo@localhost ~]$ gzip inittab-rw-r--r--. 1 demo demo 316 Dec 29 09:24 inittab.gz</code></pre><p>bz2格式，该格式比gz有着更大压缩比（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>bzip2 /PATH/TO/SOMEFILE        -d: 解压        -#: 1-9,默认是6        -k: 压缩时保留原文件        bunzip2 /PATH/TO/SOMEFILE.bz2  解压完成后会删除原文件bzcat 不解压的情况，查看文本文件的内容[demo@localhost ~]$ bzip2 inittab -rw-r--r--. 1 demo demo 349 Dec 29 09:24 inittab.bz2</code></pre><p>xz格式：（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>xz /PATH/TO/SOMEFILE    -d：解压    -#: 1-9, 默认是6    -k: 压缩时保留原文件        unxz：解压xzdec:解压xzcat：不解压的情况，查看文本文件的内容。[demo@localhost ~]$ xz inittab -rw-r--r--. 1 demo demo 372 Dec 29 09:24 inittab.xz</code></pre><p>注：以上压缩和解压会删除原文件  </p><p>zip: 既归档（可以指定文件夹压缩）又压缩的工具  </p><pre><code>zip FILENAME.zip FILE1 FILE2 ...: 压缩后不删除原文件unzip FILENAME.zip ：解压</code></pre><p>tar: 归档工具, .tar</p><pre><code>-c: 创建归档文件-f FILE.tar: 操作的归档文件（压缩时是压缩后文件名，解压时是解压的文件名）-x: 展开归档--xattrs: 归档时，保留文件的扩展属性信息-t: 不展开归档，直接查看归档了哪些文件-C: 在解压时指定解压后文件的存放位置-zcf: 归档并调用gzip压缩-zxf: 调用gzip解压缩并展开归档，-z选项可省略-jcf: 归档并调用bzip2压缩-jxf:-Jcf: 归档并调xz压缩-Jxf:[demo@localhost etc]$ tar -Jcf conf.tar.xz ./etc  压缩[demo@localhost etc]$ tar -zxf conf.tar.xz -C ./etc/ 解压</code></pre><p>cpio: 归档工具，不常用</p><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><p>w：显示目前登陆系统的用户信息（su 切换用户还是显示原用户）</p><pre><code>[demo@localhost ~]$ w 04:52:09 up 33 min,  2 users,  load average: 0.00, 0.03, 0.13USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATdemo     :0       :0               04:20   ?xdm?   1:12   0.26s /usr/libexec/gndemo     pts/0    :0               04:21    1.00s  0.49s  0.01s w</code></pre><p>who：显示当前登录系统的用户（w的简化版）</p><pre><code>[demo2@localhost demo]$ whodemo     :0           2021-12-25 04:20 (:0)demo     pts/0        2021-12-25 04:21 (:0)</code></pre><p>sleep #：等待多少秒<br>whoami：显示当前用户</p><pre><code>[demo2@localhost demo]$ whoamidemo2</code></pre><p>last，显示&#x2F;var&#x2F;log&#x2F;wtmp文件，显示用户登录历史及系统重启历史  </p><pre><code>-n #: 显示最近#次的相关信息[demo2@localhost demo]$ lastdemo     pts/0        :0               Sat Dec 25 04:21   still logged in   demo     :0           :0               Sat Dec 25 04:20   still logged in   demo     :0           :0               Sat Dec 25 04:20 - 04:20  (00:00)    reboot   system boot  3.10.0-1062.el7. Sat Dec 25 04:19 - 04:57  (00:38)    demo     pts/0        :0               Fri Dec 17 11:27 - 11:34  (00:06)    demo     :0           :0               Fri Dec 17 11:25 - crash (7+16:53) </code></pre><p>lastb，&#x2F;var&#x2F;log&#x2F;btmp文件，显示用户错误的登录尝试  </p><pre><code>-n #:[root@localhost demo]# lastbdemo2    pts/0                         Sat Dec 25 04:59 - 04:59  (00:00)    btmp begins Sat Dec 25 04:59:30 2021</code></pre><p>lastlog: 显示每一个用户最近一次的成功登录信息；</p><pre><code>-u USERNAME: 显示特定用户最近的登录信息[root@localhost demo]# lastlogUsername         Port     From             Latestroot             pts/0                     Sat Dec 25 04:59:06 -0500 2021bin                                        **Never logged in**daemon                                     **Never logged in**adm                                        **Never logged in**lp                                         **Never logged in**</code></pre><p>basename：获取文件名</p><pre><code>$0: 执行脚本时的脚本路径及名称[root@localhost demo]# basename /home/demo/demo.txtdemo.txt</code></pre><p>mail：发送邮件</p><pre><code>[root@localhost demo]# mail -s &quot;first&quot; demo &lt; demo.txt [root@localhost demo]# su - demoLast login: Sat Dec 25 04:59:21 EST 2021 on pts/0[demo@localhost ~]$ mailHeirloom Mail version 12.5 7/5/10.  Type ? for help.&quot;/var/spool/mail/demo&quot;: 1 message 1 new&gt;N  1 root                  Sat Dec 25 05:10  18/617   &quot;first&quot;&amp; 1Message  1:From root@localhost.localdomain  Sat Dec 25 05:10:07 2021Return-Path: &lt;root@localhost.localdomain&gt;X-Original-To: demoDelivered-To: demo@localhost.localdomainDate: Sat, 25 Dec 2021 05:10:06 -0500To: demo@localhost.localdomainSubject: firstUser-Agent: Heirloom mailx 12.5 7/5/10Content-Type: text/plain; charset=us-asciiFrom: root@localhost.localdomain (root)Status: Rthis is new file.&amp; 注：用户邮件目录在/var/spool/mail</code></pre><p>hostname: 显示主机名</p><pre><code>如果当前主机的主机名不是www.magedu.com，就将其改为www.magedu.com如果当前主机的主机名是localhost，就将其改为www.magedu.com如果当前主机的主机名为空，或者为(none)，或者为localhost，就将其改为www.magedu.com[ -z `hostname` ] || [ `hostname` == &#39;(none)&#39; -o `hostname` == &#39;localhost&#39; ] &amp;&amp; hostname www.magedu.com</code></pre><p>生成随机数RANDOM: 0-32768</p><pre><code>随机数生成器：熵池(收集系统产生中断的时间作为随机数)/dev/random:(收集系次产生中断的时间作为随机数，如果不足需要等待)/dev/urandom:(收集系统产生中断的时间作为随机数，如果不足则自行生成随机数)[demo@localhost mail]$ echo $RANDOM12963</code></pre><p>ln [-s -v] SRC DEST：建立符号链接</p><pre><code>-s：建立软链接-v：建立硬链接[demo@localhost ~]$ ln -s /etc/inittab ./[root@localhost demo]# ln -v /etc/inittab inittab1 ‘inittab1’ =&gt; ‘/etc/inittab’[root@localhost demo]# lltotal 8-rw-rwxr--+ 1 demo demo  18 Dec 17 11:28 demo.txtdrwxr-xr-x+ 2 demo demo  23 Dec 25 04:42 Desktopdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Documentsdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Downloadslrwxrwxrwx. 1 demo demo  12 Dec 25 05:48 inittab -&gt; /etc/inittab-rw-r--r--. 2 root root 511 Aug  8  2019 inittab1drwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Musicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Picturesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Publicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Templatesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Videos硬链接：（存储文件的inode）    1、只能对文件创建，不能应用于目录；    2、不能跨文件系统；    3、创建硬链接会增加文件被链接的次数；    符号链接：（存储文件的字符串）    1、可应用于目录；    2、可以跨文件系统；    3、不会增加被链接文件的链接次数；    4、其大小为指定的路径所包含的字符个数；</code></pre><p>du </p><pre><code>-s ：查看文件夹总大小-h ：单位换算[root@localhost etc]# du20./fonts/conf.d24./fonts72./grub.d12./pki/rpm-gpg156./pki/ca-trust/extracted/java......42436[root@localhost etc]# du -s42436.[root@localhost etc]# du -sh42M</code></pre><p>df: </p><pre><code>-h：查看各文件系统的存储  -i：查看各文件系统inode的使用量[root@localhost etc]# df -hFilesystem               Size  Used Avail Use% Mounted ondevtmpfs                 470M     0  470M   0% /devtmpfs                    487M     0  487M   0% /dev/shmtmpfs                    487M  8.7M  478M   2% /runtmpfs                    487M     0  487M   0% /sys/fs/cgroup/dev/mapper/centos-root   17G  4.2G   13G  25% //dev/sda1               1014M  171M  844M  17% /boottmpfs                     98M  4.0K   98M   1% /run/user/42tmpfs                     98M   28K   98M   1% /run/user/1000/dev/sr0                 4.4G  4.4G     0 100% /run/media/demo/CentOS 7 x86_64tmpfs                     98M     0   98M   0% /run/user/0[root@localhost etc]# df -iFilesystem               Inodes  IUsed   IFree IUse% Mounted ondevtmpfs                 120210    391  119819    1% /devtmpfs                    124468      1  124467    1% /dev/shmtmpfs                    124468    995  123473    1% /runtmpfs                    124468     16  124452    1% /sys/fs/cgroup/dev/mapper/centos-root 8910848 155245 8755603    2% //dev/sda1                524288    340  523948    1% /boottmpfs                    124468      6  124462    1% /run/user/42tmpfs                    124468     19  124449    1% /run/user/1000/dev/sr0                      0      0       0     - /run/media/demo/CentOS 7 x86_64tmpfs                    124468      1  124467    1% /run/user/0</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>终端类型：</p><pre><code>console: 控制台 直接连接在计算机上的显示器、鼠标、键盘pty: 物理终端 (VGA) tty#: 虚拟终端 (VGA) 服务器ttyS#: 串行终端pts/#: 伪终端 通过ssh等登陆到linux主机上所使用的终端</code></pre><p>计算机总线：  </p><ul><li>地址总线：内存寻址  </li><li>数据总线：传输数据  </li><li>控制总线：控制指令</li></ul><p>进程：在每个进程看来，当前主机上只存在内核和当前进程。进程是程序的副本，进程是程序执行实例  </p><p>环境变量：  </p><pre><code>PATH  HISTSIZE  SHELL：用户当前使用SHELL  </code></pre><p>LANG&#x3D;en 修改Linux编码  </p><p>read ： 从标准输入中读取数据，并以空格切分。将分割结果存入后面参数中的变量。具体使用参见：<br><a href="https://www.runoob.com/linux/linux-comm-read.html">https://www.runoob.com/linux/linux-comm-read.html</a>  </p><pre><code>-p “PROMPT&quot;: 给出提示    </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;Linux的基本原则&quot;&gt;&lt;a href=&quot;#Linux的基本原则</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="http://example.com/2022/11/24/combute-basic/"/>
    <id>http://example.com/2022/11/24/combute-basic/</id>
    <published>2022-11-24T14:01:09.352Z</published>
    <updated>2022-11-24T14:01:09.350Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。</p></div><h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p>一台计算机由硬件、操作系统、程序组成。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9a0b832f9f9e5a95d12a836ab6d53630?method=download&shareKey=c00765b3eaaae0cc10aa16760a4ea955" alt="image"></p><p>硬件是计算机的基础，计算机的硬件组成可以分为运算器、控制器、存储器、输入&#x2F;输出设备。其中运算器和控制器是构成CPU的主要部分。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB760447eef5a97f121df438b75fc68075?method=download&shareKey=52b7a07d9bf375629854264a447c7701" alt="image"> </p><p>各元件之间的逻辑连接关系如下图所示。各元件之间通过地址线、数据线和控制信号线组成的本地总线链接。目前采用总线复用技术让地址、数据和控制信号使用同一条线路。早期的32位CPU中，其地址线和数据线分别都是32位，因此地址寻址空间范围为2的32次方字节，即从0到4G。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe1436f00078189da4932a78923a7936d?method=download&shareKey=e149a2a88f09bcd5958ce514327a5d64" alt="image"></p><p>早期系统通过两个芯片组进行各元件的连接，分别是： </p><ul><li>北桥：负责链接CPU、内存、显卡等高速设备  </li><li>南桥：负责链接硬盘、网卡、USB等低速设备</li></ul><p>目前北桥已经被整合到了CPU里面，下图为PRO-SW-W480-ACE主板说明图</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB09bda74bccf0f8982f80819324ce11e4?method=download&shareKey=300ea9f175b5eced9beef2872360c0d4" alt="image"></p><h2 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU由数十亿个微型晶体管构成。它的工作可以分为三个关键阶段：CPU从系统的主存中提取指令、然后解码该指令的实际内容、然后再由CPU的相关部分执行该指令。CPU内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连接。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5eeafe804430692ad0e9eead5a1a983?method=download&shareKey=687699edd636019aa7f7d2be4f2605db" alt="image">  </p><ul><li><strong>时    钟</strong>：负责发出CPU开始计时的时钟信号。</li><li><strong>运算器</strong>：负责运算从内存中读入寄存器的数据。 </li><li><strong>寄存器</strong>：可以看作内存的一种，用来暂存指令、数据和地址。  </li><li><strong>控制器</strong>：负责把内存上的指令，数据读入寄存器，并根据指令的结果控制计算机。</li></ul><p>根据功能的不同，可以将寄存器划分为下面这几类。 </p><table><thead><tr><th align="center">种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">累加寄存器</td><td align="center">存储运行的数据和运算后的数据</td></tr><tr><td align="center">标志寄存器</td><td align="center">用于反映处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td align="center">程序计数器</td><td align="center">用于存放下一条指令所在单元的地址的地方</td></tr><tr><td align="center">基址寄存器</td><td align="center">存储数据内存的起始位置</td></tr><tr><td align="center">变址寄存器</td><td align="center">存储基址寄存器的相对位置</td></tr><tr><td align="center">通用寄存器</td><td align="center">存储任意数据</td></tr><tr><td align="center">指令寄存器</td><td align="center">储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td align="center">栈寄存器</td><td align="center">存储栈区域的起始位置</td></tr></tbody></table><p>其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其它寄存器一般有多个。在内存中的存储通过地址编号来表示，而寄存器的种类则通过名字来区分。</p><p>至于CPU的指令集，那就是Intel的架构师们的工作。总之，CPU认识这些指令，并且能执行运算。这些指令我们称之为机器代码。机器代码由二进制的01字符串构成不利于人们阅读，因此人们在机器代码的基础上开发了一套汇编代码。汇编代码只有转换为本地代码才能运行。  </p><p>CPU 采用了一系列的措施加快指令的执行过程：</p><blockquote><p>流水线：有电子厂打工经历的读者肯定很熟悉这个流水线模式。CPU的流水线工作方式和工业生产上的流水线概念一样。就是将一个指令的执行过程也分解为多个步骤，CPU中的每个电路只执行其中一个步骤，这样前赴后继加快执行速度。CPU中多个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成几个步骤后再由这些电路单元分别执行。在执行过程中，指令源源不断的送往CPU。让每个电路单元都不闲着，这样就大大的加快了执行速度。  </p></blockquote><blockquote><p>超线程：CPU在进行线程切换的时候，要执行 切换各种寄存器状态等一些操作。把第一个线程的各种寄存器状态写回缓存中保存，然后把第二个线程的相关内容送到各种寄存器上。该过程必不可少，否则待会再将第一个线程切换回来时，不知道该线程的各个状态， 那还怎么接着继续执行呢？也正因为如此，所以这个过程比较慢，大概需要几万个时钟周期。所以后来做了这样的设计，把每个寄存器等都多做一个，就是多做一组寄存器(也包括一些其他相关电路等),CPU在执行A线程时，使用的第一组寄存器，切换到B线程，直接使用第二组寄存器，然后再切换A线程时，再使用第一组寄存器。，CPU就不用再傻傻的等着寄存器值的切换，线程切换只需要几个时钟周期就够了。对于普通的执行多任务的计算机，CPU线程切换是个非常频繁的操作，所以使用该技术就会节省大量的时钟周期。也就是相当于加快了CPU的执行速度。这就是CPU宣传参数中所谓的四核八线程的由来，其实就是超线程技术。(每个核多做一组寄存器等电路固然会占用宝贵的空间，但是它带来的优点远远大于缺点)。 </p></blockquote><blockquote><p>超标量技术: CPU可以在每个时钟周期内执行多个操作,可以实行指令的并行运算。在下面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出来并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。  </p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEBca6d3f2ca384de5d257b260ead71d115?method=download&shareKey=a7e4eea3d1346b04d1eada1e71e3b1bf" alt="image">  </p><blockquote><p>乱序执行: 我们认为程序都是顺序执行的。但是在CPU层面上，指令的执行顺序并不一定与它们在机器级程序(汇编)中的顺序一样。比如 a &#x3D; b+c; d++;这两个语句 不按照顺序执行也不会影响最终结果。当然这只是在CPU执行指令的层面，在程序员们看来，依旧认为程序是顺序执行的。</p></blockquote><blockquote><p>多核芯片：在芯片上有效地承载了四个微型芯片，每个微型芯片都有自己独立的CPU。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0b07646c4ecb73a0add4e1b5a2a9dfff?method=download&shareKey=7f5a08db7f8b74d0587553a87fafcb62" alt="image">  </p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是一种随机存储器（RAM），表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3eba4f99e53218fdec72fec4e08d9090?method=download&shareKey=f3f97c1a5885c0788caa1c94c0379427" alt="image">  </p><p>内存是编址的，编址的单位是字节（不是比特）。为了便于理解，我们把内存模型映射成为我们现实世界的模型。在现实世界中，内存的模型很像我们生活中的楼房。在这个楼房中，1层可以存储一个字节的数据，楼层号就是地址。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8993750ef7e3c66bac2868347fa8c680?method=download&shareKey=818ed6e9b52b16bec7a2247ba9780d24" alt="image">  </p><p>内存的内部是由各种IC电路（集成电路）组成的。内存IC是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的IC引脚来进行数据的读写。下面是一个虚拟的IC引脚示意图。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e9c34cbbec8776b666c35b72bb3b0bc?method=download&shareKey=c943f31ea062208c46c05dd12b6979de" alt="image">  </p><p>图中VCC和GND表示电源，A0-A9是地址信号的引脚，D0-D7表示的是数据信号、RD和WR都是控制信号。将电源链接到VCC和GND后，就可以对其它引脚传递0和1的信号，大多数情况下，+5V表示1,0V表示0。</p><p>我们都知道内存是用来存储数据，那么这个内存IC中能存储多少数据呢？D0-D7表示的是数据信号，也就是说，一次可以输入输出8bit &#x3D; 1byte的数据。A0~A9是地址信号共十个，表示可以指定00000 00000 - 11111 11111共2的10次方&#x3D;1024个地址。每个地址都会存放1byte的数据，因此我们可以得出内存IC的容量就是1KB。 </p><p>如果我们使用的是512MB的内存，这就相当于是512000（512*1000）个内存IC。当然，一台计算机不太可能有这么多个内存IC，然而，通常情况下，一个内存IC会有更多的引脚，也就能存储更多的数据。</p><p>内存IC读写过程如下：  </p><ul><li>写入数据：首先给VCC接通+5V的电源，给GND接通0V的电源，使用A0-A9来指定数据的存储场所，然后再把数据的值输入给D0-D7的数据信号，并把WR（write）的值置为1，执行完这些操作后，即可以向内存IC写入数据。</li><li>读入数据：只需要通过A0-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB81497d419eab65105d73ab9cd72f29b2?method=download&shareKey=86c4562d73c7ae4724b901546c120882" alt="image">  </p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘和内存都具有存储功能，它们都是存储设备。内存是一种高速、造价昂贵的存储设备，通过电流来实现存储。而磁盘则是速度较慢、造价低廉的存储设备，通过磁记录技术实现存储。磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，他们以5400rpm、7200rpm、10800rpm或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片33转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂的位置上的所有磁道合并起来，组成了一个柱面。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1ce7db34d73ec40ecb6ea85135bc6f18?method=download&shareKey=24f1372be02346ec060fc1de5f77a9e5" alt="image">  </p><blockquote><p>注意：固态硬盘不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中。与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p></blockquote><h3 id="输入-x2F-输出设备和设备驱动程序"><a href="#输入-x2F-输出设备和设备驱动程序" class="headerlink" title="输入&#x2F;输出设备和设备驱动程序"></a>输入&#x2F;输出设备和设备驱动程序</h3><p>I&#x2F;O设备一般包括两个部分：设备控制器和设备本身。任何一个硬件设备内部的电路可能跟CPU内部的电路都不一致。因此控制器负责将外部设备的信号转换成CPU总线上能理解的信号以及控制外部设备的传输速率、校验等功能。即I&#x2F;O控制器能够接受操作系统的指令，控制设备。I&#x2F;O控制器中也有用于临时保存输入输出数据的内存，这个内存我们称之为I&#x2F;O内存。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb7382c303e9917c95e83b6edbe2cdd4d?method=download&shareKey=dc3a6ac1c609075617bffd1cc30123a6" alt="image">  </p><h2 id="计算机概念"><a href="#计算机概念" class="headerlink" title="计算机概念"></a>计算机概念</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>计算机的运行离不开程序，程序由指令和数据两部分组成。计算机运行过程中CPU所使用的指令和数据都是来自于主内存。不论是软件程序还是数据，都必须要读入主内存后CPU才能利用。由于CPU的计算速度远大于从内存操作数据的速度，直观表现就是程序的性能在极大程度上受到内存访问次数的影响，内存访问次数越多，性能越差，所以才引入缓存从而减少cpu访问内存的次数。CPU中的缓存分为三层。一二级缓存私有，三级缓存共享。一级缓存分为数据缓存和指令缓存。缓存之所以可以减少CPU访问内存的次数是由于程序的局部性原理：</p><ul><li><p>时间局部性：被引用过一次的存储器位置中的内容在未来会被多次引用  </p></li><li><p>空间局部性：如果一个存储器位置的内容被引用，那么它附近的位置也很大概率被引用。</p></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbe7ae989c55df12e9e5c9016b7414bd6?method=download&shareKey=c3a7b4196623b3fed8259fab738a9928" alt="image"></p><h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>计算机接了这么多的外部设备，CPU如何区分不同的I&#x2F;O设备呢？类比计算机区分和互联网通信的各个进程的方法，计算机区分不同的和外部通信的进程靠的是套接字，也就是ip地址+端口号。这里cpu区分不同I&#x2F;O设备靠的也是端口号，称为I&#x2F;O端口，在一台计算机上I&#x2F;O端口的数目也是65535个。任何一个硬件设备通过IO总线接入计算机的时，它必须一开机就申请注册一批连续的I&#x2F;O端口。</p><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>为了更充分的使用CPU的运算能力，计算机引入了多任务的概念。多任务的实现依赖于CPU的时间切片以及虚拟内存地址两项技术。CPU的时间切片可以理解为一项任务运行5ms之后切换其它任务执行，即通过时间片轮转的方法使不同的程序并发执行。虚拟内存地址：由进程的虚地址构成的地址空间。我的理解是CPU中每一个进程的内存地址都是0-某个值（比如1024），根据不同的进程映射到不同的内存地址中。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>当计算机上运行多个任务，这时从键盘上输入数据或者移动鼠标时计算机是如何快速响应的？这就依赖于中断机制。程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断;</p><p>I&#x2F;O设备和CPU之间的信息交流通过中断机制来实现。中断是用来暂停当前正在运行的程序，然后跳转到其他程序运行的必要机制。  </p><p>每个设备发送信号通知CPU来查看，CPU怎么得知是哪个设备的信号呢？可能你会想到通过I&#x2F;O端口来识别，但I&#x2F;O端口是实现数据交互而不是识别信号交互的。中断控制器就登场了。</p><p>中断控制器（Interrupt Controller）：CPU外置芯片，接收中断信号。当某个外部设备（例如网卡卡）传来信号，CPU中断当前操作，将此信号接收至内存中。中断控制器上连接着中断线，每根线代表一个设备（不是固定的设备），用来区分外部设备，线路是可以复用的。</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>直接存储器访问（DMA）: 它可以控制内存和某些控制器之间的数据传输，而无需CPU的干预。比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B不经过CPU的处理。由CPU在内存中划好某次传输数据所需空间，并授权某根线路给DMA使用。否则，CPU 需要从来源把每一片段的数据复制到暂存器，之后把它们再次写回到新的进程空间。在这个时间中，CPU 对于其他的工作来说就无法使用。</p><p>DMA依赖于CPU外置的DMA控制器芯片。在实现DMA传输时，是由DMA控制器直接掌管总线。因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器。而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程必须经过DMA请求、DMA响应、DMA传输、DMA结束4个步骤。</p><p>在物理内存当中，最低地址段中的空间就预留给了DMA。一般大小为16M。在DMA最前面还有1M使用的空间是留给BIOS。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB672d57b20ba18a9f89a4467c41770579?method=download&shareKey=8b548b2cebd4abe92784a69245f7a0ad" alt="image">  </p><h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><p>现在CPU都是多核的，而在服务器领域使用多颗CPU是正常的。在SMP（对称多处理器：一块主板上有多个CPU插槽）多CPU架构中，每个插槽称为一个socket。当多个CPU访问同一个内存，传统上多CPU对于内存的访问是总线方式。总线方式就会存在资源争用和临界区问题，而且如果不断的增加CPU数量，内存的争用会愈演愈烈。这就体现在4核CPU的跑分性能达不到2核CPU的2倍，甚至1.5倍都没有。理论上来说这种方式实现12core以上的CPU已经没有太大的意义。</p><p>为了防止多颗CPU访问内存出现资源争用，可以为每个CPU分配一个专用内存并且配有专用控制器。由于内存属于系统级别，内核加载时有可能把数据加载到不同CPU的专用内存上。同时每个CPU都有自己的进程队列，这些队列会不断被内核进行平衡（rebalancing），确保资源平均利用。这样就有可能会导致1号CPU需要到2号CPU的专用内存上读写数据，这种现象称为非一致性内存访问（NUMA）。如下图，CPU 0-3访问自己的内存需要1、2、3步骤（3个时钟周期），而访问CPU 4-7的内存需要1、1a、2、3步骤，其中1a就需要消耗3个时钟周期。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe521c3b43a42aca7e0cc418a043987de?method=download&shareKey=9162438460f30dcd3d07f9640f50dd5c" alt="image"></p><p>在企业中，NUMA问题是很常见的。为了避免内存间交叉访问导致性能下降，可以禁止内核进行平衡。对于比较繁忙的、需要经常执行的批处理服务进程可以采取CPU绑定策略。</p><p>Intel的NUMA解决方案：放弃总线的访问方式，将CPU划分到多个Node中。每个node有自己独立的内存空间。各个node之间通过高速互联通讯，通讯通道被称为QuickPath Interconnect即QPI。</p><h3 id="多信道设计"><a href="#多信道设计" class="headerlink" title="多信道设计"></a>多信道设计</h3><p>由于所有的数据都必须要存放在主内存，所以主内存的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达64比特。为了加大这个宽度，芯片组厂商就将两个主内存汇整在一起。如果一支内存可达64比特，两支内存就可以达到128比特了。这就是双信道的设计理念。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>操作系统是硬件层上的一层软件，它提供系统调用并屏蔽了硬件层面上的差异。操作系统负责整个计算机的内存管理、硬件管理、文件管理以及应用管理。</p><p>有时我们将操作系统也称为虚拟机。因为我们只有一块cpu芯片(可能是多核心的)，只有一块内存，只有一个鼠标，只有一个键盘……。每个进程都想独占这一整套资源。cpu可以通过时间片轮转的方式将一个cpu芯片虚拟成多个cpu运行。内存的虚拟通过分页机制和虚拟地址空间。现在已经把计算机系统中最重要的两个部件CPU和内存虚拟出来了。剩下的那些I&#x2F;O设备如何虚拟呢？其实IO虚拟不需要专门去做，因为当前哪个进程获得了系统使用权，I&#x2F;O设备就交给该进程。</p><h3 id="CPU指令模式"><a href="#CPU指令模式" class="headerlink" title="CPU指令模式"></a>CPU指令模式</h3><p>有了操作系统之后。在某一时刻，要么是内核进程（操作系统核心）在上面运行，要么是用户空间进程在上面运行。内核在cpu上运行时称为内核模式，进程在cpu上运行时称为用户模式。在内存中内核占据的那段内存空间称为内核空间，用户进程占据的空间叫用户空间。用户模式时，进程是不能直接控制硬件的。这是因为在cpu内部，cpu制造商将cpu能运行的指令划分为４层(仅对x86架构而言)，ring0，ring1，ring2，ring3。由于历史原因，ring1和ring2并没有使用，linux只用了ring0和ring3。ring0称为内核模式，也称为特权指令模式，可以直接操控硬件。ring3是用户模式，可以执行一般指令。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>内存是易失性存储，即断电之后所有数据都会被清空。CPU运行所需的指令和数据都要从内存中获取。那么计算机是如何启动的呢？</p><p>在计算机主板上有一个ROM芯片（非易失性存储），该芯片存储了BIOS程序。在按下电源键之后系统会自动将BIOS程序加载到内存中然后执行。BIOS程序主要负责确定硬件是否正常，没有异常的话会根据配置文件（存储在CMOS）中的设备启动顺序查找MBR（主引导记录）。</p><p>MBR会查找活动分区，加载活动分区中的内核代码。然后将控制权转移给内核。接下来就进入操作系统的启动流程。</p><p>目前最新的是UEFI+GPT方式。UEFI可以认为是BIOS的升级版。GPT是MBR的升级版，2T以上的硬盘需要使用gpt。</p><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>设备驱动程序是I&#x2F;O系统的高层与设备控制器之间的通信程序，工作在内核模式。其主要任务：</p><ul><li>再把它转化为具体要求，发送给设备控制器，启动设备去执行。</li><li>反方向，它也将由设备控制器发来的信号，传送给上层软件。</li><li>接收上层软件发来的抽象I&#x2F;O要求（Linux中一切皆文件），如read、write等命令；</li></ul><h3 id="固件和驱动"><a href="#固件和驱动" class="headerlink" title="固件和驱动"></a>固件和驱动</h3><p>固件是直接写入ROM中的程序，比如BIOS。它直接和硬件打交道，指导硬件怎么干活。驱动负责操作系统和设备控制器之间的通信，告诉硬件要干什么。驱动一般运行在操作系统上，由操作系统进行管理。而固件往往直接”固定”在硬件上，直接控制硬件；</p><ul><li><p>eg1：利用打印机打印东西时：</p><ul><li>驱动的作用就是告诉打印机，要打印什么。</li><li>固件则告诉打印机，要怎么执行操作(把纸弄上打印区，然后喷墨，从哪里出纸等)。</li></ul></li><li><p>eg2. BIOS即为主板上的固件，功能 ：上电 - 进入BIOS - 自检(检查设备是否正常等) - 初始化各个模块(内存以及加载其他必要的固件等) - 转移控制到系统启动程序。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>本文简单介绍了计算机组成、硬件组成（CPU、内存、硬盘、IO设备）、连接方式、计算机基础概念（IO端口、中断、DMA、SMP、多通道）、计算机如何启动、驱动和固件等相关内容。在写作本文的过程中发现我脑子里有东西，但是什么都写不出来。上次面试时面试官问我计算机的组成？我只答出CPU、内存、硬盘、IO设备，CPU从内存中获取指令和数据。好尴尬！！！！真的只能说是一听就会，一说就废。</p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 简单介绍一下计算机的组成、计算机硬件的连接方式、多任务、计算机如何区分IO设备、CPU如何和IO设备之间交互、DMA机制、SMP架构、多通道、驱动的概念？</p><p>3. 计算机如何启动?</p><p>4. 驱动和固件的区别？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. B站马哥Linux运维课程中的操作系统基础  </p> <p>2. 内存--通俗理解：<https://blog.csdn.net/youhuakongzhi/article/details/109039652>  </p> <p>3. 程序员必知的硬核知识大全  </p> <p>4. 认识操作系统</p> <p>5. 图解操作系统</p> <p>6. Linux内核完全注释</p> <p>5. 固件和驱动区别 [https://blog.csdn.net/qq_36779888/article/details/108681805](https://blog.csdn.net/qq_36779888/article/details/108681805)</p> </div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;计算机组成&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="硬件 操作系统" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://example.com/2022/11/24/MakeBlog/"/>
    <id>http://example.com/2022/11/24/MakeBlog/</id>
    <published>2022-11-24T13:58:42.850Z</published>
    <updated>2022-11-24T13:58:42.850Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。</p><p></p><p>为什么选择个人博客？我搭建个人博客的原因是由于个人博客的样式可控。</p></div><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>机器环境: CentOS Linux release 7.7.1908 (Core)  </li><li>内核环境: 3.10.0-1062.el7.x86_64</li></ul><p>本博客采用nodejs平台+hexo框架+Butterfly主题+Github Pages搭建</p><ul><li>nodejs 是一个javascirpt的运行环境。我的理解为js原本是在浏览器上运行的脚本语言，有了nodejs之后，js就可以像shell脚本一样直接在机器上运行。</li><li>hexo框架是一个基于node.js的快速生成静态博客的框架</li><li>Butterfly是hexo博客的一款主题。</li><li>Github Pages是github提供的一项静态站点托管服务。</li></ul><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="搭建本地Hexo"><a href="#搭建本地Hexo" class="headerlink" title="搭建本地Hexo"></a>搭建本地Hexo</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>本文采用nodejs的二进制安装方式，由于我的Linux机器为CentOS 7，安装最新版会报错，因此我选择安装12.15.0这个版本。  </p><pre><code># 进入根目录cd /usr/local/# 获取二进制安装包wget https://nodejs.org/download/release/v12.15.0/node-v12.15.0-linux-x64.tar.gz# 解压tar -xf node-v12.15.0-linux-x64.tar.gzrm -rf node-v12.15.0-linux-x64.tar.gz# 创建软件包链接ln -sv node-v12.15.0-linux-x64/ nodejs# 让命令可以直接执行ln -sv /usr/local/nodejs/bin/node /usr/local/binln -sv /usr/local/nodejs/bin/npm /usr/local/bin# 检查是否能够运行[root@localhost bin]# node -vv12.15.0[root@localhost bin]# npm -v6.13.4</code></pre><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>查看是否安装git。hexo初始化的时候需要使用git命令从github下载hexo相关代码，后期将博客部署到github上也依赖git。</p><pre><code>[root@localhost bin]# git --versiongit version 1.8.3.1</code></pre><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>在家目录下建立blob目录作为hexo的根目录</p><pre><code># 建立目录mkdir ~/blobcd ~/blob# 永久设置npm源（不修改执行的时候会卡住）npm config set registry https://registry.npm.taobao.org# 安装hexo-cli，nodejs的npm相当于Linux的yum[root@localhost blob]# npm install -g hexo-cli/usr/local/node-v12.15.0-linux-x64/bin/hexo -&gt; /usr/local/node-v12.15.0-linux-x64/lib/node_modules/hexo-cli/bin/hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-cli@4.3.0added 59 packages from 51 contributors in 5.498s# 初始化文件夹hexo init# 安装 hexo 所需要的依赖包npm install</code></pre><p>在安装中遇到如下问题：Error: ENOENT: no such file or directory, uv_cwd</p><p>解决方案：重启终端</p><h4 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h4><p>hexo 常用命令：</p><ul><li>hexo g 生成静态网站</li><li>hexo s 启动服务器</li><li>hexo d 部署</li><li>hexo clean 清理生成的静态网站</li></ul><p>部署：</p><pre><code>[root@192 blob]# hexo g &amp;&amp; hexo sINFO  Validating configINFO  Start processingINFO  Files loaded in 130 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2022/index.htmlINFO  Generated: archives/2022/11/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/jquery.fancybox.min.cssINFO  Generated: js/script.jsINFO  Generated: css/style.cssINFO  Generated: 2022/11/21/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.woff2INFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.min.jsINFO  Generated: js/jquery-3.4.1.min.jsINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: css/images/banner.jpgINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  17 files generated in 410 msINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</code></pre><p>访问网站：<br><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204625063.png" alt="images"></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo的主题可以在github仓库中搜索hexo-theme或者hexo官网查找，本文使用的主题为butterfly。</p><pre><code># 从github仓库中下载主题（hexo根目录中）：git https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly# 修改hexo根目录下_config.xml 配置文件theme: landscape 改为 theme: butterfly# 重新部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>在浏览器中打开报如下问题：</p><pre><code># 显示内容：extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pug解决方案（hexo根目录）：npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></pre><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c51af39bb0820efc4ea19d42c7252b2?method=download&shareKey=577f858ad5b22a1545471f53e5f2416e" alt="image"></p><h3 id="优化主题"><a href="#优化主题" class="headerlink" title="优化主题"></a>优化主题</h3><p>至此，上面的博客已经具有了一个框架。下面我们进行相应的优化。参考博客：  </p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>更改博客主题、描述、作者、语言、时区（hexo根目录下配置文件）</p><pre><code># Sitetitle: 知与行subtitle: &#39;&#39;description: &#39;学而不思则惘，思而不学则殆&#39;keywords:  author: QiYanlanguage: zh-CNtimezone: Asia/Shanghai</code></pre><p>图像修改：背景图下载地址<a href="https://wallhaven.cc/">https://wallhaven.cc/</a> ，图像放到hexo_root&#x2F;themes&#x2F;主题名&#x2F;source&#x2F;img&#x2F;。如下修改的是主题配置文件（hexo_root&#x2F;theme&#x2F;主题名&#x2F;_config.xml）。</p><pre><code># 主页图index_img: /img/background.jpg    # 头像：avatar:  img: /img/avatar.png#文档图（cover:  # display the cover or not (是否顯示文章封面)  index_enable: false  aside_enable: false  archives_enable: false  # the position of cover in home page (封面顯示的位置)  # left/right/both  position: both  # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)  default_cover: </code></pre><p>cover中设置default_cover之后，文件列表和文章内容的top图都是同一张图。<br>解决方案：<a href="https://blog.csdn.net/zzq0523/article/details/122954271">https://blog.csdn.net/zzq0523/article/details/122954271</a>）</p><p>修改菜单：</p><pre><code>menu:   首页: / || fas fa-home   归档: /archives/ || fas fa-archive   标签: /tags/ || fas fa-tags   分类: /categories/ || fas fa-folder-open  # List||fas fa-list:  #   Music: /music/ || fas fa-music  #   Movie: /movies/ || fas fa-video  # Link: /link/ || fas fa-link   关于: /about/ || fas fa-heart</code></pre><p>创建相关页面</p><pre><code>#前往你的 Hexo 博客的根目錄hexo new page tags#找到source/tags/index.md這個文件添加 type: &quot;tags&quot;并将title后的名字改为中文 ---title: 標籤date: 2018-01-05 00:00:00type: &quot;tags&quot;---# 添加分类页hexo new page categories---title: 分类date: 2022-11-21 08:20:51types: &quot;categories&quot;---</code></pre><p>添加动态文字：</p><pre><code>subtitle:  enable: true  # Typewriter Effect (打字效果)  effect: true  # Effect Speed Options (打字效果速度參數)  startDelay: 300 # time before typing starts in milliseconds  typeSpeed: 150 # type speed in milliseconds  backSpeed: 50 # backspacing speed in milliseconds  # loop (循環打字)  loop: true  # source 調用第三方服務  # source: false 關閉調用  # source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/  # source: 2  調用今日詩詞（簡體） https://www.jinrishici.com/  # subtitle 會先顯示 source , 再顯示 sub 的內容  source: false  # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字  sub:    - 今日事&amp;#44;今日畢    - Never put off till tomorrow what you can do today</code></pre><p>安装搜索框</p><pre><code>[root@192 butterfly]# npm install hexo-generator-search --savenpm notice created a lockfile as package-lock.json. You should commit this file.+ hexo-generator-search@2.4.3added 6 packages from 5 contributors in 1.551s# 修改主题配置文件local_search:  enable: true# 重启hexo否则会报错hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>添加字数统计功能：</p><pre><code>npm install hexo-wordcount --save# 修改主题配置文件wordcount:     enable: true# 重启hexo</code></pre><p>给文章列表添加字数统计：  </p><p><a href="http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/">http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/</a></p><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p><a href="https://imbhj.com/25c13146/">https://imbhj.com/25c13146/</a><br><a href="https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/">https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/</a></p><h2 id="托管静态页面"><a href="#托管静态页面" class="headerlink" title="托管静态页面"></a>托管静态页面</h2><h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><p>首先在github中注册账号  </p><p>创建仓库。每个用户只能创建一个github pages，因此仓库名称必须为&lt;用户名&gt;.github.io，否则创建的为普通仓库</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224741804.png" alt="image">、</p><p>在github pages仓库中创建一个index.html文件用于测试  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225639083.png" alt="image"></p><p>在浏览器页面输入https:&#x2F;&#x2F;用户名.github.io&#x2F; 查看是否访问成功  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229230057034.png" alt="image"></p><h3 id="免密登录github"><a href="#免密登录github" class="headerlink" title="免密登录github"></a>免密登录github</h3><p>CentOS中生成登录密钥：</p><pre><code># 其中 邮箱名 是你注册 GitHub 的邮箱ssh-keygen -t rsa -C &quot;邮箱名&quot; # 后面输入三个回车</code></pre><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image"></p><p>CentOS 进入~&#x2F;.ssh目录，复制id_rsa.pub中的内容。将公钥复制到github中。</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235220955.png" alt="image"></p><p>测试是否能够正常连接：</p><pre><code>[root@192 images]# ssh -T git@github.comHi qiyankuo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>安装部署插件</p><pre><code># 这样执行会报错[root@192 blob]# npm install hexo-deplyer-gitnpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmmirror.com/hexo-deplyer-git - [NOT_FOUND] hexo-deplyer-git not foundnpm ERR! 404 npm ERR! 404  &#39;hexo-deplyer-git@latest&#39; is not in the npm registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404 npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     /root/.npm/_logs/2022-11-22T02_25_42_682Z-debug.log# 正确方式[root@192 blob]# npm install hexo-deployer-git --save# 修改hexo根目录下配置文件deploy:  type: &#39;git&#39;  repo: git@github.com:用户名/仓库名  #如：git@github.com:qiyankuo/qiyankuo.github.io.git  branch: main# 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </code></pre><p>在浏览器中输入https:&#x2F;&#x2F;用户名.github.io&#x2F;进行测试（这个可能会有些延迟）</p><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><h3 id="git相关概念"><a href="#git相关概念" class="headerlink" title="git相关概念"></a>git相关概念</h3><p><a href="https://www.runoob.com/git/git-workspace-index-repo.html">https://www.runoob.com/git/git-workspace-index-repo.html</a></p><h3 id="创建仓库并上传图片"><a href="#创建仓库并上传图片" class="headerlink" title="创建仓库并上传图片"></a>创建仓库并上传图片</h3><p>在github中新建仓库images</p><p>在CentOS下关联github仓库，进行图片管理</p><pre><code># 先进入准备放置github仓库的目录cd ...# 克隆仓库git clone 仓库地址 # 如：https://github.io/qiyankuo/images# 将需要添加的图片移动到仓库目录中mv ... ...git add 文件名  # 添加xyz文件至indexgit commit -m &quot;描述&quot;  # 提交git remote origin git@github.com:qiyankuo/images.git  # 设置远程连接别名git push origin main  # 将本地内容提交到github中</code></pre><h3 id="引用图片地址"><a href="#引用图片地址" class="headerlink" title="引用图片地址"></a>引用图片地址</h3><p>在github中找到图像发现无法显示，在图片上右键在新标签中打开图像显示url如下：<a href="https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg">https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg</a></p><p>参照网上教程使用免费的CDN服务jsDriver进行github加速，但是我发现这个好像不能用。故我采用如下方式：</p><ul><li><p>github镜像 <a href="https://hub.nuaa.cf/">https://hub.nuaa.cf/</a> 访问上面的图片将githubusercontent.com修改为nuaa.cf。即</p><pre><code>  https://raw.nuaa.cf/qiyankuo/images/main/hexo/betterfly.jpg  注：这种方式发现本地部署和github pages中都无法查看</code></pre></li><li><p>Github RAW 加速服务<a href="https://www.7ed.net/start/raw-cdn.html">https://www.7ed.net/start/raw-cdn.html</a>，在githubusercontent中添加上s就可以了。即</p><pre><code>  [https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg](https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg)  注：这种方式发现本地部署可以查看，浏览器也可以查看，但是github pages页面中无法查看</code></pre></li><li><p>最终采用有道云笔记存储图片，或者可以用gitee存储图片。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>    经过了三四天的时间终于将自己的个人博客搭建完成。搭建博客的过程中也遇到了很多问题。首先，原本准备使用next主题，但是这个主题有一些地方无法调整，当时想过放弃或者先搭建一个后期再通过学习前端进行修改。之后当看到51cto的博客样式，这个博客已经满足我的基本需要。当我无意中找到butterfly官网的文章之后，感觉这就是我想要的文章样式。</p><p>    其次，起初采用github搭建，但是考虑到github国内访问速度较慢。开始转gitee上搭建，但是gitee需要实名认证（被拒了）。继续github进行搭建。</p><p>    搭建完之后发现jsDriver不能使用，最终找到了Github RAW 加速服务进行替换。后期计划的话博客样式应该还会不断的进行调整。最后，准备使用typora和picgo搭建书写博客的环境，typora收费，picgo官网上说仅在Windows和macos进行了测试。</p><p>    目前更新了文章之后发布都是手动发布的，图片也是手动上传。我准备做一个shell脚本，自动完成图片的上传替换以及自动发布功能。当然，博客搭建完了。更重要的是不断的更新自己的知识，不断的发布博客。即不能为了发博客而写博客，也不能因为忙而不写博客。</p></div><div class="note green icon-padding flat"><p>参考文档：</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://butterfly.js.org/posts/dc584b87</p><p>https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note blue icon-padding flat&quot;&gt;
&lt;p&gt;为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;为什么选择个人博客？我搭建个人博客的原因是由于个人博客</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/11/21/hello-world/"/>
    <id>http://example.com/2022/11/21/hello-world/</id>
    <published>2022-11-21T09:22:02.494Z</published>
    <updated>2022-11-21T09:22:02.491Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
