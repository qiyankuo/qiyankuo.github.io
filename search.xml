<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基础</title>
      <link href="/2022/11/25/Linux-basic/"/>
      <url>/2022/11/25/Linux-basic/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文主要讲解Linux操作系统的基本命令，也可以作为一个Linux基础命令的速查手册</p></div><h2 id="Linux的基本原则"><a href="#Linux的基本原则" class="headerlink" title="Linux的基本原则"></a>Linux的基本原则</h2><ul><li>一些皆文件</li><li>配置文件保存为纯文本格式</li><li>由目的单一的小程序组成，组合小程序完成复杂任务</li><li>尽量避免捕获用户接口（尽量减少与用户交互，比如如果命令运行成功则不会显示任何信息，没有消息是最好的消息）</li></ul><h2 id="Linux交互"><a href="#Linux交互" class="headerlink" title="Linux交互"></a>Linux交互</h2><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><p>Shell是用户和操作系统进行交互的软件。在Linux中它分为如下类型：  </p><blockquote><ul><li>GUI（图形界面交互）  <ul><li>Gnode  </li><li>KDE  </li><li>XFace</li></ul></li><li>CLI（命令行交互）  <ul><li>sh</li><li>bash</li><li>csh</li><li>zsh</li><li>ksh</li><li>tcsh</li></ul></li></ul></blockquote><p> 使用bash登陆Linux后会显示命令提示符（prompt）：</p><pre><code>[root@localhost ~]#    </code></pre><p>其中root是用户名，localhost是主机名，~代表家目录（&#x2F;代表根目录），#代表管理员（$代表普通用户）  </p><blockquote><p>虚拟终端(terminal)：Ctrl+Alt+F1-F6。Linux中有六个虚拟终端，每个虚拟终端都是一个Shell程序。一个用户可以在多个虚拟终端中同时登陆互不影响。CentOS 7之前可以使用init 3命令将图形shell转换为命令行Shell，使用init 5则相反。CentOS 7之后使用systemctl isolate multi-user.target或者systemctl isolate graphical.target切换</p></blockquote><h3 id="bash特性"><a href="#bash特性" class="headerlink" title="bash特性"></a>bash特性</h3><p>1、命令历史、命令补全 </p><pre><code>  history：查看命令历史 -c：清空命令历史 -d OFFSET [n]: 删除指定位置的命令 -w：保存命令历史至历史文件中  HISTSIZE环境变量: 命令历史缓冲区大小 ~/.bash_history：命令历史文件路径 命令历史的使用技巧：  !n      ：执行命令历史中的第n条命令； !-n     :执行命令历史中的倒数第n条命令；  !!      : 执行上一条命令； !string ：执行命令历史中最近一个以指定字符串开头的命令 !$      :引用前一个命令的最后一个参数;  Esc, .  :引用前一个命令的最后一个参数，先按Esc，再按.； Alt+. :引用前一个命令的最后一个参数，只在linux终端中可以； 命令、路径补全： 命令补全：搜索PATH环境变量所指定的每个路径下以我们给出的字符串开头的可执行文件，如果多于一个，两次tab，可以给出列表；否则将直接补全； 路径补全：搜索我们给出的起始路径下的每个文件名，并试图补全；</code></pre><p>2、管道、重定向<br>3、命令别名  </p><pre><code>alias CMDALIAS=&#39;COMMAND [options] [arguments]&#39; 定义别名在shell中定义的别名仅在当前shell生命周期中有效；别名的有效范围仅为当前shell进程；ualias CMDALIAS 解除别名\CMD ： 执行原命令</code></pre><p>4、命令行编辑  </p><pre><code>光标跳转：  Ctrl+a：跳到命令行首Ctrl+e：跳到命令行尾Ctrl+u: 删除光标至命令行首的内容Ctrl+k: 删除光标至命令行尾的内容Ctrl+l: 清屏</code></pre><p>5、命令行展开  </p><pre><code>命令替换: $(COMMAND), 反引号：`COMMAND`把命令中某个子命令替换为其执行结果的过程,如：：file-2013-02-28-14-53-31.txtbash支持的引号：``: 命令替换&quot;&quot;: 弱引用，可以实现变量替换&#39;&#39;: 强引用，不完成变量替换命令行展开：&#123;a,d&#125;_&#123;b,c&#125;mkdir -pv /mnt/test/&#123;x/m,y&#125;cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>6、文件名通配  </p><pre><code> globbing *: 任意长度的任意字符 ?：任意单个字符 []：匹配指定范围内的任意单个字符     [abc], [a-m], [a-z], [A-Z], [0-9], [a-zA-Z], [0-9a-zA-Z]     [:space:]：空白字符     [:punct:]：标点符号     [:lower:]：小写字母     [:upper:]: 大写字母     [:alpha:]: 大小写字母     [:digit:]: 数字     [:alnum:]: 数字和大小写字母  # man 7 glob  [^]: 匹配指定范围之外的任意单个字符  [[:alpha:]]*[[:space:]]*[^[:alpha:]]  注：文件通配符并不能匹配所有情况，比如：显示所有以数字结尾且文件名中不包含空白的文件；ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>7、变量<br>8、编程  </p><blockquote><p>注：&#x2F;etc&#x2F;shells：指定了当前系统可用的安全shell  </p></blockquote><div class="note green icon-padding flat"><p>练习：</p><p>1、创建a123, cd6, c78m, c1 my, m.z, k 67, 8yu, 789等文件；注意，以上文件是以逗号隔开的，其它符号都是文件名的组成部分；  </p><p>2、显示所有以a或m开头的文件；  </p><pre><code>ls [am]*  </code></pre><p>3、显示所有文件名中包含了数字的文件； </p> <pre><code>ls *[0-9]*   ls *[[:digit:]]*  </code></pre><p>4、显示所有以数字结尾且文件名中不包含空白的文件； </p> <pre><code>ls *[^[:space:]]*[0-9]   ?????????  </code></pre><p>5、显示文件名中包含了非字母或数字的特殊符号的文件； </p> <pre><code>ls *[^[:alnum:]]*</code></pre></div><h3 id="登陆式shell和非登陆式shell"><a href="#登陆式shell和非登陆式shell" class="headerlink" title="登陆式shell和非登陆式shell"></a>登陆式shell和非登陆式shell</h3><p>站在用户登录的角度来说，SHELL的类型：</p><ul><li><p>登录式shell:</p><ul><li>正常通过某终端登录</li><li>su - USERNAME </li><li>su -l USERNAME</li></ul></li><li><p>非登录式shell:</p><ul><li>su USERNAME</li><li>图形终端下打开命令窗口</li><li>自动执行的shell脚本</li></ul></li></ul><p>bash的配置文件：</p><ul><li><p>全局配置</p><pre><code>  /etc/profile    /etc/profile.d/*.sh    /etc/bashrc </code></pre></li><li><p>个人配置</p><pre><code>  ~/.bash_profile   ~/.bashrc</code></pre></li></ul><p>profile类的文件：  </p><ul><li>设定环境变量</li><li>运行命令或脚本</li></ul><p>bashrc类的文件：  </p><ul><li>设定本地变量</li><li>定义命令别名</li></ul><p>登录式shell如何读取配置文件？  </p><pre><code>/etc/profile --&gt; /etc/profile.d/*.sh --&gt; ~/.bash_profile --&gt; ~/.bashrc --&gt; /etc/bashrc</code></pre><p>非登录式shell如何配置文件?</p><pre><code>~/.bashrc --&gt; /etc/basrc --&gt; /etc/profile.d/*.sh</code></pre><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><p>Linux的一级目录如下：  </p><ul><li>&#x2F;boot: 系统启动相关的文件，如内核、initrd，以及grub(bootloader)  </li><li>&#x2F;dev: 设备文件  </li><li>设备文件：  <ul><li>块设备：随机访问，数据块  </li><li>字符设备：线性访问，按字符为单位  </li><li>设备号：主设备号（major）和次设备号（minor）</li></ul></li><li>&#x2F;etc：配置文件  </li><li>&#x2F;home：用户的家目录，每一个用户的家目录通常默认为&#x2F;home&#x2F;USERNAME  </li><li>&#x2F;root：管理员的家目录；  </li><li>&#x2F;lib：库文件  <ul><li>静态库,  .a   </li><li>动态库， .dll, .so (shared object)</li></ul></li><li>&#x2F;lib&#x2F;modules：内核模块文件  </li><li>&#x2F;media：挂载点目录，移动设备  </li><li>&#x2F;mnt：挂载点目录，额外的临时文件系统  </li><li>&#x2F;opt：可选目录，第三方程序的安装目录  </li><li>&#x2F;proc：伪文件系统，内核映射文件  </li><li>&#x2F;sys：伪文件系统，跟硬件设备相关的属性映射文件  </li><li>&#x2F;tmp：临时文件, &#x2F;var&#x2F;tmp  </li><li>&#x2F;var：可变化的文件  </li><li>&#x2F;bin: 可执行文件, 用户命令  </li><li>&#x2F;sbin：管理命令</li></ul><p>&#x2F;usr：shared, read-only  </p><ul><li>&#x2F;usr&#x2F;bin  </li><li>&#x2F;usr&#x2F;sbin  </li><li>&#x2F;usr&#x2F;lib</li></ul><p>&#x2F;usr&#x2F;local：  </p><ul><li>&#x2F;usr&#x2F;local&#x2F;bin  </li><li>&#x2F;usr&#x2F;local&#x2F;sbin  </li><li>&#x2F;usr&#x2F;local&#x2F;lib</li></ul><p>Linux中文件命名规则：  </p><ol><li>长度不能超过255个字符；  </li><li>不能使用&#x2F;当文件名  </li><li>严格区分大小写</li></ol><h2 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h2><h3 id="命令基础"><a href="#命令基础" class="headerlink" title="命令基础"></a>命令基础</h3><p>1、命令格式：</p><blockquote><p>命令 选项 参数</p><p>选项  </p><ul><li>短选项：- (多个选项可以组合 -a -b &#x3D; -ab)</li><li>长选项：- -</li></ul><p>参数：命令的作用对象</p></blockquote><p>2、命令类型：  </p><ul><li>内置命令(shell内置)，内部，内建  </li><li>外部命令：在文件系统的某个路径下有一个与命令名称相应的可执行文件</li></ul><p>3、type: 显示指令属于哪种类型</p><pre><code>[root@localhost ~]# type lsls is aliased to `ls --color=auto&#39; (命令别名)[root@localhost ~]# type cdcd is a shell builtin  （内部命令）[root@localhost ~]# type vivi is /usr/bin/vi （外部命令，对应文件）</code></pre><p>4、环境变量：命名的内存空间  </p><pre><code>变量赋值:NAME=Jerry  PATH: 使用冒号分隔的路径，命令的默认搜索路径  </code></pre><h3 id="查看命令帮助"><a href="#查看命令帮助" class="headerlink" title="查看命令帮助"></a>查看命令帮助</h3><blockquote><p>获得命令的使用帮助：<br>内部命令：help COMMAND<br>外部命令：COMMAND –help<br>在线手册：info COMMAND  (不常用)<br>文    档：&#x2F;usr&#x2F;share&#x2F;doc<br>命令手册：man COMMAND  </p><p>注：帮助中符号的意思<br>&lt;&gt;：必选     [] ：可选    … : 可以出现多次     | ：多选一    {} ：分组  </p></blockquote><p>man [指定章节数字] COMMAND  </p><pre><code>[root@localhost ~]# man DATEDATE(1)（1代表章节）                                                            User Commands                                                                   DATE(1)NAME（命令名称及功能简要说明）       date - print or set the system date and timeSYNOPSIS（用法说明，包括可用的选项）       date [OPTION]... [+FORMAT]       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]DESCRIPTION（命令功能的详尽说明，可能包括每一个选项的意义）     OPTIONS：说明每一个选项的意义         Display the current time in the given FORMAT, or set the system date.       Mandatory arguments to long options are mandatory for short options too.       -d, --date=STRING              display time described by STRING, not &#39;now&#39;FILES：此命令相关的配置文件        ......BUGS：       ......EXAMPLES：使用示例        ......SEE ALSO：另外参照      ...... 注：man文档查看方法    翻屏：        向后翻一屏：SPACE        向前翻一屏：b        向后翻一行：ENTER        向前翻一行：k    查找：        /KEYWORD: 向后            n: 下一个            N：前一个             ?KEYWORD：向前        n: 下一个        N：前一个         q: 退出</code></pre><p>man帮助中分章节，每个章节中存放不同类型的命令。比如1和5章节中都包含passwd。man命令如果不指定章节数，则默认显示最小章节的命令。查看5章节的passwd帮助使用man 5 passwd：  </p><ul><li>1：用户命令(&#x2F;bin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;local&#x2F;bin)  </li><li>2：系统调用  </li><li>3：库用户  </li><li>4：特殊文件(设备文件)  </li><li>5：文件格式(配置文件的语法)  </li><li>6：游戏  </li><li>7：杂项(Miscellaneous)  </li><li>8: 管理命令(&#x2F;sbin, &#x2F;usr&#x2F;sbin, &#x2F;usr&#x2F;local&#x2F;sbin)</li></ul><p>whatis COMMAND：查看命令属于那些章节  </p><pre><code>[root@localhost ~]# whatis date  date (1)             - print or set the system date and time  date (1p)            - write the date and time</code></pre><div class="note blue icon-padding flat"><p>练习：</p>  <p>1. 使用date单独获取系统当前的年份、月份、日、小时、分钟、秒  </p>  <p>2. echo和printf是内部命令还是外部命令？  </p>  <p>3. echo和printf作用？  </p>  <p>4. echo和printf如何显示“The year is 2013. Today is 26.”为两行？  </p>  <p>5. file命令及其用法？</p>  </div><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p>Linux时间有两种。一种是硬件时钟，另一种是系统时钟。</p><blockquote><ul><li>硬件时钟：CPU内置振荡器确定时间，同时CPU内置纽扣电源为振荡器提供电量。</li><li>系统时钟：Linux系统启动后，读取硬件时间并以软件方式模拟一个振荡器。date查看的便是系统时钟。</li></ul></blockquote><p>date：时间管理  </p><blockquote><p>-d 后跟字符串，显示字符串指定的时间 </p></blockquote><pre><code>[root@localhost ~]# date -d &quot;2 days ago&quot;  Fri Nov 19 02:05:54 EST 2021  [root@localhost ~]# date -d &quot;2021/11/21&quot;  Sun Nov 21 00:00:00 EST 2021    \\\\ 指定时间输出格式：  [root@localhost ~]# date -d &quot;10 days ago&quot; +&quot;The day is %Y-%m-%d %H:%M:%S%nThe day is %A&quot;  The day is 2021-11-11 02:27:09  The day is Thursday  \\\\ 修改时间  [root@localhost ~]# date -s &quot;2019-01-01 08:08:08&quot;Tue Jan  1 08:08:08 EST 2019</code></pre><p>clock、hwclock：硬件时钟</p><pre><code>-s 将系统时间更新为硬件时钟-w 将硬件时钟更新为系统时间</code></pre><p>cal：查看日历</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>ls（list）：列出指定路径下的文件  </p><pre><code> -l：长格式      文件类型：          -：普通文件 (f)          d: 目录文件          b: 块设备文件 (block)          c: 字符设备文件 (character)          l: 符号链接文件(symbolic link file)          p: 命令管道文件(pipe)          s: 套接字文件(socket)      文件权限：9位，每3位一组，每一组：rwx(读，写，执行), r--      文件硬链接的次数      文件的属主(owner)      文件的属组(group)      文件大小(size)，单位是字节      时间戳(timestamp)：最近一次被修改的时间          访问:access，文件最近访问时间          修改:modify，文件内容发生了改变          改变:change，metadata，元数据（如文件名、文件权限等属性改变）  -h：做单位转换，提高信息可读性  -a: 显示以.开头的隐藏文件      . 表示当前目录      .. 表示父目录  -A  显示以.开头的隐藏文件（除.和..目录）  -d: 显示目录自身属性，而不是目录下的内容。只显示当前文件或目录的属性  -i: index node, inode  -r: 逆序显示  -R: 递归(recursive)显示  </code></pre><p>pwd（Printing Working directory）：输出当前工作路径  </p><p>cd: change directory  </p><pre><code>cd ~: 进入指定用户的家目录  cd -:在当前目录和前一次所在的目录之间来回切换  </code></pre><p>mkdir：创建空目录  </p><pre><code>-p: 目录已存在不报错，父路径不存在自动创建  -v: verbose 打印出创建的每个目录mkdir -pv /mnt/test2/&#123;a,d&#125;_&#123;b,c&#125;：命令行展开，创建a_b, a_c, d_b, d_c目录</code></pre><p>tree：查看目录树</p><p>rmdir (remove directory)：删除空目录  </p><pre><code>-p: 如果父目录为空也会自动删除</code></pre><p>du ： 用于显示目录或文件的大小  </p><pre><code>-s 仅显示总计  -h 做单位换算，提高信息可读性</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>touch  修改文件的访问时间或修改时间为当前时间</p><pre><code> -a  仅仅改变访问时间   -m  仅仅改变修改时间   -t  指定[[CC]YY]MMDDhhmm[.ss]，代替当前时间   -c  不创建任何文件  </code></pre><blockquote><p>注：修改访问或修改任何一个时间都会自动修改改变时间为当前时间</p></blockquote><p>stat  展示文件或文件系统属性</p><pre><code>[root@localhost Music]# stat 11.txt   File: &#39;11.txt&#39;  Size: 14              Blocks: 8          IO Block: 4096   regular fileDevice: fd00h/64768d    Inode: 3169019     Links: 1Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)Context: unconfined_u:object_r:admin_home_t:s0Access: 2019-01-01 01:01:00.000000000 -0500Modify: 2019-01-01 01:01:00.000000000 -0500Change: 2021-11-21 06:07:26.151522828 -0500 Birth: - </code></pre><p>nano：文本编辑器，不常用。</p><p>rm  删除文件或目录  </p><pre><code>-i 每一次删除之前都提示    -f 忽略不存在的文件，强制删除不提示  -r 递归删除</code></pre><p>cp SRC DEST 复制文件  </p><pre><code>-r：递归拷贝目录下内容  -d：复制时保留链接，如果是链接文件复制后依然是链接文件。  -i：存在目标文件则提示是否覆盖  -f：覆盖已经存在的目标文件而不给出提示。-p（小写）：保留这个文件原来的权限、属主、属组、时间戳。注：目前我用普通用户复制属主和属组还是变化。-P（大写）：如果是链接复制为链接-a：归档复制，常用于备份，相当于-dR --preserve=all多个文件到一个目录cp /etc/&#123;passwd,inittab,rc.d/rc.sysinit&#125; /tmp/</code></pre><p>mv SRC DEST  移动文件<br>mv -t DEST SRC  -t 是将源和目标位置反向</p><p>install  复制文件并可以设置属性  </p><pre><code> install -d DIRECOTRY ... ：创建目录     install -m ：可以指定权限   install SRC DEST 复制文件，复制之后会有执行权限   install -t DIRECTORY SRC...  </code></pre><h3 id="查看文本"><a href="#查看文本" class="headerlink" title="查看文本"></a>查看文本</h3><p>cat：连接文件并显示  </p><pre><code>-n 显示行号   -E 显示每一行的结束符$ [root@localhost Music]# cat file1 file2  this file is one.  this file is two.   [root@localhost Music]# cat -n file1 file2       1  this file is one.       2  this file is two.  [root@localhost Music]# cat -E file1 file2  this file is one.$  this file is two.$  [root@localhost Music]# cat -nE file1 file2       1  this file is one.$       2  this file is two.$</code></pre><p>tac: 将文件内容倒着显示</p><pre><code>[root@localhost Music]# tac file1this file is one, the line is 6.this file is one, the line is 5.this file is one, the line is 4.this file is one, the line is 3.this file is one, the line is 2.this file is one, the line is 1.</code></pre><p>more：以一页一页的方式查看文本，到文件末尾会自动退出。详细使用见man命令</p><p>less：less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。到文件末尾不会自动退出。</p><p>head:查看前n行   </p><pre><code>-n: 指定行数，默认为10  </code></pre><p>tail:查看后n行  </p><pre><code>-n: 指定行数，默认为10  -f: 会把文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>file： 辨识文件类型  </p><p>测试文件内容：</p><pre><code>Tom:25:male:2013/05/06  Jack:24:famale:2013/05/06Json:23:male:2013/05/06Mark:26:famale:2013/05/06</code></pre><p>cut:  分割文件中的每一行，并只显示选择字段</p><pre><code>-d: 指定字段分隔符，默认是空格-f: 指定要显示的字段    -f 1,3    -f 1-3[root@localhost Music]# cut -d : -f 1,3 file3Tom:maleJack:famaleJson:maleMark:famale</code></pre><p>sort：文本排序</p><pre><code>-n：数值排序-r: 降序-t: 字段分隔符-k: 以哪个字段为关键字进行排序-u: 排序后相同的行只显示一次-f: 排序时忽略字符大小写[root@localhost Music]# sort -n -t : -k 2 file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06WangWu:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06ZhaoLiu:26:male:2013/05/06LiSi:111:male:2013/05/06[root@localhost Music]# sort -n -t : -k 2 -u file3ZhangSan:6:famale:2013/05/06Json:23:male:2013/05/06Jack:24:famale:2013/05/06Tom:25:male:2013/05/06Mark:26:famale:2013/05/06LiSi:111:male:2013/05/06</code></pre><p>uniq:去重，去重时两行相邻并且内容一致才会认定是重复</p><pre><code>-c: 显示文件中行重复的次数-d: 只显示重复的行</code></pre><p>wc (word count)：文本统计，打印文件的行数、单词数、字节数</p><pre><code> -l：打印行数 -w：打印单词数 -c：打印字节数 -L：打印最长行的长度</code></pre><p>tr —— 转换或删除字符  </p><pre><code>tr [OPTION]... SET1 [SET2]      -d: 删除出现在字符集中的所有字符tr ab AB ：将文档中的a全部转换为A，将b全部转换为B，并不是ab转AB</code></pre><h3 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h3><p>locate: 非实时，模糊匹配，查找是根据全系统文件数据库进行的，速度快；<br>updatedb: 手动生成文件数据库（比较慢）</p><p>find：实时、精确、支持众多查找标准、遍历指定目录中的所有文件完成查找，速度慢；</p><pre><code>find 查找路径 匹配标准 查找到以后的处理运作查找路径：默认为当前目录匹配标准：默认为指定路径下的所有文件处理运作：默认为显示匹配标准：-name &#39;FILENAME&#39;：对文件名作精确匹配    文件名通配：        *：任意长度的任意字符        ?:任意单个字符        []:匹配指定范围内的任意单个字符-iname &#39;FILENAME&#39;: 文件名匹配时不区分大小写-regex PATTERN：基于正则表达式进行文件名匹配-user USERNAME: 根据属主查找-group GROUPNAME: 根据属组查找-uid UID: 根据UID查找-gid GID: 根据GID查找-nouser：查找没有属主的文件(删除用户之后，文件的属主则会变为用户对应的uid)-nogroup: 查找没有属组的文件(删除组之后，文件的属组则会变为用户对应的gid)-type     f: 普通文件    d：目录文件    c：字符设备文件    b：块设备文件    l：符号链接文件    p：命名管道文件    s：套接字文件-size [+|-] 大小 +大于 -小于    #k    #M    #G -mtime：在过去n天修改过的文件（单位：天）-ctime：在过去n天改变过的文件-atime：在过去n天访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-mmin：在过去n分钟修改过的文件（单位：分钟）-cmin：在过去n分钟改变过的文件-amin：在过去n分钟访问多的文件    [+|-]# +代表某个时间之前，－代表最近多长时间-maxdepth:递归层数-perm MODE：精确匹配    /MODE: 任意一位匹配即满足条件    -MODE: 文件权限能完全包含此MODE时才符合条件        -644    644: rw-r--r--    755: rwxr-xr-x    750: rwxr-x---    find ./ -perl -001 组合条件：以上条件之间的逻辑，    -a：与    -o：或    -not： 非     \( \)：括号要转义运作：    -print: 显示    -ls：类似ls -l的形式显示每一个文件的详细    -ok COMMAND &#123;&#125; \; 每一次操作都需要用户确认，命令中需要文件名的地方用&#123;&#125;代替    -exec COMMAND &#123;&#125; \;每一次操作都不需要用户确认，命令中需要文件名的地方用&#123;&#125;代替</code></pre><div class="note green icon-padding flat"><p>练习：  </p><p>1)在/mnt下创建boot和sysroot； </p> <p>2)在/mnt/boot下创建grub；  </p><p>3)在/mnt/sysroot下创建proc, sys, bin, sbin, lib, usr, var, etc, dev, home, root, tmp  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a)在/mnt/sysroot/usr下创建bin, sbin, lib  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b)在/mnt/sysroot/lib下创建modules  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)在/mnt/sysroot/var下创建run, log, lock  </p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d)在/mnt/sysroot/etc下创建init.d  </p><p>4)创建目录/backup；  </p><p>5)复制目录/etc至/backup目录中，并重命名为“etc-当前日期”，如etc-2013-02-26；要求保留文件原来的属性，保持链接文件；   </p><p>6）复制文件/etc/inittab为/tmp/inittab.new，并删除inittab.new文件的后两行； </p> <pre><code>  # cp /etc/inittab  /tmp/inittab.new    # nano /tmp/inittab.new</code></pre><p>7）描述GPL, BSD, Apache三个开源协定的大体联系及区别。</p><p>8）如何获取Linux当前最新的内核版本号？  </p>      <pre><code>  www.kernel.org</code></pre><p>9）列出你所了解的Linux发行版，并说明其跟Linux内核的关系。</p>  <pre><code>Linux, GNU: GNU/Linux, 源代码发行版：Fedora, RedHat(CentOS), SUSE, Debian(Ubuntu, Mint), Gentoo, LFS(Linux From Scratch)</code></pre><p>10）、查找/var目录下属主为root并且属组为mail的所有文件；</p><pre><code>find /var -user root -group mail</code></pre><p>11）、查找/usr目录下不属于root,bin或student的文件；</p><pre><code>find /usr -not -user root -a -not -user bin -a -not -user studentfind /usr -not \( -user root -o -user bin -o -user student \)</code></pre><p>12）、查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件；</p><pre><code>find /etc -mtime -7 -not \ ( -user root -o -user student \)find /etc -mtime -7 -not -user root -a -not -user student</code></pre><p>13）、查找当前系统上没有属主或属组且最近1天内曾被访问过的文件，并将其属主属组均修改为root；</p>    <pre><code>find / \( -nouser -o -nogroup \) -a -atime -1 -exec chown root:root &#123;&#125; \; </code></pre><p>14）、查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中；</p>    <pre><code>find /etc -size +1M &gt;&gt; /tmp/etc.largefiles</code></pre><p>15）、查找/etc目录下所有用户都没有写权限的文件，显示出其详细信息；</p><pre><code>find /etc -not -perm /222 -ls</code></pre></div><h3 id="用户、权限和组基础"><a href="#用户、权限和组基础" class="headerlink" title="用户、权限和组基础"></a>用户、权限和组基础</h3><p>Linux的用户管理使用如下机制：  </p><blockquote><p>认证机制：Authentication（使用用户名密码）<br>授权：Authorization（使用权限管理）<br>审计：Audition (日志)</p></blockquote><p>权限：  r, w, x</p><ul><li><p>文件：  </p><ul><li>r：可读，可以使用类似cat等命令查看文件内容；  </li><li>w：可写，可以编辑或删除此文件；  </li><li>x: 可执行，exacutable，可以命令提示符下当作命令提交给内核运行；</li></ul></li><li><p>目录：  </p><ul><li>r: 可以对此目录执行ls以列出内部的所有文件；  </li><li>w: 可以在此目录创建文件；  </li><li>x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；</li></ul></li></ul><p>权限和数字对应关系：</p><pre><code> 0 000 ---: 无权限 1 001 --x: 执行 2 010 -w-: 写 3 011 -wx: 写和执行 4 100 r--: 只读 5 101 r-x: 读和执行 6 110 rw-: 读写 7 111 rwx: 读写执行 755：rwxr-xr-x 640：rw-r-----  660: rw-rw---- 775: rwxrwxr-x</code></pre><p>用户：UID, &#x2F;etc&#x2F;passwd  </p><pre><code>account: 登录名password: 密码UID：GID：基本组IDcomment: 注释HOME DIR：家目录SHELL：用户的默认shell</code></pre><p>组：GID, &#x2F;etc&#x2F;group  </p><pre><code>组名：  密码：  GID:  以此组为其附加组的用户列表：</code></pre><p>影子口令：  </p><ul><li><p>用户：&#x2F;etc&#x2F;shadow</p><pre><code>  account: 登录名    encrypted password: 加密的密码    date of last password change：最近一次修改密码的时间  minimum password age：最短使用期限  maximum password age：最长使用期限  password warning period：警告时间  password inactivity period：非活动时间  account expiration date：账号过期时间</code></pre></li><li><p>组：&#x2F;etc&#x2F;gshadow</p></li></ul><p>影子文件中存储的密码都会进行相应的单向加密，加密算法分类如下：  </p><ul><li>对称加密：加密和解密使用同一个密码  </li><li>公钥加密：每个密码都成对儿出现，一个为私钥(secret key)，一个为公钥(public key)  </li><li>单向加密，散列加密：提取数据特征码，常用于数据完整性校验  <ul><li>1、雪崩效应  </li><li>2、定长输出  </li><li>MD5：Message Digest, 128位定长输出  </li><li>SHA1：Secure Hash Algorithm, 160位定长输出</li></ul></li></ul><p>用户类别：</p><ul><li>管理员：0  </li><li>普通用户： 1-65535  </li><li>系统用户：1-499  </li><li>一般用户：500-60000</li></ul><p>用户组类别：</p><ul><li>私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组  </li><li>基本组：创建用户时，指定的用户的默认组  </li><li>附加组，额外组：默认组以外的其它组</li></ul><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>useradd  [options]  USERNAME 添加用户  </p><pre><code> -u UID（用户ID） -g GID（基本组ID\基本组名，组必须存在） -G GID,...  （附加组） -c &quot;COMMENT&quot; （注释） -d /path/to/directory （家目录） -s SHELL （指定SHELL） -m -k （创建家目录。-k将/etc/skel下内容复制到家目录中） -M （不创建家目录） -r: 添加系统用户</code></pre><p>&#x2F;etc&#x2F;login.defs</p><blockquote><p>用于在Linux创建用户时，对用户的一些基本属性做默认设置。该配置对root用户无效。并且，当此文件中的配置与 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 文件中的用户信息有冲突时，系统会以&#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 为准。  </p></blockquote><p>userdel [option] USERNAME 删除用户  </p><pre><code> -r: 同时删除用户的家目录</code></pre><p>id：查看用户的帐号属性信息  </p><pre><code> -u: 显示用户ID -g: 显示基本组ID -G: 显示附加组ID -n: 每个选项不显示ID，显示名称[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><p>finger USERNAME：查看用户账号信息</p><p>usermod ： 修改用户帐号属性</p><pre><code>   -u UID 修改用户ID-g GID 修改基本组-a -G GID：不使用-a选项，会覆盖此前的附加组；-c：修改用户账户备注文字-d -m：修改用户的家目录，-m选项是将原来家目录中的内容复制新的家目录-s：修改用户shell-l：修改用户帐号名称-L：锁定帐号-U：解锁帐号usermod -a -G GROUPNAME，... USERNAME</code></pre><p>chage ： 修改用户密码信息</p><pre><code>-d: 最近一次的修改时间-E: 过期时间-I：非活动时间-m: 最短使用期限-M: 最长使用期限-W: 警告时间</code></pre><p>chsh: 修改用户的默认shell</p><p>chfn：修改注释信息</p><h3 id="密码管理"><a href="#密码管理" class="headerlink" title="密码管理"></a>密码管理</h3><p>passwd [USERNAME]</p><pre><code> --stdin ： 从标准输入中读入，主要用于管道传入 -l：锁定帐号  -u：解锁帐号   -d: 删除用户密码</code></pre><p>pwck：检查用户帐号完整性</p><pre><code>[root@localhost ~]# pwckuser &#39;ftp&#39;: directory &#39;/var/ftp&#39; does not existuser &#39;saslauth&#39;: directory &#39;/run/saslauthd&#39; does not existuser &#39;gluster&#39;: directory &#39;/run/gluster&#39; does not existuser &#39;pulse&#39;: directory &#39;/var/run/pulse&#39; does not existuser &#39;gnome-initial-setup&#39;: directory &#39;/run/gnome-initial-setup/&#39; does not existpwck: no changes</code></pre><h3 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h3><p>groupadd 添加组</p><pre><code> -g GID 指定组ID -r：添加为系统组</code></pre><p>groupmod 修改组</p><pre><code> -g GID 修改组ID -n GRPNAME 更改组名称</code></pre><p>groupdel 删除组  </p><p>gpasswd：为组设定密码  </p><pre><code>gpasswd -d A GROUP ：将用户A从GROUP组移除  </code></pre><p>newgrp GRPNAME &lt;–&gt; exit：为用户指定临时基本组，需要指定组密码，用exit退出。</p><pre><code>[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ newgrp hadoop Password: [demo@localhost ~]$ iduid=1000(demo) gid=1001(hadoop) groups=1001(hadoop),1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023[demo@localhost ~]$ exitexit[demo@localhost ~]$ iduid=1000(demo) gid=1000(demo) groups=1000(demo) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、创建一个用户mandriva，其ID号为2002，基本组为distro（组ID为3003），附加组为linux； </p>  <pre><code># groupadd -g 3003 distro# groupadd linux# useradd -u 2002 -g distro -G linux mandriva</code></pre><p>2、创建一个用户fedora，其全名为Fedora Community，默认shell为tcsh；</p>   <pre><code># useradd -c &quot;Fedora Community&quot; -s /bin/tcsh fedora</code></pre><p>3、修改mandriva的ID号为4004，基本组为linux，附加组为distro和fedora；</p> <pre><code># usermod -u 4004 -g linux -G distro,fedora mandriva</code></pre><p>4、给fedora加密码，并设定其密码最短使用期限为2天，最长为50天；</p> <pre><code># passwd -n 2 -x 50 fedora</code></pre><p>5、将mandriva的默认shell改为/bin/bash; </p> <pre><code>usermod -s /bin/bash mandirva</code></pre><p>6、添加系统用户hbase，且不允许其登录系统；</p> <pre><code># useradd -r -s /sbin/nologin hbase</code></pre></div><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>chown USERNAME file,…  改变文件属主(只有管理员可以使用此命令)  </p><pre><code> -R: 修改目录及其内部文件的属主 --reference=/path/to/somefile file,...：将文件的属主和属组和参照文件保持一致  chown    :GRPNAME file,...      ：改变文件属组信息 chown    .GRPNAME file,...      ：改变文件属组信息 chown USERNAME:GRPNAME file,... ：改变文件属主、属组信息 chown USERNAME.GRPNAME file,... ：改变文件属主、属组信息</code></pre><p>chgrp GRPNAME file,… 改变文件属组(只有管理员可以使用此命令)  </p><pre><code>-R: 修改目录及其内部文件的属组--reference=/path/to/somefile file,...：将文件的属组和参照文件保持一致  </code></pre><p>chmod MODE file,… 修改文件的权限</p><pre><code>-R: 修改目录及其内部文件的权限--reference=/path/to/somefile file,... ：将文件的权限和参照文件保持一致 修改文件权限：chmod  MODE file,...chomd  755 /home/demo/11.txt修改某类用户用户权限：u（属主）,g（属组）,o（其他）,a（所有）chmod 用户类别=MODE file,...chomd  u=rw /home/demo/11.txt修改某类用户的某位或某些位权限：u,g,o,achmod 用户类别+|-MODE file,...chmod u+w /home/demo/11.txtchmod ug+w /home/demo/11.txtchmod u+w,g+r /home/demo/11.txt</code></pre><div class="note green icon-padding flat"><p>练习：</p>  <p>1、新建一个没有家目录的用户openstack；  </p>  <pre><code># useradd -M openstack  </code></pre><p>2、复制/etc/skel为/home/openstack；  </p>  <pre><code># cp -r /etc/skel /home/openstack  </code></pre><p>3、改变/home/openstack及其内部文件的属主属组均为openstack； </p>   <pre><code># chown -R openstack:openstack /home/openstack  </code></pre><p>4、/home/openstack及其内部的文件，属组和其它用户没有任何访问权限  </p>  <pre><code># chmod -R go= /home/openstack  （不修改属主的权限） </code></pre><p>5、不用命令如何添加一个用户  </p>  <pre><code>在/etc/passwd、/etc/shadow、/etc/group中分别添加一条记录使用openssl passwd -1 -salt xxxxxxxx（八位随机数） password 获取加密密码使用如上步骤</code></pre></div><h3 id="umask-遮掩码"><a href="#umask-遮掩码" class="headerlink" title="umask(遮掩码)"></a>umask(遮掩码)</h3><p>每个用户都会有一个遮掩码，遮掩码的作用是设置用户创建文件或目录的权限。Linux文件默认不具有执行权限。</p><pre><code>文件权限：666-umask （文件不具有执行权限） 目录权限：777-umask建议用权限位相减</code></pre><p>umask: 023</p><pre><code>文件：666-023=643 X （文件默认不能具有执行权限，如果算得的结果中有执行权限，则将其权限加1；故结果应为644）目录：777-023=754</code></pre><p>注：umask：027 创建的文件或目录其它用户无任何权限</p><h3 id="管道与重定向"><a href="#管道与重定向" class="headerlink" title="管道与重定向"></a>管道与重定向</h3><p>程序在运行过程中需要和I&#x2F;O设备打交道，而程序一般是不直接指定具体的输入和输出设备的。因此系统为我们提供了一些默认的输入和输出设置。</p><ul><li>默认输出设备：标准输出，STDOUT, 1（文件描述符），显示器</li><li>默认输入设备：标准输入, STDIN, 0（文件描述符） ，键盘  </li><li>标准错误输出：STDERR, 2（文件描述符）  ，显示器</li></ul><p>I&#x2F;O重定向就是修改程序的输入和输出的位置。</p><pre><code>&gt;:  标准输出覆盖输出&gt;&gt;：标准输出追加输出2&gt;: 重定向错误输出2&gt;&gt;:重定向错误输出追加方式&amp;&gt;: 重定向标准输出或错误输出至同一个文件&lt;：输入重定向&lt;&lt;：Here Document 此处生成文档    使用：&lt;&lt;EOF或者END         cat &lt;&lt; EOF         cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        [root@localhost ~]# cat        this is my first line.        this is my first line.        this is my secondary line.        this is my secondary line.        ^C        [root@localhost ~]# cat &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        this is my first line.        this is my secondary line.        [root@localhost ~]# cat &gt;&gt; /tmp/myfile.txt &lt;&lt; EOF        &gt; this is my first line.        &gt; this is my secondary line.        &gt; EOF        [root@localhost ~]# cat /tmp/myfile.txt         this is my first line.        this is my secondary line.</code></pre><p>tee：将标准输入写入标准输出和文件<br>        echo “hello world”|tee &#x2F;tmp&#x2F;hello.out</p><p>set可以对系统的某些功能性选项进行开启或关闭。 </p><pre><code>set -C: 禁止对已经存在文件使用覆盖重定向；  强制覆盖输出，则使用 &gt;|set +C: 关闭上述功能</code></pre><p>管道：一端流入，一端流出。即前一个命令的输出，作为后一个命令的输入。</p><pre><code>命令1 | 命令2 | 命令3 | ...echo “redhat” | passwd -stdin hive：使用命令行修改用户密码</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、统计/usr/bin/目录下的文件个数；</p><pre><code> # ls /usr/bin | wc -l</code></pre><p>2、取出当前系统上所有用户的shell，要求，每种shell只显示一次，并且按顺序进行显示；</p><pre><code> # cut -d: -f7 /etc/passwd | sort -u</code></pre><p>3、思考：如何显示/var/log目录下每个文件的内容类型？</p><pre><code> # file /var/log/* # file &#39;ls /var/log&#39;</code></pre><p>4、取出/etc/inittab文件的第6行；</p><pre><code> # head -6 /etc/inittab | tail -1</code></pre><p>5、取出/etc/passwd文件中倒数第9个用户的用户名和shell，显示到屏幕上并将其保存至/tmp/users文件中；</p><pre><code> # tail -9 /etc/passwd | head -1 | cut -d: -f1,7 | tee /tmp/users</code></pre><p>6、显示/etc目录下所有以pa开头的文件，并统计其个数；</p><pre><code># ls -d /etc/pa* | wc -l</code></pre><p>7、不使用文本编辑器，将alias cls=clear一行内容添加至当前用户的.bashrc文件中；</p><pre><code># echo &quot;alias cls=clear&quot; &gt;&gt; ~/.bashrc</code></pre></div><h2 id="文本匹配"><a href="#文本匹配" class="headerlink" title="文本匹配"></a>文本匹配</h2><h3 id="常规正则表达式"><a href="#常规正则表达式" class="headerlink" title="常规正则表达式"></a>常规正则表达式</h3><p>grep: 根据模式搜索文本，并将符合模式的文本行显示出来。</p><p>Pattern（模式）: 文本字符和正则表达式的元字符组合而成匹配条件</p><p>grep [options] PATTERN [FILE…]</p><pre><code>-i:忽略大小写--color : 匹配到的字符串亮色显示-v: 显示没有被模式匹配到的行-o：只显示被模式匹配到的字符串-E：使用扩展正则表达式-A：显示匹配字符串的前N行-B：显示匹配字符串的后N行-C：显示匹配字符串的前后N行</code></pre><p>Pattern（模式）元字符如下：</p><pre><code>字符匹配：：    .: 匹配任意单个字符    []: 匹配指定范围内的任意单个字符    [^]：匹配指定范围外的任意单个字符    字符集合：[:digit:], [:lower:], [:upper:], [:punct:], [:space:], [:alpha:], [:alnum:]匹配次数（贪婪模式）    *: 匹配其前面的字符任意次    \?: 匹配其前面的字符1次或0次    \&#123;m,n\&#125;:匹配其前面的字符至少m次，至多n次        a, b, ab, aab, acb, adb, amnb        a*b， a?b        a.*b            .*: 任意长度的任意字符        \&#123;1,\&#125;        \&#123;0,3\&#125;位置锚定：    ^: 锚定行首，此字符后面的任意内容必须出现在行首    $: 锚定行尾，此字符前面的任意内容必须出现在行尾    ^$: 空白行    \&lt;或\b: 锚定词首，其后面的任意字符必须作为单词首部出现    \&gt;或\b: 锚定词尾，其前面的任意字符必须作为单词的尾部出现分组：    \(\)    \(ab\)* 后向引用        \1: 引用第一个左括号以及与之对应的右括号所包括的所有内容如：demo    He love his lover.    She like her liker.    He like his lover.[root@localhost ~]# grep &quot;\(l..e\).*\1r\.&quot; demoHe love his lover.She like her liker.</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示/proc/meminfo文件中以不区分大小的s开头的行；</p><pre><code>grep -i &#39;^s&#39; /proc/meminfogrep &#39;^[sS]&#39; /proc/meminfo</code></pre><p>2、显示/etc/passwd中以nologin结尾的行;</p> <pre><code>grep &#39;nologin$&#39; /etc/passwd</code></pre><p>3、取出默认shell为/sbin/nologin的用户列表</p><pre><code>grep &quot;nologin$&#39; /etc/passwd | cut -d: -f1</code></pre><p>4、取出默认shell为bash，且其用户ID号最小的用户的用户名</p><pre><code>grep &#39;bash$&#39; /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1</code></pre><p>5、显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；</p>    <pre><code>grep &quot;^#[[:space:]]\&#123;1,\&#125;[^[:space:]]&quot; /etc/inittab</code></pre><p>6、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；</p>    grep ':[0-9]:' /etc/inittab<p>7、显示/boot/grub/grub.conf文件中以一个或多个空白字符开头的行；</p>    <pre><code>grep &#39;^[[:space:]]\&#123;1,\&#125;&#39; /boot/grub/grub.conf</code></pre><p>8、显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；</p><pre><code>grep &#39;^\([0-9]\).*\1$&#39; /etc/inittab</code></pre><p>9、找出某文件中的，1位数，或2位数；</p><pre><code>grep &#39;[0-9]\&#123;1,2\&#125;&#39; /proc/cpuinfogrep --color &#39;\&lt;[0-9]\&#123;1,2\&#125;\&gt;&#39; /proc/cpuinfo</code></pre><p>10、找出ifconfig命令结果中的1-255之间的整数；</p>  <p>9、查找当前系统上名字为student(必须出现在行首)的用户的帐号的相关信息, 文件为/etc/passwd</p>    <pre><code>grep &#39;^student\&gt;&#39; /etc/passwd | cut -d: -f3id -u student</code></pre><p>10、 分析/etc/inittab文件中如下文本中前两行的特征(每一行中出现在数字必须相同)，请写出可以精确找到类似两行的模式：</p><pre><code>l1:1:wait:/etc/rc.d/rc 1l3:3:wait:/etc/rc.d/rc 3grep &#39;^l\([0-9]\):\1.*\1$&#39; /etc/inittab</code></pre></div><h3 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h3><pre><code>grep -E = egrep    字符匹配：        .        []        [^]    次数匹配：        *:         ?:        +: 匹配其前面的字符至少1次        &#123;m,n&#125;    位置锚定：        ^        $        \&lt;        \&gt;    分组：        ()：分组        \1, \2, \3, ...    或者        |: or        C|cat: 为 C或cat 不是 Cat或cat</code></pre><div class="note green icon-padding flat"><p>练习：</p><p>1、显示所有以数字结尾且文件名中不包含空白的文件；</p>    <pre><code>ls *[^[:space:]]*[0-9]   ?????????</code></pre><p>2、找出/boot/grub/grub.conf文件中1-255之间的数字；</p>    <pre><code>\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;ifconfig | egrep &#39;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39; ifconfig | egrep --color &#39;(\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;\.)&#123;3&#125;\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&#39;只查找前三类IP地址：（1-223）\&lt;([1-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[01][0-9]|22[0-3])\&gt;(\.\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;)&#123;2&#125;\.\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-4])\&gt;</code></pre></div><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>   su [-l] 用户名：切换用户<br>   sudo COMMAND：完成部分特权指令</p><pre><code>配置文件/etc/sudoers文件中的如下行： 106 ## Allows people in group wheel to run all commands107 %wheel  ALL=(ALL)       ALL</code></pre><h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><p>SUID: 运行某程序时，相应进程的属主是程序文件自身的属主，而不是启动者；</p><pre><code>chmod u+s FILEchmod u-s FILE    如果FILE本身原来就有执行权限，则SUID显示为s；否则显示S；</code></pre><p>SGID: 运行某程序时，相应进程的属组是程序文件自身的属组，而不是启动者所属的基本组；同时该文件夹下所创建文件的属组是文件夹的属组，而不是创建用户的属组。</p><pre><code>chmod g+s FILEchmod g-s FILE    develop team, hadoop, hbase, hive    /tmp/project/        develop</code></pre><p>Sticky: 在一个公共目录，每个都可以创建文件，删除自己的文件，但不能删除别人的文件；</p><pre><code>chmod o+t DIRchmod o-t DIR</code></pre><p>注：以上三种权限就像rwx一样，也可以使用数字表示。比如 chmod 5755 &#x2F;backup&#x2F;test，而且umask的第一位数字代表的就是这三种权限。</p><h2 id="文件系统访问列表"><a href="#文件系统访问列表" class="headerlink" title="文件系统访问列表"></a>文件系统访问列表</h2><p>FACL(Filesystem Access Control List):利用文件扩展保存额外的访问控制权限 </p><p>setfacl</p><pre><code>-m: 设定    u:UID:perm    d:u：UID：perm 对目录有用，该目录下的新建文件拥有此默认权限    g:GID:perm    d:g：GID：perm 对目录有用，该目录下的新建文件拥有此默认权限-x：取消    u:UID    g:GID</code></pre><p>getfacl：查看文件系统访问权限</p><pre><code>[demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-group::rw-mask::rw- (这个会根据自动变化，为文件的最大权限)other::r--[demo@localhost ~]$ setfacl -m u:demo2:rwx demo.txt [demo@localhost ~]$ getfacl demo.txt # file: demo.txt# owner: demo# group: demouser::rw-user:demo2:rwxgroup::rw-mask::rwx (这个会根据自动变化，为文件的最大权限)other::r--// 目录下设置默认权限[demo@localhost ~]$ setfacl -m d:u:demo2:rw- Desktop/[demo@localhost ~]$ cd Desktop/[demo@localhost Desktop]$ lltotal 0[demo@localhost Desktop]$ touch demo2.txt[demo@localhost Desktop]$ getfacl demo2.txt # file: demo2.txt# owner: demo# group: demouser::rw-user:demo2:rw-group::r-x#effective:r--mask::rw-other::r--[demo@localhost ~]$ lltotal 4-rw-rwxr--+ 1 demo demo 18 Dec 17 11:28 demo.txt  （具有acl属性权限结尾会有+）drwxr-xr-x+ 2 demo demo 23 Dec 25 04:42 Desktop</code></pre><h2 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h2><p>压缩算法不同，压缩比也会不同。常见的压缩格式有：gz, bz2, xz, zip, Z</p><p>Z格式（只能压缩单个文件。如果是文件夹，则是压缩文件夹内的每个文件）</p><pre><code>compress FILENAMEuncompress [demo@localhost ~]$ compress inittab -rw-r--r--. 1 demo demo 390 Dec 29 09:24 inittab.Z[demo@localhost ~]$ uncompress inittab.Z -rw-r--r--. 1 demo demo 511 Dec 29 09:24 inittab</code></pre><p>gz格式（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>gzip /PATH/TO/SOMEFILE：压缩完成后会删除原文件    -d：解压    -#：1-9，指定压缩比，默认是6；gunzip /PATH/TO/SOMEFILE.gz: 解压完成后会删除原文件zcat /PATH/TO/SOMEFILE.gz： 不解压的情况，查看文本文件的内容[demo@localhost ~]$ gzip inittab-rw-r--r--. 1 demo demo 316 Dec 29 09:24 inittab.gz</code></pre><p>bz2格式，该格式比gz有着更大压缩比（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>bzip2 /PATH/TO/SOMEFILE        -d: 解压        -#: 1-9,默认是6        -k: 压缩时保留原文件        bunzip2 /PATH/TO/SOMEFILE.bz2  解压完成后会删除原文件bzcat 不解压的情况，查看文本文件的内容[demo@localhost ~]$ bzip2 inittab -rw-r--r--. 1 demo demo 349 Dec 29 09:24 inittab.bz2</code></pre><p>xz格式：（只能压缩单个文件。如果是文件夹，则是压缩文件内的每个文件）</p><pre><code>xz /PATH/TO/SOMEFILE    -d：解压    -#: 1-9, 默认是6    -k: 压缩时保留原文件        unxz：解压xzdec:解压xzcat：不解压的情况，查看文本文件的内容。[demo@localhost ~]$ xz inittab -rw-r--r--. 1 demo demo 372 Dec 29 09:24 inittab.xz</code></pre><p>注：以上压缩和解压会删除原文件  </p><p>zip: 既归档（可以指定文件夹压缩）又压缩的工具  </p><pre><code>zip FILENAME.zip FILE1 FILE2 ...: 压缩后不删除原文件unzip FILENAME.zip ：解压</code></pre><p>tar: 归档工具, .tar</p><pre><code>-c: 创建归档文件-f FILE.tar: 操作的归档文件（压缩时是压缩后文件名，解压时是解压的文件名）-x: 展开归档--xattrs: 归档时，保留文件的扩展属性信息-t: 不展开归档，直接查看归档了哪些文件-C: 在解压时指定解压后文件的存放位置-zcf: 归档并调用gzip压缩-zxf: 调用gzip解压缩并展开归档，-z选项可省略-jcf: 归档并调用bzip2压缩-jxf:-Jcf: 归档并调xz压缩-Jxf:[demo@localhost etc]$ tar -Jcf conf.tar.xz ./etc  压缩[demo@localhost etc]$ tar -zxf conf.tar.xz -C ./etc/ 解压</code></pre><p>cpio: 归档工具，不常用</p><h2 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h2><p>w：显示目前登陆系统的用户信息（su 切换用户还是显示原用户）</p><pre><code>[demo@localhost ~]$ w 04:52:09 up 33 min,  2 users,  load average: 0.00, 0.03, 0.13USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATdemo     :0       :0               04:20   ?xdm?   1:12   0.26s /usr/libexec/gndemo     pts/0    :0               04:21    1.00s  0.49s  0.01s w</code></pre><p>who：显示当前登录系统的用户（w的简化版）</p><pre><code>[demo2@localhost demo]$ whodemo     :0           2021-12-25 04:20 (:0)demo     pts/0        2021-12-25 04:21 (:0)</code></pre><p>sleep #：等待多少秒<br>whoami：显示当前用户</p><pre><code>[demo2@localhost demo]$ whoamidemo2</code></pre><p>last，显示&#x2F;var&#x2F;log&#x2F;wtmp文件，显示用户登录历史及系统重启历史  </p><pre><code>-n #: 显示最近#次的相关信息[demo2@localhost demo]$ lastdemo     pts/0        :0               Sat Dec 25 04:21   still logged in   demo     :0           :0               Sat Dec 25 04:20   still logged in   demo     :0           :0               Sat Dec 25 04:20 - 04:20  (00:00)    reboot   system boot  3.10.0-1062.el7. Sat Dec 25 04:19 - 04:57  (00:38)    demo     pts/0        :0               Fri Dec 17 11:27 - 11:34  (00:06)    demo     :0           :0               Fri Dec 17 11:25 - crash (7+16:53) </code></pre><p>lastb，&#x2F;var&#x2F;log&#x2F;btmp文件，显示用户错误的登录尝试  </p><pre><code>-n #:[root@localhost demo]# lastbdemo2    pts/0                         Sat Dec 25 04:59 - 04:59  (00:00)    btmp begins Sat Dec 25 04:59:30 2021</code></pre><p>lastlog: 显示每一个用户最近一次的成功登录信息；</p><pre><code>-u USERNAME: 显示特定用户最近的登录信息[root@localhost demo]# lastlogUsername         Port     From             Latestroot             pts/0                     Sat Dec 25 04:59:06 -0500 2021bin                                        **Never logged in**daemon                                     **Never logged in**adm                                        **Never logged in**lp                                         **Never logged in**</code></pre><p>basename：获取文件名</p><pre><code>$0: 执行脚本时的脚本路径及名称[root@localhost demo]# basename /home/demo/demo.txtdemo.txt</code></pre><p>mail：发送邮件</p><pre><code>[root@localhost demo]# mail -s &quot;first&quot; demo &lt; demo.txt [root@localhost demo]# su - demoLast login: Sat Dec 25 04:59:21 EST 2021 on pts/0[demo@localhost ~]$ mailHeirloom Mail version 12.5 7/5/10.  Type ? for help.&quot;/var/spool/mail/demo&quot;: 1 message 1 new&gt;N  1 root                  Sat Dec 25 05:10  18/617   &quot;first&quot;&amp; 1Message  1:From root@localhost.localdomain  Sat Dec 25 05:10:07 2021Return-Path: &lt;root@localhost.localdomain&gt;X-Original-To: demoDelivered-To: demo@localhost.localdomainDate: Sat, 25 Dec 2021 05:10:06 -0500To: demo@localhost.localdomainSubject: firstUser-Agent: Heirloom mailx 12.5 7/5/10Content-Type: text/plain; charset=us-asciiFrom: root@localhost.localdomain (root)Status: Rthis is new file.&amp; 注：用户邮件目录在/var/spool/mail</code></pre><p>hostname: 显示主机名</p><pre><code>如果当前主机的主机名不是www.magedu.com，就将其改为www.magedu.com如果当前主机的主机名是localhost，就将其改为www.magedu.com如果当前主机的主机名为空，或者为(none)，或者为localhost，就将其改为www.magedu.com[ -z `hostname` ] || [ `hostname` == &#39;(none)&#39; -o `hostname` == &#39;localhost&#39; ] &amp;&amp; hostname www.magedu.com</code></pre><p>生成随机数RANDOM: 0-32768</p><pre><code>随机数生成器：熵池(收集系统产生中断的时间作为随机数)/dev/random:(收集系次产生中断的时间作为随机数，如果不足需要等待)/dev/urandom:(收集系统产生中断的时间作为随机数，如果不足则自行生成随机数)[demo@localhost mail]$ echo $RANDOM12963</code></pre><p>ln [-s -v] SRC DEST：建立符号链接</p><pre><code>-s：建立软链接-v：建立硬链接[demo@localhost ~]$ ln -s /etc/inittab ./[root@localhost demo]# ln -v /etc/inittab inittab1 ‘inittab1’ =&gt; ‘/etc/inittab’[root@localhost demo]# lltotal 8-rw-rwxr--+ 1 demo demo  18 Dec 17 11:28 demo.txtdrwxr-xr-x+ 2 demo demo  23 Dec 25 04:42 Desktopdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Documentsdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Downloadslrwxrwxrwx. 1 demo demo  12 Dec 25 05:48 inittab -&gt; /etc/inittab-rw-r--r--. 2 root root 511 Aug  8  2019 inittab1drwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Musicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Picturesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Publicdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Templatesdrwxr-xr-x. 2 demo demo   6 Dec 17 11:17 Videos硬链接：（存储文件的inode）    1、只能对文件创建，不能应用于目录；    2、不能跨文件系统；    3、创建硬链接会增加文件被链接的次数；    符号链接：（存储文件的字符串）    1、可应用于目录；    2、可以跨文件系统；    3、不会增加被链接文件的链接次数；    4、其大小为指定的路径所包含的字符个数；</code></pre><p>du </p><pre><code>-s ：查看文件夹总大小-h ：单位换算[root@localhost etc]# du20./fonts/conf.d24./fonts72./grub.d12./pki/rpm-gpg156./pki/ca-trust/extracted/java......42436[root@localhost etc]# du -s42436.[root@localhost etc]# du -sh42M</code></pre><p>df: </p><pre><code>-h：查看各文件系统的存储  -i：查看各文件系统inode的使用量[root@localhost etc]# df -hFilesystem               Size  Used Avail Use% Mounted ondevtmpfs                 470M     0  470M   0% /devtmpfs                    487M     0  487M   0% /dev/shmtmpfs                    487M  8.7M  478M   2% /runtmpfs                    487M     0  487M   0% /sys/fs/cgroup/dev/mapper/centos-root   17G  4.2G   13G  25% //dev/sda1               1014M  171M  844M  17% /boottmpfs                     98M  4.0K   98M   1% /run/user/42tmpfs                     98M   28K   98M   1% /run/user/1000/dev/sr0                 4.4G  4.4G     0 100% /run/media/demo/CentOS 7 x86_64tmpfs                     98M     0   98M   0% /run/user/0[root@localhost etc]# df -iFilesystem               Inodes  IUsed   IFree IUse% Mounted ondevtmpfs                 120210    391  119819    1% /devtmpfs                    124468      1  124467    1% /dev/shmtmpfs                    124468    995  123473    1% /runtmpfs                    124468     16  124452    1% /sys/fs/cgroup/dev/mapper/centos-root 8910848 155245 8755603    2% //dev/sda1                524288    340  523948    1% /boottmpfs                    124468      6  124462    1% /run/user/42tmpfs                    124468     19  124449    1% /run/user/1000/dev/sr0                      0      0       0     - /run/media/demo/CentOS 7 x86_64tmpfs                    124468      1  124467    1% /run/user/0</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>终端类型：</p><pre><code>console: 控制台 直接连接在计算机上的显示器、鼠标、键盘pty: 物理终端 (VGA) tty#: 虚拟终端 (VGA) 服务器ttyS#: 串行终端pts/#: 伪终端 通过ssh等登陆到linux主机上所使用的终端</code></pre><p>计算机总线：  </p><ul><li>地址总线：内存寻址  </li><li>数据总线：传输数据  </li><li>控制总线：控制指令</li></ul><p>进程：在每个进程看来，当前主机上只存在内核和当前进程。进程是程序的副本，进程是程序执行实例  </p><p>环境变量：  </p><pre><code>PATH  HISTSIZE  SHELL：用户当前使用SHELL  </code></pre><p>LANG&#x3D;en 修改Linux编码  </p><p>read ： 从标准输入中读取数据，并以空格切分。将分割结果存入后面参数中的变量。具体使用参见：<br><a href="https://www.runoob.com/linux/linux-comm-read.html">https://www.runoob.com/linux/linux-comm-read.html</a>  </p><pre><code>-p “PROMPT&quot;: 给出提示    </code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/2022/11/24/combute-basic/"/>
      <url>/2022/11/24/combute-basic/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>本文旨在简单的介绍计算机的组成，包含硬件、操作系统等内容。本内容是以B站马哥Linux运维课程中的操作系统基础结合相关资料整理而来。</p></div><h2 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h2><p>一台计算机由硬件、操作系统、程序组成。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9a0b832f9f9e5a95d12a836ab6d53630?method=download&shareKey=c00765b3eaaae0cc10aa16760a4ea955" alt="image"></p><p>硬件是计算机的基础，计算机的硬件组成可以分为运算器、控制器、存储器、输入&#x2F;输出设备。其中运算器和控制器是构成CPU的主要部分。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB760447eef5a97f121df438b75fc68075?method=download&shareKey=52b7a07d9bf375629854264a447c7701" alt="image"> </p><p>各元件之间的逻辑连接关系如下图所示。各元件之间通过地址线、数据线和控制信号线组成的本地总线链接。目前采用总线复用技术让地址、数据和控制信号使用同一条线路。早期的32位CPU中，其地址线和数据线分别都是32位，因此地址寻址空间范围为2的32次方字节，即从0到4G。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe1436f00078189da4932a78923a7936d?method=download&shareKey=e149a2a88f09bcd5958ce514327a5d64" alt="image"></p><p>早期系统通过两个芯片组进行各元件的连接，分别是： </p><ul><li>北桥：负责链接CPU、内存、显卡等高速设备  </li><li>南桥：负责链接硬盘、网卡、USB等低速设备</li></ul><p>目前北桥已经被整合到了CPU里面，下图为PRO-SW-W480-ACE主板说明图</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB09bda74bccf0f8982f80819324ce11e4?method=download&shareKey=300ea9f175b5eced9beef2872360c0d4" alt="image"></p><h2 id="硬件介绍"><a href="#硬件介绍" class="headerlink" title="硬件介绍"></a>硬件介绍</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU由数十亿个微型晶体管构成。它的工作可以分为三个关键阶段：CPU从系统的主存中提取指令、然后解码该指令的实际内容、然后再由CPU的相关部分执行该指令。CPU内部由寄存器、控制器、运算器和时钟四部分组成，各部分之间通过电信号连接。  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5eeafe804430692ad0e9eead5a1a983?method=download&shareKey=687699edd636019aa7f7d2be4f2605db" alt="image">  </p><ul><li><strong>时    钟</strong>：负责发出CPU开始计时的时钟信号。</li><li><strong>运算器</strong>：负责运算从内存中读入寄存器的数据。 </li><li><strong>寄存器</strong>：可以看作内存的一种，用来暂存指令、数据和地址。  </li><li><strong>控制器</strong>：负责把内存上的指令，数据读入寄存器，并根据指令的结果控制计算机。</li></ul><p>根据功能的不同，可以将寄存器划分为下面这几类。 </p><table><thead><tr><th align="center">种类</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">累加寄存器</td><td align="center">存储运行的数据和运算后的数据</td></tr><tr><td align="center">标志寄存器</td><td align="center">用于反映处理器的状态和运算结果的某些特征以及控制指令的执行</td></tr><tr><td align="center">程序计数器</td><td align="center">用于存放下一条指令所在单元的地址的地方</td></tr><tr><td align="center">基址寄存器</td><td align="center">存储数据内存的起始位置</td></tr><tr><td align="center">变址寄存器</td><td align="center">存储基址寄存器的相对位置</td></tr><tr><td align="center">通用寄存器</td><td align="center">存储任意数据</td></tr><tr><td align="center">指令寄存器</td><td align="center">储存正在被运行的指令，CPU内部使用，程序员无法对该寄存器进行读写</td></tr><tr><td align="center">栈寄存器</td><td align="center">存储栈区域的起始位置</td></tr></tbody></table><p>其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个，其它寄存器一般有多个。在内存中的存储通过地址编号来表示，而寄存器的种类则通过名字来区分。</p><p>至于CPU的指令集，那就是Intel的架构师们的工作。总之，CPU认识这些指令，并且能执行运算。这些指令我们称之为机器代码。机器代码由二进制的01字符串构成不利于人们阅读，因此人们在机器代码的基础上开发了一套汇编代码。汇编代码只有转换为本地代码才能运行。  </p><p>CPU 采用了一系列的措施加快指令的执行过程：</p><blockquote><p>流水线：有电子厂打工经历的读者肯定很熟悉这个流水线模式。CPU的流水线工作方式和工业生产上的流水线概念一样。就是将一个指令的执行过程也分解为多个步骤，CPU中的每个电路只执行其中一个步骤，这样前赴后继加快执行速度。CPU中多个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成几个步骤后再由这些电路单元分别执行。在执行过程中，指令源源不断的送往CPU。让每个电路单元都不闲着，这样就大大的加快了执行速度。  </p></blockquote><blockquote><p>超线程：CPU在进行线程切换的时候，要执行 切换各种寄存器状态等一些操作。把第一个线程的各种寄存器状态写回缓存中保存，然后把第二个线程的相关内容送到各种寄存器上。该过程必不可少，否则待会再将第一个线程切换回来时，不知道该线程的各个状态， 那还怎么接着继续执行呢？也正因为如此，所以这个过程比较慢，大概需要几万个时钟周期。所以后来做了这样的设计，把每个寄存器等都多做一个，就是多做一组寄存器(也包括一些其他相关电路等),CPU在执行A线程时，使用的第一组寄存器，切换到B线程，直接使用第二组寄存器，然后再切换A线程时，再使用第一组寄存器。，CPU就不用再傻傻的等着寄存器值的切换，线程切换只需要几个时钟周期就够了。对于普通的执行多任务的计算机，CPU线程切换是个非常频繁的操作，所以使用该技术就会节省大量的时钟周期。也就是相当于加快了CPU的执行速度。这就是CPU宣传参数中所谓的四核八线程的由来，其实就是超线程技术。(每个核多做一组寄存器等电路固然会占用宝贵的空间，但是它带来的优点远远大于缺点)。 </p></blockquote><blockquote><p>超标量技术: CPU可以在每个时钟周期内执行多个操作,可以实行指令的并行运算。在下面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出来并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。  </p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEBca6d3f2ca384de5d257b260ead71d115?method=download&shareKey=a7e4eea3d1346b04d1eada1e71e3b1bf" alt="image">  </p><blockquote><p>乱序执行: 我们认为程序都是顺序执行的。但是在CPU层面上，指令的执行顺序并不一定与它们在机器级程序(汇编)中的顺序一样。比如 a &#x3D; b+c; d++;这两个语句 不按照顺序执行也不会影响最终结果。当然这只是在CPU执行指令的层面，在程序员们看来，依旧认为程序是顺序执行的。</p></blockquote><blockquote><p>多核芯片：在芯片上有效地承载了四个微型芯片，每个微型芯片都有自己独立的CPU。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB0b07646c4ecb73a0add4e1b5a2a9dfff?method=download&shareKey=7f5a08db7f8b74d0587553a87fafcb62" alt="image">  </p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是一种随机存储器（RAM），表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3eba4f99e53218fdec72fec4e08d9090?method=download&shareKey=f3f97c1a5885c0788caa1c94c0379427" alt="image">  </p><p>内存是编址的，编址的单位是字节（不是比特）。为了便于理解，我们把内存模型映射成为我们现实世界的模型。在现实世界中，内存的模型很像我们生活中的楼房。在这个楼房中，1层可以存储一个字节的数据，楼层号就是地址。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB8993750ef7e3c66bac2868347fa8c680?method=download&shareKey=818ed6e9b52b16bec7a2247ba9780d24" alt="image">  </p><p>内存的内部是由各种IC电路（集成电路）组成的。内存IC是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的IC引脚来进行数据的读写。下面是一个虚拟的IC引脚示意图。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2e9c34cbbec8776b666c35b72bb3b0bc?method=download&shareKey=c943f31ea062208c46c05dd12b6979de" alt="image">  </p><p>图中VCC和GND表示电源，A0-A9是地址信号的引脚，D0-D7表示的是数据信号、RD和WR都是控制信号。将电源链接到VCC和GND后，就可以对其它引脚传递0和1的信号，大多数情况下，+5V表示1,0V表示0。</p><p>我们都知道内存是用来存储数据，那么这个内存IC中能存储多少数据呢？D0-D7表示的是数据信号，也就是说，一次可以输入输出8bit &#x3D; 1byte的数据。A0~A9是地址信号共十个，表示可以指定00000 00000 - 11111 11111共2的10次方&#x3D;1024个地址。每个地址都会存放1byte的数据，因此我们可以得出内存IC的容量就是1KB。 </p><p>如果我们使用的是512MB的内存，这就相当于是512000（512*1000）个内存IC。当然，一台计算机不太可能有这么多个内存IC，然而，通常情况下，一个内存IC会有更多的引脚，也就能存储更多的数据。</p><p>内存IC读写过程如下：  </p><ul><li>写入数据：首先给VCC接通+5V的电源，给GND接通0V的电源，使用A0-A9来指定数据的存储场所，然后再把数据的值输入给D0-D7的数据信号，并把WR（write）的值置为1，执行完这些操作后，即可以向内存IC写入数据。</li><li>读入数据：只需要通过A0-A9的地址信号指定数据的存储场所，然后再将RD的值置为1即可。</li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEB81497d419eab65105d73ab9cd72f29b2?method=download&shareKey=86c4562d73c7ae4724b901546c120882" alt="image">  </p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>磁盘和内存都具有存储功能，它们都是存储设备。内存是一种高速、造价昂贵的存储设备，通过电流来实现存储。而磁盘则是速度较慢、造价低廉的存储设备，通过磁记录技术实现存储。磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，他们以5400rpm、7200rpm、10800rpm或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片33转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为磁道。把一个给定臂的位置上的所有磁道合并起来，组成了一个柱面。   </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1ce7db34d73ec40ecb6ea85135bc6f18?method=download&shareKey=24f1372be02346ec060fc1de5f77a9e5" alt="image">  </p><blockquote><p>注意：固态硬盘不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中。与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p></blockquote><h3 id="输入-x2F-输出设备和设备驱动程序"><a href="#输入-x2F-输出设备和设备驱动程序" class="headerlink" title="输入&#x2F;输出设备和设备驱动程序"></a>输入&#x2F;输出设备和设备驱动程序</h3><p>I&#x2F;O设备一般包括两个部分：设备控制器和设备本身。任何一个硬件设备内部的电路可能跟CPU内部的电路都不一致。因此控制器负责将外部设备的信号转换成CPU总线上能理解的信号以及控制外部设备的传输速率、校验等功能。即I&#x2F;O控制器能够接受操作系统的指令，控制设备。I&#x2F;O控制器中也有用于临时保存输入输出数据的内存，这个内存我们称之为I&#x2F;O内存。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb7382c303e9917c95e83b6edbe2cdd4d?method=download&shareKey=dc3a6ac1c609075617bffd1cc30123a6" alt="image">  </p><h2 id="计算机概念"><a href="#计算机概念" class="headerlink" title="计算机概念"></a>计算机概念</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>计算机的运行离不开程序，程序由指令和数据两部分组成。计算机运行过程中CPU所使用的指令和数据都是来自于主内存。不论是软件程序还是数据，都必须要读入主内存后CPU才能利用。由于CPU的计算速度远大于从内存操作数据的速度，直观表现就是程序的性能在极大程度上受到内存访问次数的影响，内存访问次数越多，性能越差，所以才引入缓存从而减少cpu访问内存的次数。CPU中的缓存分为三层。一二级缓存私有，三级缓存共享。一级缓存分为数据缓存和指令缓存。缓存之所以可以减少CPU访问内存的次数是由于程序的局部性原理：</p><ul><li><p>时间局部性：被引用过一次的存储器位置中的内容在未来会被多次引用  </p></li><li><p>空间局部性：如果一个存储器位置的内容被引用，那么它附近的位置也很大概率被引用。</p></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbe7ae989c55df12e9e5c9016b7414bd6?method=download&shareKey=c3a7b4196623b3fed8259fab738a9928" alt="image"></p><h3 id="IO端口"><a href="#IO端口" class="headerlink" title="IO端口"></a>IO端口</h3><p>计算机接了这么多的外部设备，CPU如何区分不同的I&#x2F;O设备呢？类比计算机区分和互联网通信的各个进程的方法，计算机区分不同的和外部通信的进程靠的是套接字，也就是ip地址+端口号。这里cpu区分不同I&#x2F;O设备靠的也是端口号，称为I&#x2F;O端口，在一台计算机上I&#x2F;O端口的数目也是65535个。任何一个硬件设备通过IO总线接入计算机的时，它必须一开机就申请注册一批连续的I&#x2F;O端口。</p><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>为了更充分的使用CPU的运算能力，计算机引入了多任务的概念。多任务的实现依赖于CPU的时间切片以及虚拟内存地址两项技术。CPU的时间切片可以理解为一项任务运行5ms之后切换其它任务执行，即通过时间片轮转的方法使不同的程序并发执行。虚拟内存地址：由进程的虚地址构成的地址空间。我的理解是CPU中每一个进程的内存地址都是0-某个值（比如1024），根据不同的进程映射到不同的内存地址中。</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>当计算机上运行多个任务，这时从键盘上输入数据或者移动鼠标时计算机是如何快速响应的？这就依赖于中断机制。程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序(中断服务程序)，待处理完后，再返回原来的程序运行，这整个过程称为程序中断;</p><p>I&#x2F;O设备和CPU之间的信息交流通过中断机制来实现。中断是用来暂停当前正在运行的程序，然后跳转到其他程序运行的必要机制。  </p><p>每个设备发送信号通知CPU来查看，CPU怎么得知是哪个设备的信号呢？可能你会想到通过I&#x2F;O端口来识别，但I&#x2F;O端口是实现数据交互而不是识别信号交互的。中断控制器就登场了。</p><p>中断控制器（Interrupt Controller）：CPU外置芯片，接收中断信号。当某个外部设备（例如网卡卡）传来信号，CPU中断当前操作，将此信号接收至内存中。中断控制器上连接着中断线，每根线代表一个设备（不是固定的设备），用来区分外部设备，线路是可以复用的。</p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>直接存储器访问（DMA）: 它可以控制内存和某些控制器之间的数据传输，而无需CPU的干预。比如希望外设A的数据拷贝到外设B，只要给两种外设提供一条数据通路，直接让数据由A拷贝到B不经过CPU的处理。由CPU在内存中划好某次传输数据所需空间，并授权某根线路给DMA使用。否则，CPU 需要从来源把每一片段的数据复制到暂存器，之后把它们再次写回到新的进程空间。在这个时间中，CPU 对于其他的工作来说就无法使用。</p><p>DMA依赖于CPU外置的DMA控制器芯片。在实现DMA传输时，是由DMA控制器直接掌管总线。因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器。而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程必须经过DMA请求、DMA响应、DMA传输、DMA结束4个步骤。</p><p>在物理内存当中，最低地址段中的空间就预留给了DMA。一般大小为16M。在DMA最前面还有1M使用的空间是留给BIOS。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB672d57b20ba18a9f89a4467c41770579?method=download&shareKey=8b548b2cebd4abe92784a69245f7a0ad" alt="image">  </p><h3 id="SMP"><a href="#SMP" class="headerlink" title="SMP"></a>SMP</h3><p>现在CPU都是多核的，而在服务器领域使用多颗CPU是正常的。在SMP（对称多处理器：一块主板上有多个CPU插槽）多CPU架构中，每个插槽称为一个socket。当多个CPU访问同一个内存，传统上多CPU对于内存的访问是总线方式。总线方式就会存在资源争用和临界区问题，而且如果不断的增加CPU数量，内存的争用会愈演愈烈。这就体现在4核CPU的跑分性能达不到2核CPU的2倍，甚至1.5倍都没有。理论上来说这种方式实现12core以上的CPU已经没有太大的意义。</p><p>为了防止多颗CPU访问内存出现资源争用，可以为每个CPU分配一个专用内存并且配有专用控制器。由于内存属于系统级别，内核加载时有可能把数据加载到不同CPU的专用内存上。同时每个CPU都有自己的进程队列，这些队列会不断被内核进行平衡（rebalancing），确保资源平均利用。这样就有可能会导致1号CPU需要到2号CPU的专用内存上读写数据，这种现象称为非一致性内存访问（NUMA）。如下图，CPU 0-3访问自己的内存需要1、2、3步骤（3个时钟周期），而访问CPU 4-7的内存需要1、1a、2、3步骤，其中1a就需要消耗3个时钟周期。</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBe521c3b43a42aca7e0cc418a043987de?method=download&shareKey=9162438460f30dcd3d07f9640f50dd5c" alt="image"></p><p>在企业中，NUMA问题是很常见的。为了避免内存间交叉访问导致性能下降，可以禁止内核进行平衡。对于比较繁忙的、需要经常执行的批处理服务进程可以采取CPU绑定策略。</p><p>Intel的NUMA解决方案：放弃总线的访问方式，将CPU划分到多个Node中。每个node有自己独立的内存空间。各个node之间通过高速互联通讯，通讯通道被称为QuickPath Interconnect即QPI。</p><h3 id="多信道设计"><a href="#多信道设计" class="headerlink" title="多信道设计"></a>多信道设计</h3><p>由于所有的数据都必须要存放在主内存，所以主内存的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达64比特。为了加大这个宽度，芯片组厂商就将两个主内存汇整在一起。如果一支内存可达64比特，两支内存就可以达到128比特了。这就是双信道的设计理念。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>操作系统是硬件层上的一层软件，它提供系统调用并屏蔽了硬件层面上的差异。操作系统负责整个计算机的内存管理、硬件管理、文件管理以及应用管理。</p><p>有时我们将操作系统也称为虚拟机。因为我们只有一块cpu芯片(可能是多核心的)，只有一块内存，只有一个鼠标，只有一个键盘……。每个进程都想独占这一整套资源。cpu可以通过时间片轮转的方式将一个cpu芯片虚拟成多个cpu运行。内存的虚拟通过分页机制和虚拟地址空间。现在已经把计算机系统中最重要的两个部件CPU和内存虚拟出来了。剩下的那些I&#x2F;O设备如何虚拟呢？其实IO虚拟不需要专门去做，因为当前哪个进程获得了系统使用权，I&#x2F;O设备就交给该进程。</p><h3 id="CPU指令模式"><a href="#CPU指令模式" class="headerlink" title="CPU指令模式"></a>CPU指令模式</h3><p>有了操作系统之后。在某一时刻，要么是内核进程（操作系统核心）在上面运行，要么是用户空间进程在上面运行。内核在cpu上运行时称为内核模式，进程在cpu上运行时称为用户模式。在内存中内核占据的那段内存空间称为内核空间，用户进程占据的空间叫用户空间。用户模式时，进程是不能直接控制硬件的。这是因为在cpu内部，cpu制造商将cpu能运行的指令划分为４层(仅对x86架构而言)，ring0，ring1，ring2，ring3。由于历史原因，ring1和ring2并没有使用，linux只用了ring0和ring3。ring0称为内核模式，也称为特权指令模式，可以直接操控硬件。ring3是用户模式，可以执行一般指令。</p><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><p>内存是易失性存储，即断电之后所有数据都会被清空。CPU运行所需的指令和数据都要从内存中获取。那么计算机是如何启动的呢？</p><p>在计算机主板上有一个ROM芯片（非易失性存储），该芯片存储了BIOS程序。在按下电源键之后系统会自动将BIOS程序加载到内存中然后执行。BIOS程序主要负责确定硬件是否正常，没有异常的话会根据配置文件（存储在CMOS）中的设备启动顺序查找MBR（主引导记录）。</p><p>MBR会查找活动分区，加载活动分区中的内核代码。然后将控制权转移给内核。接下来就进入操作系统的启动流程。</p><p>目前最新的是UEFI+GPT方式。UEFI可以认为是BIOS的升级版。GPT是MBR的升级版，2T以上的硬盘需要使用gpt。</p><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>设备驱动程序是I&#x2F;O系统的高层与设备控制器之间的通信程序，工作在内核模式。其主要任务：</p><ul><li>再把它转化为具体要求，发送给设备控制器，启动设备去执行。</li><li>反方向，它也将由设备控制器发来的信号，传送给上层软件。</li><li>接收上层软件发来的抽象I&#x2F;O要求（Linux中一切皆文件），如read、write等命令；</li></ul><h3 id="固件和驱动"><a href="#固件和驱动" class="headerlink" title="固件和驱动"></a>固件和驱动</h3><p>固件是直接写入ROM中的程序，比如BIOS。它直接和硬件打交道，指导硬件怎么干活。驱动负责操作系统和设备控制器之间的通信，告诉硬件要干什么。驱动一般运行在操作系统上，由操作系统进行管理。而固件往往直接”固定”在硬件上，直接控制硬件；</p><ul><li><p>eg1：利用打印机打印东西时：</p><ul><li>驱动的作用就是告诉打印机，要打印什么。</li><li>固件则告诉打印机，要怎么执行操作(把纸弄上打印区，然后喷墨，从哪里出纸等)。</li></ul></li><li><p>eg2. BIOS即为主板上的固件，功能 ：上电 - 进入BIOS - 自检(检查设备是否正常等) - 初始化各个模块(内存以及加载其他必要的固件等) - 转移控制到系统启动程序。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>本文简单介绍了计算机组成、硬件组成（CPU、内存、硬盘、IO设备）、连接方式、计算机基础概念（IO端口、中断、DMA、SMP、多通道）、计算机如何启动、驱动和固件等相关内容。在写作本文的过程中发现我脑子里有东西，但是什么都写不出来。上次面试时面试官问我计算机的组成？我只答出CPU、内存、硬盘、IO设备，CPU从内存中获取指令和数据。好尴尬！！！！真的只能说是一听就会，一说就废。</p></div><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat"><p>1. 简单描述一下本文讲了些什么？</p><p>2. 简单介绍一下计算机的组成、计算机硬件的连接方式、多任务、计算机如何区分IO设备、CPU如何和IO设备之间交互、DMA机制、SMP架构、多通道、驱动的概念？</p><p>3. 计算机如何启动?</p><p>4. 驱动和固件的区别？</p></div><div class="note green icon-padding flat"><p>**参考内容**：</p> <p>1. B站马哥Linux运维课程中的操作系统基础  </p> <p>2. 内存--通俗理解：<https://blog.csdn.net/youhuakongzhi/article/details/109039652>  </p> <p>3. 程序员必知的硬核知识大全  </p> <p>4. 认识操作系统</p> <p>5. 图解操作系统</p> <p>6. Linux内核完全注释</p> <p>5. 固件和驱动区别 [https://blog.csdn.net/qq_36779888/article/details/108681805](https://blog.csdn.net/qq_36779888/article/details/108681805)</p> </div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2022/11/24/MakeBlog/"/>
      <url>/2022/11/24/MakeBlog/</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><p>为什么写博客？我写博客的原因有三点：将学到的内容表达出来、整合所学的内容串联成为系统、作为自己的知识库。</p><p></p><p>为什么选择个人博客？我搭建个人博客的原因是由于个人博客的样式可控。</p></div><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>机器环境: CentOS Linux release 7.7.1908 (Core)  </li><li>内核环境: 3.10.0-1062.el7.x86_64</li></ul><p>本博客采用nodejs平台+hexo框架+Butterfly主题+Github Pages搭建</p><ul><li>nodejs 是一个javascirpt的运行环境。我的理解为js原本是在浏览器上运行的脚本语言，有了nodejs之后，js就可以像shell脚本一样直接在机器上运行。</li><li>hexo框架是一个基于node.js的快速生成静态博客的框架</li><li>Butterfly是hexo博客的一款主题。</li><li>Github Pages是github提供的一项静态站点托管服务。</li></ul><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h3 id="搭建本地Hexo"><a href="#搭建本地Hexo" class="headerlink" title="搭建本地Hexo"></a>搭建本地Hexo</h3><h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>本文采用nodejs的二进制安装方式，由于我的Linux机器为CentOS 7，安装最新版会报错，因此我选择安装12.15.0这个版本。  </p><pre><code># 进入根目录cd /usr/local/# 获取二进制安装包wget https://nodejs.org/download/release/v12.15.0/node-v12.15.0-linux-x64.tar.gz# 解压tar -xf node-v12.15.0-linux-x64.tar.gzrm -rf node-v12.15.0-linux-x64.tar.gz# 创建软件包链接ln -sv node-v12.15.0-linux-x64/ nodejs# 让命令可以直接执行ln -sv /usr/local/nodejs/bin/node /usr/local/binln -sv /usr/local/nodejs/bin/npm /usr/local/bin# 检查是否能够运行[root@localhost bin]# node -vv12.15.0[root@localhost bin]# npm -v6.13.4</code></pre><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>查看是否安装git。hexo初始化的时候需要使用git命令从github下载hexo相关代码，后期将博客部署到github上也依赖git。</p><pre><code>[root@localhost bin]# git --versiongit version 1.8.3.1</code></pre><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>在家目录下建立blob目录作为hexo的根目录</p><pre><code># 建立目录mkdir ~/blobcd ~/blob# 永久设置npm源（不修改执行的时候会卡住）npm config set registry https://registry.npm.taobao.org# 安装hexo-cli，nodejs的npm相当于Linux的yum[root@localhost blob]# npm install -g hexo-cli/usr/local/node-v12.15.0-linux-x64/bin/hexo -&gt; /usr/local/node-v12.15.0-linux-x64/lib/node_modules/hexo-cli/bin/hexonpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules/hexo-cli/node_modules/chokidar/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted &#123;&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;&#125; (current: &#123;&quot;os&quot;:&quot;linux&quot;,&quot;arch&quot;:&quot;x64&quot;&#125;)+ hexo-cli@4.3.0added 59 packages from 51 contributors in 5.498s# 初始化文件夹hexo init# 安装 hexo 所需要的依赖包npm install</code></pre><p>在安装中遇到如下问题：Error: ENOENT: no such file or directory, uv_cwd</p><p>解决方案：重启终端</p><h4 id="启动hexo"><a href="#启动hexo" class="headerlink" title="启动hexo"></a>启动hexo</h4><p>hexo 常用命令：</p><ul><li>hexo g 生成静态网站</li><li>hexo s 启动服务器</li><li>hexo d 部署</li><li>hexo clean 清理生成的静态网站</li></ul><p>部署：</p><pre><code>[root@192 blob]# hexo g &amp;&amp; hexo sINFO  Validating configINFO  Start processingINFO  Files loaded in 130 msINFO  Generated: archives/index.htmlINFO  Generated: archives/2022/index.htmlINFO  Generated: archives/2022/11/index.htmlINFO  Generated: index.htmlINFO  Generated: fancybox/jquery.fancybox.min.cssINFO  Generated: js/script.jsINFO  Generated: css/style.cssINFO  Generated: 2022/11/21/hello-world/index.htmlINFO  Generated: css/fonts/fontawesome-webfont.woffINFO  Generated: css/fonts/fontawesome-webfont.woff2INFO  Generated: css/fonts/FontAwesome.otfINFO  Generated: fancybox/jquery.fancybox.min.jsINFO  Generated: js/jquery-3.4.1.min.jsINFO  Generated: css/fonts/fontawesome-webfont.eotINFO  Generated: css/fonts/fontawesome-webfont.ttfINFO  Generated: css/images/banner.jpgINFO  Generated: css/fonts/fontawesome-webfont.svgINFO  17 files generated in 410 msINFO  Validating configINFO  Start processingINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</code></pre><p>访问网站：<br><img src="https://yushuaigee.gitee.io/myblog/img/image-20201220204625063.png" alt="images"></p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>hexo的主题可以在github仓库中搜索hexo-theme或者hexo官网查找，本文使用的主题为butterfly。</p><pre><code># 从github仓库中下载主题（hexo根目录中）：git https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly# 修改hexo根目录下_config.xml 配置文件theme: landscape 改为 theme: butterfly# 重新部署hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>在浏览器中打开报如下问题：</p><pre><code># 显示内容：extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pug解决方案（hexo根目录）：npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></pre><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1c51af39bb0820efc4ea19d42c7252b2?method=download&shareKey=577f858ad5b22a1545471f53e5f2416e" alt="image"></p><h3 id="优化主题"><a href="#优化主题" class="headerlink" title="优化主题"></a>优化主题</h3><p>至此，上面的博客已经具有了一个框架。下面我们进行相应的优化。参考博客：  </p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><p>更改博客主题、描述、作者、语言、时区（hexo根目录下配置文件）</p><pre><code># Sitetitle: 知与行subtitle: &#39;&#39;description: &#39;学而不思则惘，思而不学则殆&#39;keywords:  author: QiYanlanguage: zh-CNtimezone: Asia/Shanghai</code></pre><p>图像修改：背景图下载地址<a href="https://wallhaven.cc/">https://wallhaven.cc/</a> ，图像放到hexo_root&#x2F;themes&#x2F;主题名&#x2F;source&#x2F;img&#x2F;。如下修改的是主题配置文件（hexo_root&#x2F;theme&#x2F;主题名&#x2F;_config.xml）。</p><pre><code># 主页图index_img: /img/background.jpg    # 头像：avatar:  img: /img/avatar.png#文档图（cover:  # display the cover or not (是否顯示文章封面)  index_enable: false  aside_enable: false  archives_enable: false  # the position of cover in home page (封面顯示的位置)  # left/right/both  position: both  # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)  default_cover: </code></pre><p>cover中设置default_cover之后，文件列表和文章内容的top图都是同一张图。<br>解决方案：<a href="https://blog.csdn.net/zzq0523/article/details/122954271">https://blog.csdn.net/zzq0523/article/details/122954271</a>）</p><p>修改菜单：</p><pre><code>menu:   首页: / || fas fa-home   归档: /archives/ || fas fa-archive   标签: /tags/ || fas fa-tags   分类: /categories/ || fas fa-folder-open  # List||fas fa-list:  #   Music: /music/ || fas fa-music  #   Movie: /movies/ || fas fa-video  # Link: /link/ || fas fa-link   关于: /about/ || fas fa-heart</code></pre><p>创建相关页面</p><pre><code>#前往你的 Hexo 博客的根目錄hexo new page tags#找到source/tags/index.md這個文件添加 type: &quot;tags&quot;并将title后的名字改为中文 ---title: 標籤date: 2018-01-05 00:00:00type: &quot;tags&quot;---# 添加分类页hexo new page categories---title: 分类date: 2022-11-21 08:20:51types: &quot;categories&quot;---</code></pre><p>添加动态文字：</p><pre><code>subtitle:  enable: true  # Typewriter Effect (打字效果)  effect: true  # Effect Speed Options (打字效果速度參數)  startDelay: 300 # time before typing starts in milliseconds  typeSpeed: 150 # type speed in milliseconds  backSpeed: 50 # backspacing speed in milliseconds  # loop (循環打字)  loop: true  # source 調用第三方服務  # source: false 關閉調用  # source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/  # source: 2  調用今日詩詞（簡體） https://www.jinrishici.com/  # subtitle 會先顯示 source , 再顯示 sub 的內容  source: false  # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字  sub:    - 今日事&amp;#44;今日畢    - Never put off till tomorrow what you can do today</code></pre><p>安装搜索框</p><pre><code>[root@192 butterfly]# npm install hexo-generator-search --savenpm notice created a lockfile as package-lock.json. You should commit this file.+ hexo-generator-search@2.4.3added 6 packages from 5 contributors in 1.551s# 修改主题配置文件local_search:  enable: true# 重启hexo否则会报错hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code></pre><p>添加字数统计功能：</p><pre><code>npm install hexo-wordcount --save# 修改主题配置文件wordcount:     enable: true# 重启hexo</code></pre><p>给文章列表添加字数统计：  </p><p><a href="http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/">http://doraemonzzz.com/2021/06/13/2021-6-13-%E7%BB%99Hexo-Butterfly%E4%B8%BB%E9%A2%98%E9%A6%96%E9%A1%B5%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%95%B0%E6%80%BB%E8%AE%A1%EF%BC%8C%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/</a></p><h3 id="修改字体"><a href="#修改字体" class="headerlink" title="修改字体"></a>修改字体</h3><p><a href="https://imbhj.com/25c13146/">https://imbhj.com/25c13146/</a><br><a href="https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/">https://jingzhi1208.github.io/2021/11/26/hexo-butterfly%E4%B8%BB%E9%A2%98%E4%B8%8B%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/</a></p><h2 id="托管静态页面"><a href="#托管静态页面" class="headerlink" title="托管静态页面"></a>托管静态页面</h2><h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><p>首先在github中注册账号  </p><p>创建仓库。每个用户只能创建一个github pages，因此仓库名称必须为&lt;用户名&gt;.github.io，否则创建的为普通仓库</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229224741804.png" alt="image">、</p><p>在github pages仓库中创建一个index.html文件用于测试  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229225639083.png" alt="image"></p><p>在浏览器页面输入https:&#x2F;&#x2F;用户名.github.io&#x2F; 查看是否访问成功  </p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229230057034.png" alt="image"></p><h3 id="免密登录github"><a href="#免密登录github" class="headerlink" title="免密登录github"></a>免密登录github</h3><p>CentOS中生成登录密钥：</p><pre><code># 其中 邮箱名 是你注册 GitHub 的邮箱ssh-keygen -t rsa -C &quot;邮箱名&quot; # 后面输入三个回车</code></pre><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229233801498.png" alt="image"></p><p>CentOS 进入~&#x2F;.ssh目录，复制id_rsa.pub中的内容。将公钥复制到github中。</p><p><img src="https://yushuaigee.gitee.io/myblog/img/image-20201229235220955.png" alt="image"></p><p>测试是否能够正常连接：</p><pre><code>[root@192 images]# ssh -T git@github.comHi qiyankuo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><h3 id="发布到github"><a href="#发布到github" class="headerlink" title="发布到github"></a>发布到github</h3><p>安装部署插件</p><pre><code># 这样执行会报错[root@192 blob]# npm install hexo-deplyer-gitnpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmmirror.com/hexo-deplyer-git - [NOT_FOUND] hexo-deplyer-git not foundnpm ERR! 404 npm ERR! 404  &#39;hexo-deplyer-git@latest&#39; is not in the npm registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404 npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.npm ERR! A complete log of this run can be found in:npm ERR!     /root/.npm/_logs/2022-11-22T02_25_42_682Z-debug.log# 正确方式[root@192 blob]# npm install hexo-deployer-git --save# 修改hexo根目录下配置文件deploy:  type: &#39;git&#39;  repo: git@github.com:用户名/仓库名  #如：git@github.com:qiyankuo/qiyankuo.github.io.git  branch: main# 发布hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </code></pre><p>在浏览器中输入https:&#x2F;&#x2F;用户名.github.io&#x2F;进行测试（这个可能会有些延迟）</p><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><h3 id="git相关概念"><a href="#git相关概念" class="headerlink" title="git相关概念"></a>git相关概念</h3><p><a href="https://www.runoob.com/git/git-workspace-index-repo.html">https://www.runoob.com/git/git-workspace-index-repo.html</a></p><h3 id="创建仓库并上传图片"><a href="#创建仓库并上传图片" class="headerlink" title="创建仓库并上传图片"></a>创建仓库并上传图片</h3><p>在github中新建仓库images</p><p>在CentOS下关联github仓库，进行图片管理</p><pre><code># 先进入准备放置github仓库的目录cd ...# 克隆仓库git clone 仓库地址 # 如：https://github.io/qiyankuo/images# 将需要添加的图片移动到仓库目录中mv ... ...git add 文件名  # 添加xyz文件至indexgit commit -m &quot;描述&quot;  # 提交git remote origin git@github.com:qiyankuo/images.git  # 设置远程连接别名git push origin main  # 将本地内容提交到github中</code></pre><h3 id="引用图片地址"><a href="#引用图片地址" class="headerlink" title="引用图片地址"></a>引用图片地址</h3><p>在github中找到图像发现无法显示，在图片上右键在新标签中打开图像显示url如下：<a href="https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg">https://raw.githubusercontent.com/qiyankuo/images/main/hexo/betterfly.jpg</a></p><p>参照网上教程使用免费的CDN服务jsDriver进行github加速，但是我发现这个好像不能用。故我采用如下方式：</p><ul><li><p>github镜像 <a href="https://hub.nuaa.cf/">https://hub.nuaa.cf/</a> 访问上面的图片将githubusercontent.com修改为nuaa.cf。即</p><pre><code>  https://raw.nuaa.cf/qiyankuo/images/main/hexo/betterfly.jpg  注：这种方式发现本地部署和github pages中都无法查看</code></pre></li><li><p>Github RAW 加速服务<a href="https://www.7ed.net/start/raw-cdn.html">https://www.7ed.net/start/raw-cdn.html</a>，在githubusercontent中添加上s就可以了。即</p><pre><code>  [https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg](https://raw.githubusercontents.com/qiyankuo/images/main/hexo/betterfly.jpg)  注：这种方式发现本地部署可以查看，浏览器也可以查看，但是github pages页面中无法查看</code></pre></li><li><p>最终采用有道云笔记存储图片，或者可以用gitee存储图片。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat"><p>    经过了三四天的时间终于将自己的个人博客搭建完成。搭建博客的过程中也遇到了很多问题。首先，原本准备使用next主题，但是这个主题有一些地方无法调整，当时想过放弃或者先搭建一个后期再通过学习前端进行修改。之后当看到51cto的博客样式，这个博客已经满足我的基本需要。当我无意中找到butterfly官网的文章之后，感觉这就是我想要的文章样式。</p><p>    其次，起初采用github搭建，但是考虑到github国内访问速度较慢。开始转gitee上搭建，但是gitee需要实名认证（被拒了）。继续github进行搭建。</p><p>    搭建完之后发现jsDriver不能使用，最终找到了Github RAW 加速服务进行替换。后期计划的话博客样式应该还会不断的进行调整。最后，准备使用typora和picgo搭建书写博客的环境，typora收费，picgo官网上说仅在Windows和macos进行了测试。</p><p>    目前更新了文章之后发布都是手动发布的，图片也是手动上传。我准备做一个shell脚本，自动完成图片的上传替换以及自动发布功能。当然，博客搭建完了。更重要的是不断的更新自己的知识，不断的发布博客。即不能为了发博客而写博客，也不能因为忙而不写博客。</p></div><div class="note green icon-padding flat"><p>参考文档：</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://zhuanlan.zhihu.com/p/105715224</p><p>https://butterfly.js.org/posts/dc584b87</p><p>https://yushuaigee.gitee.io/2020/12/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6/</p></div>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/21/hello-world/"/>
      <url>/2022/11/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
