<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux文件系统 | 知与行</title><meta name="author" content="QiYan"><meta name="copyright" content="QiYan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相成。同时，文件系统也是一个操作系统的重要组成部分。   基础知识在Linux中一切皆文件 [demo@localhost dev]$ ll 文件类型                   主设备号 次设备号 c">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux文件系统">
<meta property="og:url" content="http://example.com/2022/11/27/Linux-file/index.html">
<meta property="og:site_name" content="知与行">
<meta property="og:description" content="计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相成。同时，文件系统也是一个操作系统的重要组成部分。   基础知识在Linux中一切皆文件 [demo@localhost dev]$ ll 文件类型                   主设备号 次设备号 c">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-27T07:57:24.976Z">
<meta property="article:modified_time" content="2022-11-27T07:57:24.974Z">
<meta property="article:author" content="QiYan">
<meta property="article:tag" content="LVM">
<meta property="article:tag" content="RAID">
<meta property="article:tag" content="XFS">
<meta property="article:tag" content="MBR">
<meta property="article:tag" content="GPT">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/11/27/Linux-file/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux文件系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 15:57:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="知与行" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">知与行</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux文件系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-27T07:57:24.976Z" title="发表于 2022-11-27 15:57:24">2022-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T07:57:24.974Z" title="更新于 2022-11-27 15:57:24">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux文件系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="note blue icon-padding flat">
<p>计算机在运行过程所需的指令以及数据都从内存中获取，但是计算机一旦断电则内存中的数据都会消失。磁盘虽然速度较慢，但是造价低、存储空间大、非易失性存储。因此，在计算机的存储中磁盘和内存正好相辅相成。同时，文件系统也是一个操作系统的重要组成部分。</P>
</div>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>在Linux中一切皆文件</p>
<pre><code>[demo@localhost dev]$ ll
文件类型                   主设备号 次设备号
crw-rw-rw-. 1 root tty       5,     0 Dec 25 04:19 tty
crw--w----. 1 root tty       4,     0 Dec 25 04:19 tty0
crw--w----. 1 root tty       4,     1 Dec 25 04:19 tty1
brw-rw----. 1 root disk      8,     0 Dec 25 04:19 sda
brw-rw----. 1 root disk      8,     1 Dec 25 04:19 sda1
brw-rw----. 1 root disk      8,     2 Dec 25 04:19 sda2
                         
设备文件类型：
b: 按块为单位，随机访问的设备；
c：按字符为单位，线性设备；

主设备号 （major number）
    标识设备类型
次设备号 （minor number）
    标识同一种类型中不同设备
</code></pre>
<p>创建特殊文件</p>
<pre><code>mknod [OPTION]... NAME TYPE MAJOR（主设备号） MINOR（次设备号）
    -m MODE ： 指定权限

[root@localhost dev]# mknod sda3 b 8 3
[root@localhost dev]# mknod -mode 660 sda4 b 8 3
</code></pre>
<p>磁盘设备的设备文件名：</p>
<pre><code>IDE, ATA：hd
SATA：sd
SCSI: sd
USB: sd
同种设备以a，b，c...来区分同一种类型下的不同设备，即sda, sdb, sdc, ...

IDE: 
    第一个IDE口：主、从
        /dev/hda, /dev/hdb
    第二个IDE口：主、从
        /dev/hdc, /dev/hdd
</code></pre>
<p>同一磁盘设备文件分区名:</p>
<pre><code>如hda: 
    hda1: 第一个主分区
    hda2: 第二个主分区
    hda3: 第三个主分区
    hda4: 第四个主分区（MBR中的扩展分区）
    hda5: 第一个逻辑分区
</code></pre>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h3><p>首先了解一下磁盘的物理结构。磁盘是由一个个光盘结合在一起，每个光盘上都有一些同心圆。这些同心圆我们称之为磁道，然后将磁道划分为一个个的扇区作为基本存储单元。同时每一个光盘的同一扇区称之为柱面。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB362e3b95a3888dcdf1fc43d21c8daa00?method=download&shareKey=974939cf6495a01ed31327a286a5aa35" alt="image"></p>
<p>磁盘刚被创建出来后，没有任何信息。磁盘在出厂的时候会进行低级格式化。格式化之后的扇区由前导码（包括柱面号、扇区号等）、数据区和ECC（数据纠错码）组成。</p>
<p>大部分的磁盘能够划分出一到多个分区，叫做磁盘分区。每个分区都有独立的文件系统，每块分区的文件系统都可以不同。目前磁盘的分区组织方式有两种，分别为MBR和GPT。  </p>
<h3 id="分区组织方式"><a href="#分区组织方式" class="headerlink" title="分区组织方式"></a>分区组织方式</h3><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>磁盘的0号分区称为主引导记录（MBR），位于磁盘的第一扇区。MBR由Bootloader（446bytes）、Partition Table（64bytes，每个16个字节记录一个分区）、Magic Number（2个字节）组成。  </p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB373eb090e2c333bc226709ac8b7ff105?method=download&shareKey=06a6b63acbf2ef85453d7227a63f4643" alt="image"></p>
<ol>
<li><p>Bootloader:用于标识操作系统的放置方式和位置，以便可以将其加载到计算机的内存中。    </p>
</li>
<li><p>Partition Table:由于Partition Table最多只能包含四条记录。如果磁盘分区大于4，需要将最后一条记录添加为扩展分区。扩展分区可以存储更多的分区记录。</p>
</li>
<li><p>Magic Number：如果为0x55 0xAA，则代表该设备MBR中含有Bootloader。</p>
</li>
</ol>
<p>在计算机启动过程中会首先启动BIOS检查各种硬件环境，之后根据BIOS的配置挨个查看存储设备的前512字节是不是以0x55 0xAA结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载该磁盘MBR中的Bootloader。并将控制权转移到相应设备（U盘、硬盘）的引导加载程序(Bootloader)。</p>
<p>MBR存在如下限制：</p>
<ol>
<li>操作系统无法抓取到2.2T以上的磁盘容量</li>
<li>MBR仅有一个区块。若被破坏后，经常无法或很难救援</li>
<li>MBR内存开机管理程序的区块仅446Bytes，无法容纳较多的程序码</li>
</ol>
<h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p>GPT不存在如上所述的限制。</p>
<blockquote>
<p>过去一个扇区的大小为512Bytes，目前已经有4K的扇区出现。为了相容于所有的磁盘，所以引入了逻辑区块位址（LBA)的概念。GPT将磁盘所有扇区以此LBA（默认为512Bytes喔！）来规划，而第一个LBA称为LBA0.</p>
</blockquote>
<p>GPT使用了34个LBA区块来记录分区信息。同时整个磁盘的最后33个LBA也拿来作为一个备份。GPT结构如下图：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB1a6a41e7d27580e02d1060e36902cd66?method=download&shareKey=9aa1e15262c5049a57738d48448694f5" alt="image"></p>
<p>LBA0 (MBR兼容）</p>
<p>与MBR模式相似的，这个相容区块也分为两个部分。一个就是根之前446Bytes相似的区块，存储了第一阶段的开机管理程序。而在原本的分区表的记录区内放入了一个特殊标志，用来表示此磁盘为GPT格式。而不懂GPT分区表的磁盘管理程序，就不会认识这颗磁盘。除非用户有特别要求要处理这颗磁盘。</p>
<p>LBA1 （GPT表头）</p>
<p>记录了备份用的GPT分区放置的位置，同时放置了分区表的校验机制码。操作系统可以根据这个校验码来判断GPT是否正确。若有错误，还可以通过这个记录区来取得备份的GPT来恢复GPT的正常运行。</p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>磁盘在使用之前要进行高级格式化，高级格式化即在分区上分配文件系统。</p>
<h4 id="ext-系列"><a href="#ext-系列" class="headerlink" title="ext 系列"></a>ext 系列</h4><p>每个文件系统的结构如下：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBd28a8793ae46cdcd002c271e2f45bcac?method=download&shareKey=255b05b4812120ce65529dfddcf1bb03" alt="image"></p>
<ul>
<li>引导块：为了一致性，每个分区都要从引导块开始，即使引导块不包括操作系统。引导块占据文件系统的前4096个字节，从磁盘上的字节偏移量0开始。引导块可用于启动操作系统。  </li>
<li>超级块：描述整个分区的文件系统信息。例如块大小、文件系统的大小、文件系统的块数等。  </li>
<li>空闲空间管理：块位图和inode位图。块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块。其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用</li>
<li>inode：一个文件除了数据需要存储之外，一些描述信息也需要存储。例如文件类型（常规、目录、符号链接等），权限，文件大小，创建&#x2F;修改&#x2F;访问时间等。也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中</li>
<li>根目录：存放文件系统目录树的根部。</li>
<li>文件和目录：存储文件和目录的数据。</li>
</ul>
<p>文件系统逻辑结构图：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB8fafced3dd9b543ffa04545dfc65680e?method=download&shareKey=c8803f0b05537d766c6ad7f60b7588da" alt="image"></p>
<p>Linux支持的文件系统</p>
<ul>
<li>ext3, ext4, ext2: extended</li>
<li>reiserfs</li>
<li>iso9660, swap, cifs, nfs</li>
<li>xfs, jfs</li>
<li>ocfs2, gfs2</li>
<li>fat32, ntfs</li>
</ul>
<h4 id="xfs文件系统"><a href="#xfs文件系统" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><p>CentOS 7 开始，默认的文件系统已经由原本的Ext4 变成了xfs 这个较适合大容量磁盘与巨型文件性能较佳的文件系统了。</p>
<p>Ext文件系统采用的是预先规划出所有的inode&#x2F;block&#x2F;metadata等数据，这些数据未来系统可以直接使用。xfs则是根据需要动态分配inode和block数据。当磁盘容量达到TB以上等级时，传统ext家族在文件系统格式化时预先规划inode和block就需要消耗好多的时间。</p>
<p>xfs文件系统的组成：</p>
<ol>
<li>数据区：这个区域和ext文件系统的block群组一样，只不过inode和block是动态产生的，并非是一开始格式化就分配好的</li>
<li>文件系统活动登录区：日志区。文件的变化会记录到这里。当变化完整的写入数据区后，该笔记录才会被终结。</li>
<li>实时运行区：当有文件要被创建时，xfs会在这个区段里面找一个到数个extent区块，将文件放置在这个区块中，等到动态分配完毕后，再写入到数据区的inode和block中。这个extent区块的大小要在格式化的时候就指定，最小值4k最大可到1G。建议不要乱动，具有磁盘阵列stripe的情况下，则建议extent设置为与stripe一样大比较好。</li>
</ol>
<p>查看xfs文件系统信息：</p>
<pre><code>[root@study ~]# xfs_info 挂载点|设备文件名

范例一：找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录
[root@study ~]# df -T /boot
Filesystem Type 1K-blocks Used Available Use% Mounted on
/dev/vda2 xfs 1038336 133704 904632 13% /boot

# 没错！可以看得出来是 xfs 文件系统的！来观察一下内容吧！
[root@study ~]# xfs_info /dev/vda2
1 meta-data=/dev/vda2 isize=256 agcount=4, agsize=65536 blks
2 = sectsz=512 attr=2, projid32bit=1
3 = crc=0 finobt=0
4 data = bsize=4096 blocks=262144, imaxpct=25
5 = sunit=0 swidth=0 blks
6 naming =version 2 bsize=4096 ascii-ci=0 ftype=0
7 log =internal bsize=4096 blocks=2560, version=2
8 = sectsz=512 sunit=0 blks, lazy-count=1
9 realtime =none extsz=4096 blocks=0, rtextents=0

第 1 行里面的 isize 指的是 inode 的容量，每个有 256Bytes 这么大。至于 agcount 则是前面谈到的储存区群组 （allocation group） 的个数，共有 4 个， agsize 则是指每个储存区群组具有 65536 个 block 。配合第 4 行的 block 设置为 4K，因此整个文件系统的容量应该就是 4655364K 这么大！
第 2 行里面 sectsz 指的是逻辑扇区 （sector） 的容量设置为 512Bytes 这么大的意思。
第 4 行里面的 bsize 指的是 block 的容量，每个 block 为 4K 的意思，共有 262144 个block 在这个文件系统内。
第 5 行里面的 sunit 与 swidth 与磁盘阵列的 stripe 相关性较高。这部份我们下面格式化的时候会举一个例子来说明。
第 7 行里面的 internal 指的是这个登录区的位置在文件系统内，而不是外部设备的意思。且占用了 4K * 2560 个 block，总共约 10M 的容量。
第 9 行里面的 realtime 区域，里面的 extent 容量为 4K。不过目前没有使用。
</code></pre>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="分区命令"><a href="#分区命令" class="headerlink" title="分区命令"></a>分区命令</h3><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区！parted &#x2F;dev&#x2F;xxx print可以找出内部的分区表类型，之后再用 gdisk 或 fdisk 来操作系统。</p>
<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk -l [&#x2F;dev&#x2F;to&#x2F;some_device_file] ：查看当前系统识别了几块硬盘  </p>
<pre><code>[root@localhost dev]# fdisk -l

Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors （硬盘）
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0001d65a

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux（分区）
/dev/sda2         2099200    41943039    19921920   8e  Linux LVM（分区）

Disk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectors （硬盘）
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors （硬盘）
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</code></pre>
<p>fdisk &#x2F;dev&#x2F;sda  </p>
<pre><code>p: 显示当前硬件的分区，包括没保存的改动
n: 创建新分区
    e: 扩展分区（创建扩展分区，将所有空间分配给它）
    p: 主分区
d: 删除一个分区
w: 保存退出
q: 不保存退出
t: 修改分区类型
L: （查看分区类型）
l: 显示所支持的所有类型

[root@localhost ~]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0xc8f76ed0.

Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xc8f76ed0

   Device Boot      Start         End      Blocks   Id  System

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1):   
First sector (2048-41943039, default 2048): 
Using default value 2048
Last sector, +sectors or +size&#123;K,M,G&#125; (2048-41943039, default 41943039): +1G
Partition 1 of type Linux and of size 1 GiB is set

... //再建立两个主分区

Command (m for help): n
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): e
Selected partition 4
First sector (6293504-41943039, default 6293504): 
Using default value 6293504
Last sector, +sectors or +size&#123;K,M,G&#125; (6293504-41943039, default 41943039): 
Using default value 41943039
Partition 4 of type Extended and of size 17 GiB is set

Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xc8f76ed0

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     2099199     1048576   83  Linux
/dev/sdb2         2099200     4196351     1048576   83  Linux
/dev/sdb3         4196352     6293503     1048576   83  Linux
/dev/sdb4         6293504    41943039    17824768    5  Extended

Command (m for help): n
All primary partitions are in use
Adding logical partition 5
First sector (6295552-41943039, default 6295552):  
Using default value 6295552
Last sector, +sectors or +size&#123;K,M,G&#125; (6295552-41943039, default 41943039): +1G
Partition 5 of type Linux and of size 1 GiB is set

Command (m for help): p

Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0xc8f76ed0

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     2099199     1048576   83  Linux
/dev/sdb2         2099200     4196351     1048576   83  Linux
/dev/sdb3         4196352     6293503     1048576   83  Linux
/dev/sdb4         6293504    41943039    17824768    5  Extended
/dev/sdb5         6295552     8392703     1048576   83  Linux
</code></pre>
<p>cat &#x2F;proc&#x2F;partitions ：查看系统有哪些分区<br>partprobe [&#x2F;dev&#x2F;sda]：重新加载设备分区</p>
<h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><pre><code>[root@study ~]# gdisk 设备名称

范例：由前一小节的 lsblk 输出，我们知道系统有个 /dev/vda，请观察该磁盘的分区与相关数据
[root@study ~]# gdisk /dev/vda  #仔细看，不要加上数字喔！
GPT fdisk （gdisk） version 0.8.6
Partition table scan:
MBR: protective
BSD: not present
APM: not present
GPT: present
Found valid GPT with protective MBR; using GPT. &amp;lt;==找到了 GPT 的分区表！

Command （? for help）: #这里可以让你输入指令动作，可以按问号 （?） 来查看可用指令
Command （? for help）: ?
b back up GPT data to a file
c change a partition&#39;s name
d delete a partition 	# 删除一个分区
i show detailed information on a partition
l list known partition types
n add a new partition 	# 增加一个分区
o create a new empty GUID partition table （GPT）
p print the partition table	 # 印出分区表 （常用）
q quit without saving changes  	# 不储存分区就直接离开 gdisk
r recovery and transformation options （experts only）
s sort partitions
t change a partition&#39;s type code
v verify disk
w write table to disk and exit  # 储存分区操作后离开 gdisk
x extra functionality （experts only）
? print this menu
Command （? for help）:
</code></pre>
<h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>查看当前内核所支持文件系统类型：</p>
<pre><code>cat /proc/filesystems  
</code></pre>
<h4 id="ext系列文件系统"><a href="#ext系列文件系统" class="headerlink" title="ext系列文件系统"></a>ext系列文件系统</h4><p>专门管理ext系列文件：<br>mkdfs.ext4<br>mke2fs  </p>
<pre><code>-j: 创建ext3类型文件系统
-b BLOCK_SIZE: 指定块大小，默认为4096；可用取值为1024、2048或4096；
-L LABEL：指定分区卷标；
-m #: 指定预留给超级用户的块数百分比
-i #: 用于指定用多少字节的空间创建一个inode，默认为8192；这里给出的数值应该为块大小的2^n倍；
-N #: 指定inode个数；
-F: 强制创建文件系统；
-E: 用户指定额外文件系统属性; 

[root@localhost ~]# mkfs -t ext2 /dev/sdb1
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: （超级块备份存储的块地址）
    32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done
</code></pre>
<h4 id="xfs文件系统-1"><a href="#xfs文件系统-1" class="headerlink" title="xfs文件系统"></a>xfs文件系统</h4><pre><code>[root@study ~]# mkfs.xfs [-b bsize] [-d parms] [-i parms] [-l parms] [-L label] [-f] \
[-r parms] 设备名称

选项与参数：

关于单位：下面只要谈到“数值”时，没有加单位则为 Bytes 值，可以用 k,m,g,t,p （小写）等来解释
比较特殊的是 s 这个单位，它指的是 sector 的“个数”喔！

-b ：后面接的是 block 容量，可由 512 到 64k，不过最大容量限制为 Linux 的 4k 喔！
-d ：后面接的是重要的 data section 的相关参数值，主要的值有：

    agcount=数值 ：设置需要几个储存群组的意思（AG），通常与 CPU 有关
    agsize=数值 ：每个 AG 设置为多少容量的意思，通常 agcount/agsize 只选一个设置即可
    file ：指的是“格式化的设备是个文件而不是个设备”的意思！（例如虚拟磁盘）
    size=数值 ：data section 的容量，亦即你可以不将全部的设备容量用完的意思
    su=数值 ：当有 RAID 时，那个 stripe 数值的意思，与下面的 sw 搭配使用
    sw=数值 ：当有 RAID 时，用于储存数据的磁盘数量（须扣除备份碟与备用碟）
    sunit=数值 ：与 su 相当，不过单位使用的是“几个 sector（512Bytes大小）”的意思
    swidth=数值 ：就是 su*sw 的数值，但是以“几个 sector（512Bytes大小）”来设置

-f ：如果设备内已经有文件系统，则需要使用这个 -f 来强制格式化才行！
-i ：与 inode 有较相关的设置，主要的设置值有：

    size=数值 ：最小是 256Bytes 最大是 2k，一般保留 256 就足够使用了！
    internal=[0&amp;#124;1]：log 设备是否为内置？默认为 1 内置，如果要用外部设备，使用下面设置
    logdev=device ：log 存储为后面接的那个设备上头的意思，需设置 internal=0 才可！
    size=数值 ：指定这块登录区的容量，通常最小得要有 512 个 block，大约 2M 以上才行！

-L ：后面接这个文件系统的标头名称 Label name 的意思！
-r ：指定 realtime section 的相关设置值，常见的有：

    extsize=数值 ：就是那个重要的 extent 数值，一般不须设置，但有 RAID 时，
    最好设置与 swidth 的数值相同较佳！最小为 4K 最大为 1G 。
    范例：将前一小节分区出来的 /dev/vda4 格式化为 xfs 文件系统

[root@study ~]# mkfs.xfs /dev/vda4
meta-data=/dev/vda4 isize=256 agcount=4, agsize=65536 blks
= sectsz=512 attr=2, projid32bit=1
= crc=0 finobt=0
data = bsize=4096 blocks=262144, imaxpct=25
= sunit=0 swidth=0 blks
naming =version 2 bsize=4096 ascii-ci=0 ftype=0
log =internal log bsize=4096 blocks=2560, version=2
= sectsz=512 sunit=0 blks, lazy-count=1
realtime =none extsz=4096 blocks=0, rtextents=0
# 很快格是化完毕！都用默认值！较重要的是 inode 与 block 的数值

[root@study ~]# blkid /dev/vda4
/dev/vda4: UUID=&quot;39293f4f-627b-4dfd-a015-08340537709c&quot; TYPE=&quot;xfs&quot;
# 确定创建好 xfs 文件系统了！
</code></pre>
<p>XFS文件系统for RAID性能优化</p>
<p>磁盘阵列 （RAID） 就是通过将文件先细分为数个小型的分区区块 （stripe） 之后，然后将众多的 stripes 分别放到磁盘阵列里面的所有磁盘， 所以一个文件是被同时写入到多个磁盘去，当然性能会好一些。为了文件的保全性，所以在这些磁盘里面，会保留数个（与磁盘阵列的规划有关） 备份磁盘 （parity disk）， 以及可能会保留一个以上的备用磁盘（spare disk）。</p>
<p>文件系统的读写要能够有最优化，最好能够搭配磁盘阵列的参数来设计，这样性能才能够起来！也就是说，你可以先在文件系统就将 stripe 规划好， 那交给 RAID 去存取时，它就无须重复进行文件的 stripe 过程，性能当然会更好！那格式化时，最优化性能与什么咚咚有关呢？我们来假设个环境好了：</p>
<blockquote>
<p>我有两个线程的 CPU 数量，所以 agcount 最好指定为 2</p>
<p>当初设置 RAID 的 stripe 指定为 256K 这么大，因此 su 最好设置为 256k</p>
<p>设置的磁盘阵列有 8 颗，因为是 RAID5 的设置，所以有一个 parity （备份碟），因此指定 sw 为 7</p>
<p>由上述的数据中，我们可以发现数据宽度 （swidth） 应该就是 256K*7 得到 1792K，以指定 extsize 为 1792k</p>
</blockquote>
<blockquote>
<p>重新创建文件系统会损坏原有文件  </p>
</blockquote>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>mkfs: make file system  </p>
<pre><code>-t FSTYPE 文件系统类型
    
mkfs -t ext2 = mkfs.ext2
mkfs -t ext3 = mkfs.ext3
</code></pre>
<p>parted：创建文件系统，ext和xfs都可以</p>
<pre><code>parted [设备] [指令 [参数]]

新增分区：mkpart [primary|logical|extended] [ext4|vfat|xfs] 开始 结束
显示分区：print
删除分区：rm [partition]

范例一：以 parted 列出目前本机的分区表数据
[root@study ~]# parted /dev/vda print
Model: Virtio Block Device （virtblk） &amp;lt;==磁盘接口与型号
Disk /dev/vda: 42.9GB &amp;lt;==磁盘文件名与容量
Sector size （logical/physical）: 512B/512B &amp;lt;==每个扇区的大小
Partition Table: gpt &amp;lt;==是 GPT 还是 MBR 分区
Disk Flags: pmbr_boot
Number Start End Size File system Name Flags
1 1049kB 3146kB 2097kB bios_grub
2 3146kB 1077MB 1074MB xfs
3 1077MB 33.3GB 32.2GB lvm
4 33.3GB 34.4GB 1074MB xfs Linux filesystem
5 34.4GB 35.4GB 1074MB ext4 Microsoft basic data
6 35.4GB 36.0GB 537MB linux-swap（v1） Linux swap
[ 1 ] [ 2 ] [ 3 ] [ 4 ] [ 5 ] [ 6 ]
</code></pre>
<h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><blockquote>
<p>修复文件系统时不能被挂载</p>
</blockquote>
<h4 id="xfs-repair"><a href="#xfs-repair" class="headerlink" title="xfs_repair"></a>xfs_repair</h4><p>检查并修复 XFS 文件系统</p>
<pre><code>[root@study ~]# xfs_repair [-fnd] 设备名称

选项与参数：
-f ：后面的设备其实是个文件而不是实体设备
-n ：单纯检查并不修改文件系统的任何数据 （检查而已）
-d ：通常用在单人维护模式下面，针对根目录 （/） 进行检查与修复的动作！很危险！不要随便使用

范例：检查一下刚刚创建的 /dev/vda4 文件系统
[root@study ~]# xfs_repair /dev/vda4
Phase 1 - find and verify superblock...
Phase 2 - using internal log
Phase 3 - for each AG...
Phase 4 - check for duplicate blocks...
Phase 5 - rebuild AG headers and trees...
Phase 6 - check inode connectivity...
Phase 7 - verify and correct link counts...
done
# 共有 7 个重要的检查流程！详细的流程介绍可以 man xfs_repair 即可！
</code></pre>
<h4 id="其它文件系统自检"><a href="#其它文件系统自检" class="headerlink" title="其它文件系统自检"></a>其它文件系统自检</h4><p>fsck: 检查并修复Linux文件系统</p>
<pre><code>-t FSTYPE: 指定文件系统类型
-a: 自动修复
</code></pre>
<p>e2fsck: 专用于修复ext2&#x2F;ext3文件系统</p>
<pre><code>-f: 强制检查；
-p: 自动修复；

[root@localhost ~]# e2fsck /dev/sdb1
e2fsck 1.42.9 (28-Dec-2013)
filesystem: clean, 11/65536 files, 4443/262144 blocks
</code></pre>
<h3 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h3><p>blkid: 查询或查看磁盘设备的相关属性 UUID、TYPE（文件系统）、LABEL</p>
<pre><code>[root@localhost ~]# blkid
/dev/sda1: UUID=&quot;63389af9-2128-4b68-b072-0b3d7aaca50d&quot; TYPE=&quot;xfs&quot; 
/dev/sda2: UUID=&quot;UN0Ex0-C5Bz-oeCn-RbEP-RR1a-x79t-Ikyjh3&quot; TYPE=&quot;LVM2_member&quot; 
/dev/sdb1: UUID=&quot;224f048a-76cf-4320-89b8-4458d6b96def&quot; TYPE=&quot;ext2&quot; 
/dev/sr0: UUID=&quot;2019-09-11-18-50-31-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot; 
/dev/mapper/centos-root: UUID=&quot;827a53b1-31be-4ab8-b5a2-3310ee209a81&quot; TYPE=&quot;xfs&quot; 
/dev/mapper/centos-swap: UUID=&quot;f03a485d-b51a-4f0a-ad29-1262c359686f&quot; TYPE=&quot;swap&quot; 
</code></pre>
<p>e2label: 用于查看或定义卷标（应该只能查看ext格式的文件系统）</p>
<pre><code>e2label 设备文件 卷标: 设定卷标

[root@localhost ~]# e2label /dev/sdb1 filesystem
[root@localhost ~]# e2label /dev/sdb1
filesystem
</code></pre>
<p>tune2fs: 调整文件系统的相关属性</p>
<pre><code>-j: 不损害原有数据，将ext2升级为ext3；不能反方向执行
-L LABEL: 设定或修改卷标; 
-m #: 调整预留百分比；（预留给超级用户）
-r #: 指定预留块数；（预留给超级用户）
-o: 设定默认挂载选项；
    acl 开启文件系统acl选项
-c #：指定挂载次数达到#次之后进行自检，0或-1表关闭此功能；
-i #: 每挂载使用多少天后进行自检；0或-1表示关闭此功能；
-l: 显示超级块中的信息；

[root@localhost ~]# tune2fs -l /dev/sdb1
tune2fs 1.42.9 (28-Dec-2013)
Filesystem volume name:   filesystem
Last mounted on:          &lt;not available&gt;
Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96def
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file
Filesystem flags:         signed_directory_hash 
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              65536
Block count:              262144
Reserved block count:     13107
Free blocks:              257701
Free inodes:              65525
First block:              0
Block size:               4096
Fragment size:            4096
Reserved GDT blocks:      63
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         8192
Inode blocks per group:   512
Filesystem created:       Sun Dec 26 07:12:40 2021
Last mount time:          n/a
Last write time:          Sun Dec 26 07:24:57 2021
Mount count:              0
Maximum mount count:      -1
Last checked:             Sun Dec 26 07:12:40 2021
Check interval:           0 (&lt;none&gt;)
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          256
Required extra isize:     28
Desired extra isize:      28
Default directory hash:   half_md4
Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4f
</code></pre>
<p>dumpe2fs: 显示文件系统属性信息</p>
<pre><code>-h: 只显示超级块中的信息

[root@localhost ~]# dumpe2fs /dev/sdb1
dumpe2fs 1.42.9 (28-Dec-2013)
Filesystem volume name:   filesystem
Last mounted on:          &lt;not available&gt;
Filesystem UUID:          224f048a-76cf-4320-89b8-4458d6b96def
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file
Filesystem flags:         signed_directory_hash 
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              65536
Block count:              262144
Reserved block count:     13107
Free blocks:              257701
Free inodes:              65525
First block:              0
Block size:               4096
Fragment size:            4096
Reserved GDT blocks:      63
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         8192
Inode blocks per group:   512
Filesystem created:       Sun Dec 26 07:12:40 2021
Last mount time:          n/a
Last write time:          Sun Dec 26 07:24:57 2021
Mount count:              0
Maximum mount count:      -1
Last checked:             Sun Dec 26 07:12:40 2021
Check interval:           0 (&lt;none&gt;)
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          256
Required extra isize:     28
Desired extra isize:      28
Default directory hash:   half_md4
Directory Hash Seed:      da85b069-0596-4e87-bb2e-4b265a4c5a4f


Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-64
  Block bitmap at 65 (+65), Inode bitmap at 66 (+66)
  Inode table at 67-578 (+67)
  32183 free blocks, 8181 free inodes, 2 directories
  Free blocks: 585-32767
  Free inodes: 12-8192
Group 1: (Blocks 32768-65535)
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-32832
  Block bitmap at 32833 (+65), Inode bitmap at 32834 (+66)
  Inode table at 32835-33346 (+67)
  32189 free blocks, 8192 free inodes, 0 directories
  Free blocks: 33347-65535
  Free inodes: 8193-16384
</code></pre>
<p>xfs_admin:修改xfs文件系统：</p>
<pre><code>[root@study ~]# xfs_admin [-lu] [-L label] [-U uuid] 设备文件名

选项与参数：
-l ：列出这个设备的 label name
-u ：列出这个设备的 UUID
-L ：设置这个设备的 Label name
-U ：设置这个设备的 UUID 喔！

范例：设置 /dev/vda4 的 label name 为 vbird_xfs，并测试挂载
[root@study ~]# xfs_admin -L vbird_xfs /dev/vda4
writing all SBs
new label = &quot;vbird_xfs&quot; # 产生新的 LABEL 名称啰！

[root@study ~]# xfs_admin -l /dev/vda4
label = &quot;vbird_xfs&quot;
[root@study ~]# mount LABEL=vbird_xfs /data/xfs/

范例：利用 uuidgen 产生新 UUID 来设置 /dev/vda4，并测试挂载
[root@study ~]# umount /dev/vda4 # 使用前，请先卸载！

[root@study ~]# uuidgen
e0fa7252-b374-4a06-987a-3cb14f415488 # 很有趣的指令！可以产生新的 UUID 喔！
[root@study ~]# xfs_admin -u /dev/vda4
UUID = e0a6af55-26e7-4cb7-a515-826a8bd29e90

[root@study ~]# xfs_admin -U e0fa7252-b374-4a06-987a-3cb14f415488 /dev/vda4
Clearing log and setting UUID
writing all SBs
new UUID = e0fa7252-b374-4a06-987a-3cb14f415488
[root@study ~]# mount UUID=e0fa7252-b374-4a06-987a-3cb14f415488 /data/x
</code></pre>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载：将新的文件系统关联至当前根文件系统，挂载完成后，要通过挂载点访问对应文件系统上的文件；</p>
<p>卸载：将某文件系统与当前根文件系统的关联关系预以移除；</p>
<p>mount：挂载</p>
<pre><code>mount 设备 挂载点
    设备：
        设备文件：/dev/sda5
        卷标：LABEL=“”
        UUID： UUID=“”
    挂载点：目录
        要求：
            1、此目录没有被其它进程使用；
            2、目录得事先存在；
            3、目录中的原有的文件将会暂时隐藏；

mount [options] [-o options] DEVICE MOUNT_POINT
    -a: 表示挂载/etc/fstab文件中定义的所有文件系统
    -n: 默认情况下，mount命令每挂载一个设备，都会把挂载的设备信息保存至/etc/mtab文件；使用—n选项意味着挂载设备时，不把信息写入此文件；
    -t FSTYPE: 指定正在挂载设备上的文件系统的类型；不使用此选项时，mount会调用blkid命令获取对应文件系统的类型；
    -r: 只读挂载，挂载光盘时常用此选项
    -w: 读写挂载
    
    -o: 指定额外的挂载选项，也即指定文件系统启用的属性；
        remount: 重新挂载当前文件系统
        ro: 挂载为只读
        rw: 读写挂载
</code></pre>
<p>umount: 卸载某文件系统</p>
<pre><code>umount 设备
umount 挂载点	

卸载注意事项：
    挂载的设备没有进程使用；
</code></pre>
<p>mount -o loop 文件地址 MOUNT_POINT: 挂载本地回环设备（比如iso文件）</p>
<p>文件系统的配置文件&#x2F;etc&#x2F;fstab  </p>
<pre><code>OS在初始时，会自动挂载此文件中定义的每个文件系统

要挂载的设备	挂载点		文件系统类型		挂载选项（文件系统选项）		转储频率(每多少天做一次完全备份)		文件系统检测次序(只有根可以为1)		
/dev/sda5		/mnt/test		ext3		defaults		0 0

文件系统参数：
async/sync 非同步/同步
        设置磁盘是否以非同步方式运行！默认为 async（性能较佳）

auto/noauto 自动/非自动
    当下达 mount -a 时，此文件系统是否会被主动测试挂载。默认为 auto。

rw/ro 可读写/只读
    让该分区以可读写或者是只读的型态挂载上来，如果你想要分享的数据是不给使用者随意变更的， 这里也能够设置为只读。则不论在此文件系统的文件是否设置 w 权限，都无法写入喔！

exec/noexec可执行/不可执行
    限制在此文件系统内是否可以进行“执行”的工作？如果是纯粹用来储存数据的目录, 那么可以设置为 noexec 会比较安全。不过，这个参数也不能随便使用，因为你不知道该目录下是否默认会有可执行文件。举例来说，如果你将 noexec 设置在 /var ，当某些软件将一些可执行文件放置于 /var 下时，那就会产生很大的问题喔！ 因此，建议这个 noexec 最多仅设置于你自订或分享的一般数据目录。

user/nouser允许/不允许
    使用者挂载是否允许使用者使用 mount指令来挂载呢？一般而言，我们当然不希望一般身份的 user 能使用 mount 啰，因为太不安全了，因此这里应该要设置为 nouser 啰！

suid/nosuid具有/不具有suid 权限
    该文件系统是否允许 SUID 的存在？如果不是可执行文件放置目录，也可以设置为 nosuid 来取消这个功能！

defaults 同时具有 rw, suid, dev, exec, auto, nouser, async 等参数。
默认情况使用 defaults 设置即可！
</code></pre>
<p>mount -a：挂载&#x2F;etc&#x2F;fstab文件中定义的所有文件系统  </p>
<p>fuser: 验正进程正在使用的文件或套接字文件  </p>
<pre><code>-v: 查看某文件上正在运行的进程
-k: 杀死访问进程的文件
-m: 指定MOUNT_POINT

fuser -km MOUNT_POINT：终止正在访问此挂载点的所有进程
</code></pre>
<h3 id="swap分区"><a href="#swap分区" class="headerlink" title="swap分区"></a>swap分区</h3><p>Swap（交换分区）：把不常访问的内存先写到磁盘中，然后释放这些内存，给其它更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存。</p>
<p>free :查看内存容量  </p>
<pre><code>-m ：以M为单位显示
-g ：以g为单位显示
-h ：单位换算
[demo@localhost ~]$ free -h
              total        used        free      shared  buff/cache   available
Mem:           972M        625M        122M         16M        225M        191M
Swap:          2.0G         51M        1.9G

free是真正尚未被使用的物理内存数量。avaliable是从应用程序的角度看到的可用内存数量。Linux内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的buffer和cache。所以对于内核来说，buffer和cache都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的free内存可以用，内核就会从buffer和cache中回收内存来满足应用程序的请求。
</code></pre>
<h4 id="创建swap实体分区"><a href="#创建swap实体分区" class="headerlink" title="创建swap实体分区"></a>创建swap实体分区</h4><ol>
<li><p>在硬盘中创建Swap分区</p>
</li>
<li><p>调整Swap分区类型为82</p>
<pre><code>fdisk 调整分区类型为 82
gdisk 调整为8200
</code></pre>
</li>
<li><p>开始创建Swap格式</p>
<pre><code> mkswap /dev/sda8  创建交换分区：  
    -L LABEL

 [root@localhost ~]# free
          total        used        free      shared  buff/cache   available
Mem:         995748      648288       73440       17184      274020      187264
Swap:       2097148       51976     2045172
</code></pre>
</li>
<li><p>开启Swap分区</p>
<pre><code> swapon /dev/sda8  开启交换分区

 -a: 启用所有的定义在/etc/fstab文件中的交换设备
 -s: 查看交换分区由哪些文件或者分区组成

 [root@localhost ~]# swapon /dev/sdb5

 [root@localhost ~]# free -h
 total        used        free      shared  buff/cache   available
 Mem:           972M        633M         71M         16M        267M        182M
 Swap:          3.0G         50M        3.0G

 [root@localhost var]# swapon -s
 Filename				Type		 Size	 Used	Priority
 /dev/dm-1              partition	   2097148 	30652   	-2
 /var/swapfile           file	   1048572	   0      	-3
</code></pre>
</li>
</ol>
<p>swapoff &#x2F;dev&#x2F;sda8 关闭交换分区  </p>
<h4 id="创建swap文件分区"><a href="#创建swap文件分区" class="headerlink" title="创建swap文件分区"></a>创建swap文件分区</h4><p>如何在一个分区中创建一个文件，并把它添加到swap交换分区中  </p>
<blockquote>
<p>回环设备loopback, 使用软件来模拟实现硬件</p>
</blockquote>
<p>dd ： 读取、转换并输出数据</p>
<pre><code>if=数据来源
of=数据存储目标
bs=1 读取或输出的块大小
count=2 拷贝多少个块
seek=#: 创建数据文件时，创建文件跳过的空间大小

dd if=/dev/sda of=/mnt/usb/mbr.backup bs=512 count=1
dd if=/mnt/usb/mbr.backup of=/dev/sda bs=512 count=1
</code></pre>
<p>首先，创建一个镜像文件：&#x2F;dev&#x2F;zero 读出的都是0</p>
<pre><code>dd if=/dev/zero of=/var/swapfile bs=1M count=1024 
</code></pre>
<p>其次，将文件创建为swap分区</p>
<pre><code>[root@localhost var]# mkswap /var/swapfile 
Setting up swapspace version 1, size = 1048572 KiB
no label, UUID=86213827-3a91-4171-9892-e9c8efd42e2b
</code></pre>
<p>最后，开启swap分区文件</p>
<pre><code>[root@localhost var]# swapon /var/swapfile
swapon: /var/swapfile: insecure permissions 0644, 0600 suggested.
[root@localhost var]# free -h
              total        used        free      shared  buff/cache   available
Mem:           972M        631M         67M         16M        274M        182M
Swap:          3.0G         50M        3.0G
</code></pre>
<h3 id="xfs文件备份与还原"><a href="#xfs文件备份与还原" class="headerlink" title="xfs文件备份与还原"></a>xfs文件备份与还原</h3><h4 id="xfsdump备份"><a href="#xfsdump备份" class="headerlink" title="xfsdump备份"></a>xfsdump备份</h4><p>xfsdumcp是xfs文件系统备份工具，可以进行完整备份和增量备份。同时xfsdumcp是通过文件系统的UUID来分辨各个备份文件的，因此不能备份两个具有相同UUID的文件系统。</p>
<pre><code>[root@study ~]# xfsdump [-L S_label] [-M M_label] [-l #] [-f 备份文件] 待备份数据

选项与参数：
-L ：xfsdump 会纪录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明
-M ：xfsdump 可以纪录储存媒体的标头，这里可以填写此媒体的简易说明
-l ：是 L 的小写，就是指定等级～有 0~9 共 10 个等级喔！ （默认为 0，即完整备份）
-f ：有点类似 tar 啦！后面接产生的文件，亦可接例如 /dev/st0 设备文件名或其他一般文件文件名等
-I ：从 /var/lib/xfsdump/inventory 列出目前备份的信息状态
</code></pre>
<p>完整备份</p>
<pre><code># 1\. 先确定 /boot 是独立的文件系统喔！
[root@study ~]# df -h /boot
Filesystem Size Used Avail Use% Mounted on
/dev/vda2 1014M 131M 884M 13% /boot # 挂载 /boot 的是 /dev/vda 设备！
# 看！确实是独立的文件系统喔！ /boot 是挂载点！

# 2\. 将完整备份的文件名记录成为 /srv/boot.dump ：
[root@study ~]# xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot
xfsdump: using file dump （drive_simple） strategy
xfsdump: version 3.1.4 （dump format 3.0） - type ^C for status and control
xfsdump: level 0 dump of study.centos.vbird:/boot # 开始备份本机/boot系统
xfsdump: dump date: Wed Jul 1 18:43:04 2015 # 备份的时间
xfsdump: session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1 # 这次dump的ID
xfsdump: session label: &quot;boot_all&quot; # 简单给予一个名字记忆
xfsdump: ino map phase 1: constructing initial dump list # 开始备份程序
xfsdump: ino map phase 2: skipping （no pruning necessary）
xfsdump: ino map phase 3: skipping （only one dump stream）
xfsdump: ino map construction complete
xfsdump: estimated dump size: 103188992 Bytes
xfsdump: creating dump session media file 0 （media 0, file 0）
xfsdump: dumping ino map
xfsdump: dumping directories
xfsdump: dumping non-directory files
xfsdump: ending media file
xfsdump: media file size 102872168 Bytes
xfsdump: dump size （non-dir files） : 102637296 Bytes
xfsdump: dump complete: 1 seconds elapsed
xfsdump: Dump Summary:
xfsdump: stream 0 /srv/boot.dump OK （success）
xfsdump: Dump Status: SUCCESS
# 在指令的下达方面，你也可以不加 -L 及 -M 的，只是那就会进入互动模式，要求你 enter！

# 而执行 xfsdump 的过程中会出现如上的一些讯息，您可以自行仔细的观察！
[root@study ~]# ll /srv/boot.dump
-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump

[root@study ~]# ll /var/lib/xfsdump/inventory
-rw-r--r--. 1 root root 5080 Jul 1 18:43 506425d2-396a-433d-9968-9b200db0c17c.StObj
-rw-r--r--. 1 root root 312 Jul 1 18:43 94ac5f77-cb8a-495e-a65b-2ef7442b837c.InvIndex
-rw-r--r--. 1 root root 576 Jul 1 18:43 fstab
# 使用了 xfsdump 之后才会有上述 /var/lib/xfsdump/inventory 内的文件产生喔！
</code></pre>
<p>累积备份</p>
<pre><code># 0\. 看一下有没有任何文件系统被 xfsdump 过的数据？
[root@study ~]# xfsdump -I
file system 0:
fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837c
session 0:
mount point: study.centos.vbird:/boot
device: study.centos.vbird:/dev/vda2
time: Wed Jul 1 18:43:04 2015
session label: &quot;boot_all&quot;
session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1
level: 0
resumed: NO
subtree: NO
streams: 1
stream 0:
pathname: /srv/boot.dump
start: ino 132 offset 0
end: ino 2138243 offset 0
interrupted: NO
media files: 1
media file 0:
mfile index: 0
mfile type: data
mfile size: 102872168
mfile start: ino 132 offset 0
mfile end: ino 2138243 offset 0
media label: &quot;boot_all&quot;
media id: a6168ea6-1ca8-44c1-8d88-95c863202eab
xfsdump: Dump Status: SUCCESS

# 我们可以看到目前仅有一个 session 0 的备份数据而已！而且是 level 0 喔！

# 1\. 先恶搞一下，创建一个大约 10 MB 的文件在 /boot 内：
[root@study ~]# dd if=/dev/zero of=/boot/testing.img bs=1M count=10
10+0 records in
10+0 records out
10485760 Bytes （10 MB） copied, 0.166128 seconds, 63.1 MB/s

# 2\. 开始创建差异备份文件，此时我们使用 level 1 吧：
[root@study ~]# xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot
....（中间省略）....
[root@study ~]# ll /srv/boot*
-rw-r--r--. 1 root root 102872168 Jul 1 18:43 /srv/boot.dump
-rw-r--r--. 1 root root 10510952 Jul 1 18:46 /srv/boot.dump1
# 看看文件大小，岂不是就是刚刚我们所创建的那个大文件的容量吗？ ^_^

# 3\. 最后再看一下是否有记录 level 1 备份的时间点呢？
[root@study ~]# xfsdump -I
file system 0:
fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837c
session 0:
mount point: study.centos.vbird:/boot
device: study.centos.vbird:/dev/vda2
....（中间省略）....
session 1:
mount point: study.centos.vbird:/boot
device: study.centos.vbird:/dev/vda2
time: Wed Jul 1 18:46:21 2015
session label: &quot;boot_2&quot;
session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8
level: 1
resumed: NO
subtree: NO
streams: 1
stream 0:
pathname: /srv/boot.dump1
start: ino 455518 offset 0
....（下面省略）....
</code></pre>
<h4 id="xfsrestore还原"><a href="#xfsrestore还原" class="headerlink" title="xfsrestore还原"></a>xfsrestore还原</h4><pre><code>[root@study ~]# xfsrestore -I &amp;lt;==用来察看备份文件数据
[root@study ~]# xfsrestore [-f 备份文件] [-L S_label] [-s] 待复原目录 &amp;lt;==单一文件全系统复原
[root@study ~]# xfsrestore [-f 备份文件] -r 待复原目录 &amp;lt;==通过累积备份文件来复原系统
[root@study ~]# xfsrestore [-f 备份文件] -i 待复原目录 &amp;lt;==进入互动模式

选项与参数：
-I ：跟 xfsdump 相同的输出！可查询备份数据，包括 Label 名称与备份时间等
-f ：后面接的就是备份文件！企业界很有可能会接 /dev/st0 等磁带机！我们这里接文件名！
-L ：就是 Session 的 Label name 喔！可用 -I 查询到的数据，在这个选项后输入！
-s ：需要接某特定目录，亦即仅复原某一个文件或目录之意！
-r ：如果是用文件来储存备份数据，那这个就不需要使用。如果是一个磁带内有多个文件，需要这东西来达成累积复原
-i ：进入互动模式，进阶管理员使用的！一般我们不太需要操作它！
</code></pre>
<p>用xfsrestore查看xfsdump备份数据</p>
<pre><code>[root@study ~]# xfsrestore -I
file system 0:
fs id: 94ac5f77-cb8a-495e-a65b-2ef7442b837c
session 0:
mount point: study.centos.vbird:/boot
device: study.centos.vbird:/dev/vda2
time: Wed Jul 1 18:43:04 2015
session label: &quot;boot_all&quot;
session id: 418b563f-26fa-4c9b-98b7-6f57ea0163b1
level: 0
pathname: /srv/boot.dump
mfile size: 102872168
media label: &quot;boot_all&quot;
session 1:
mount point: study.centos.vbird:/boot
device: study.centos.vbird:/dev/vda2
time: Wed Jul 1 18:46:21 2015
session label: &quot;boot_2&quot;
session id: c71d1d41-b3bb-48ee-bed6-d77c939c5ee8
level: 1
pathname: /srv/boot.dump1
mfile size: 10510952
media label: &quot;boot_2&quot;
xfsrestore: Restore Status: SUCCESS
</code></pre>
<p>完全备份还原</p>
<pre><code># 1\. 直接将数据给它还原回去即可！
[root@study ~]# xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot
xfsrestore: using file dump （drive_simple） strategy
xfsrestore: version 3.1.4 （dump format 3.0） - type ^C for status and control
xfsrestore: using online session inventory
xfsrestore: searching media for directory dump
xfsrestore: examining media file 0
xfsrestore: reading directories
xfsrestore: 8 directories and 327 entries processed
xfsrestore: directory post-processing
xfsrestore: restoring non-directory files
xfsrestore: restore complete: 1 seconds elapsed
xfsrestore: Restore Summary:
xfsrestore: stream 0 /srv/boot.dump OK （success） # 是否是正确的文件啊？
xfsrestore: Restore Status: SUCCESS

如果只想要复原某一个目录或文件的话，直接加上“ -s 目录 ”这个选项与参数即可！
</code></pre>
<p>部分备份还原</p>
<pre><code># 继续复原 level 1 到 /tmp/boot 当中！
[root@study ~]# xfsrestore -f /srv/boot.dump1 /tmp/boot
</code></pre>
<p>仅还原部分文件的 xfsrestore 互动模式</p>
<pre><code># 1\. 先进入备份文件内，准备找出需要备份的文件名数据，同时预计还原到 /tmp/boot3 当中！
[root@study ~]# mkdir /tmp/boot3
[root@study ~]# xfsrestore -f /srv/boot.dump -i /tmp/boot3
========================== subtree selection dialog ==========================
the following commands are available:
pwd
ls [ &amp;lt;path&amp;gt; ]
cd [ &amp;lt;path&amp;gt; ]
add [ &amp;lt;path&amp;gt; ] # 可以加入复原文件列表中
delete [ &amp;lt;path&amp;gt; ] # 从复原列表拿掉文件名！并非删除喔！
extract # 开始复原动作！
quit
help
-&amp;gt; ls
455517 initramfs-3.10.0-229.el7.x86_64kdump.img
138 initramfs-3.10.0-229.el7.x86_64.img
141 initrd-plymouth.img
140 vmlinuz-0-rescue-309eb890d09f440681f596543d95ec7a
139 initramfs-0-rescue-309eb890d09f440681f596543d95ec7a.img
137 vmlinuz-3.10.0-229.el7.x86_64
136 symvers-3.10.0-229.el7.x86_64.gz
135 config-3.10.0-229.el7.x86_64
134 System.map-3.10.0-229.el7.x86_64
133 .vmlinuz-3.10.0-229.el7.x86_64.hmac
1048704 grub2/
131 grub/
-&amp;gt; add grub
-&amp;gt; add grub2
-&amp;gt; add config-3.10.0-229.el7.x86_64
-&amp;gt; extract

[root@study ~]# ls -l /tmp/boot3
-rw-r--r--. 1 root root 123838 Mar 6 19:45 config-3.10.0-229.el7.x86_64
drwxr-xr-x. 2 root root 26 May 4 17:52 grub
drwxr-xr-x. 6 root root 104 Jun 25 00:02 grub2
# 就只会有 3 个文件名被复原，当然，如果文件名是目录，那下面的子文件当然也会被还原回来的！
</code></pre>
<h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>RAID中文名称为独立磁盘冗余阵列，简称为磁盘阵列。简单的说，RAID是由多个独立的高性能磁盘驱动器组成的磁盘子系统，从而提供比单个磁盘更高的存储性能和数据冗余的技术。RAID的主要优势有如下几点：大容量、高性能、可靠性、可管理性（它将多个物理磁盘驱动器虚拟成一个大容量的逻辑驱动器）。实现RAID的关键技术为镜像、数据条带、数据校验技术。RAID的每种级别仅代表磁盘组织方式不同，没有上下之分。  </p>
<p>一般来说， RAID 不可作为数据备份的替代方案，它对非磁盘故障等造成的数据丢失无能为力，比如病毒、人为破坏、意外删除等情形。此时的数据丢失是相对操作系统、文件系统、卷管理器或者应用系统来说的，对于 RAID 系统来身，数据都是完好的，没有发生丢失。所以，数据备份、灾 备等数据保护措施是非常必要的，与 RAID 相辅相成，保护数据在不同层次的安全性，防止发生数据丢失。</p>
<p>从实现角度看， RAID 主要分为软 RAID、硬 RAID 以及软硬混合 RAID 三种。软 RAID 所有功能均有操作系统和 CPU 来完成，没有独立的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片，效率自然最低。硬 RAID 配备了专门的 RAID 控制 &#x2F; 处理芯片和 I&#x2F;O 处理芯片以及阵列缓冲，不占用 CPU 资源，但成本很高。软硬混合 RAID 具备 RAID 控制 &#x2F; 处理芯片，但缺乏 I&#x2F;O 处理芯片，需要 CPU 和驱动程序来完成，性能和成本 在软 RAID 和硬 RAID 之间。不建议使用软RAID。</p>
<p>常见raid级别如下，具体可参见文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/ensp1/article/details/81318135">https://blog.csdn.net/ensp1/article/details/81318135</a>，以上关于raid内容也是摘取自这篇文章。</p>
<h4 id="raid-0"><a href="#raid-0" class="headerlink" title="raid 0"></a>raid 0</h4><p>raid 0基于条带化技术。将数据按照stripe大小切分之后存放到各磁盘中</p>
<p><img src="https://img-blog.csdnimg.cn/20200701102411750.png" alt="image"></p>
<pre><code>    性能提升: 读，写
    冗余能力（容错能力）: 无
    空间利用率：nS
    至少2块盘
</code></pre>
<h4 id="raid-1"><a href="#raid-1" class="headerlink" title="raid 1"></a>raid 1</h4><p>raid 1基于镜像技术。将数据复制为N份存放到各磁盘中。</p>
<p><img src="https://img-blog.csdnimg.cn/20200701102427735.png" alt="image"></p>
<pre><code>    性能表现：写性能下降，读性能提升
    冗余能力：有
    空间利用率：1/2
    至少2块盘
</code></pre>
<h4 id="raid-5"><a href="#raid-5" class="headerlink" title="raid 5"></a>raid 5</h4><p>raid 5采用的是条带化和校验技术。将数据按照stripe大小切分并且计算数据校验信息然后分别存放到各磁盘中。当一个磁盘损坏后可以根据其它磁盘数据进行恢复，而且该技术中校验信息不是存放到固定磁盘中的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200701102535811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Vuc3Ax,size_16,color_FFFFFF,t_70" alt="image"></p>
<pre><code>    性能表现：读，写提升
    冗余能力：有
    空间利用率：(n-1)/n
    至少需要3块
</code></pre>
<p>raid 5 并发问题<a target="_blank" rel="noopener" href="https://forum.huawei.com/enterprise/zh/thread/580916590801731584">https://forum.huawei.com/enterprise/zh/thread/580916590801731584</a></p>
<h4 id="raid10"><a href="#raid10" class="headerlink" title="raid10"></a>raid10</h4><p>raid 10 从下往上是先采用raid 1的镜像技术，再采用raid 0 的条带化技术。</p>
<p><img src="https://img-blog.csdnimg.cn/2020070110262565.png" alt="image"></p>
<pre><code>    性能表现：读、写提升
    冗余能力：有
    空间利用率：1/2
    至少需要4块
</code></pre>
<h4 id="raid-01"><a href="#raid-01" class="headerlink" title="raid 01"></a>raid 01</h4><p>raid 01 从下往上是先采用raid 0的条带化技术，再采用raid 1的镜像技术。<br><img src="https://img-blog.csdnimg.cn/20200701102612237.png" alt="image"></p>
<pre><code>    性能表现：读、写提升
    冗余能力：有
    空间利用率：1/2
    至少需要4块
</code></pre>
<h4 id="raid-50"><a href="#raid-50" class="headerlink" title="raid 50"></a>raid 50</h4><p>raid 50 从下往上是先采用raid 5技术，再采用raid 0 技术。<br><img src="https://img-blog.csdnimg.cn/20200701102710274.png" alt="image"></p>
<pre><code>    性能表现：读、写提升
    冗余能力：有
    空间利用率：(n-2)/n
    至少需要6块
</code></pre>
<h4 id="jbod"><a href="#jbod" class="headerlink" title="jbod"></a>jbod</h4><p>jbod并不是一个raid技术，它仅仅只是将几个磁盘组成一个大的存储设备。</p>
<p><img src="https://img-blog.csdnimg.cn/20200701102345894.png" alt="image"></p>
<pre><code>    性能表现：无提升
    冗余能力：无
    空间利用率：100%
    至少需要2块
</code></pre>
<h4 id="软件raid练习"><a href="#软件raid练习" class="headerlink" title="软件raid练习"></a>软件raid练习</h4><p>以下我们使用逻辑RAID作为练习，软件RAID在Linux中的设备名为&#x2F;dev&#x2F;md</p>
<p>mdadm：将任何块设备做成RAID </p>
<pre><code>模式化的命令：
    创建模型
        -C 
            专用选项：
                -l: 级别
                -n #: 设备个数（raid使用的磁盘数量）
                -a &#123;yes|no&#125;: 是否自动为其创建设备文件
                -c: CHUNK大小, 2^n，默认为64K
                -x #: 指定空闲盘个数
    管理模式
        --add, 
        --remove, 
        --fail
        mdadm /dev/md# --fail /dev/sda7
    监控模式
        -F：
    增长模式
        -G：
    装配模式
        -A:
</code></pre>
<p>查看RAID阵列的详细信息</p>
<pre><code>mdadm -D /dev/md#
    --detail
</code></pre>
<p>停止阵列：</p>
<pre><code>mdadm -S /dev/md#
    --stop
</code></pre>
<p>将当前RAID信息保存至配置文件，以便以后进行装配：</p>
<pre><code>mdamd -D --scan &gt; /etc/mdadm.conf
</code></pre>
<p>使用软raid操作如下：</p>
<pre><code>1. 在磁盘/dev/sdb上创建四个磁盘分区（6，7,8,9），每个分区的类型修改为fd

[root@localhost var]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): n
All primary partitions are in use
Adding logical partition 6
First sector (8394752-41943039, default 8394752): 
Using default value 8394752
Last sector, +sectors or +size&#123;K,M,G&#125; (8394752-41943039, default 41943039): +1G
Partition 6 of type Linux and of size 1 GiB is set

Command (m for help): t
Partition number (1-8, default 8): fd
Partition number (1-8, default 8): 6
Hex code (type L to list all codes): fd
Changed type of partition &#39;Linux&#39; to &#39;Linux raid autodetect&#39;

2. 使用mdadm命令创建raid

[root@localhost dev]# mdadm -C /dev/md0 -l 1 -n 2 -a yes -x 1 /dev/sdb&#123;6,7,8&#125;
mdadm: Note: this array has metadata at the start and
    may not be suitable as a boot device.  If you plan to
    store &#39;/boot&#39; on this device please ensure that
    your boot-loader understands md/v1.x metadata, or use
    --metadata=0.90   （软raid不能作为启动分区）
Continue creating array? 
Continue creating array? (y/n) y
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md0 started.

[root@localhost dev]# ll -d /dev/md*
brw-rw----. 1 root disk 9, 0 Jan  1 04:42 /dev/md0

3. 在raid上创建文件系统
[root@localhost dev]# mke2fs /dev/md0
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
65408 inodes, 261632 blocks
13081 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8176 inodes per group
Superblock backups stored on blocks: 
    32768, 98304, 163840, 229376

Allocating group tables: done                            
Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done

4. 挂载文件系统
[root@localhost dev]# mount /dev/md0 /mnt

5. 拷贝并查看文件
[root@localhost mnt]# cp /etc/inittab ./
[root@localhost mnt]# ll
total 20
-rw-r--r--. 1 root root   511 Jan  1 04:47 inittab
drwx------. 2 root root 16384 Jan  1 04:46 lost+found
[root@localhost mnt]# cat inittab 
# inittab is no longer used when using systemd.
#
# ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.
...

6. 查看raid信息
[root@localhost mnt]# mdadm -D /dev/md0
/dev/md0:
           Version : 1.2
     Creation Time : Sat Jan  1 04:42:17 2022
        Raid Level : raid1
        Array Size : 1046528 (1022.00 MiB 1071.64 MB)
     Used Dev Size : 1046528 (1022.00 MiB 1071.64 MB)
      Raid Devices : 2
     Total Devices : 3
       Persistence : Superblock is persistent

       Update Time : Sat Jan  1 04:47:39 2022
             State : clean 
    Active Devices : 2
   Working Devices : 3
    Failed Devices : 0
     Spare Devices : 1

Consistency Policy : resync

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72
            Events : 17

    Number   Major   Minor   RaidDevice State
       0       8       22        0      active sync   /dev/sdb6
       1       8       23        1      active sync   /dev/sdb7

       2       8       24        -      spare   /dev/sdb8
7. 查看raid状态
    cat /proc/mdstat


8. 将sdb6标识为损坏
[root@localhost mnt]# mdadm /dev/md0 --fail /dev/sdb6
mdadm: set /dev/sdb6 faulty in /dev/md0
[root@localhost mnt]# mdadm -D /dev/md0
/dev/md0:
                    ...
                    ...
    Number   Major   Minor   RaidDevice State
       2       8       24        0      active sync   /dev/sdb8
       1       8       23        1      active sync   /dev/sdb7

       0       8       22        -      faulty   /dev/sdb6

9. 在raid中移除sdb6
[root@localhost mnt]# mdadm /dev/md0 --remove /dev/sdb6
mdadm: hot removed /dev/sdb6 from /dev/md0
[root@localhost mnt]# mdadm -D /dev/md0
/dev/md0:
                        ...
                        ...
Consistency Policy : resync

              Name : localhost.localdomain:0  (local to host localhost.localdomain)
              UUID : c4835ed0:a9206ccf:21818f68:7e3c3a72
            Events : 37

    Number   Major   Minor   RaidDevice State
       2       8       24        0      active sync   /dev/sdb8
       1       8       23        1      active sync   /dev/sdb7
10. 查看文件
[root@localhost mnt]# cat inittab 
    # inittab is no longer used when using systemd.
    #
    # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.
    ...

  11. 在raid中添加磁盘
[root@localhost mnt]# mdadm /dev/md0 --add /dev/sdb9
mdadm: added /dev/sdb9
[root@localhost mnt]# mdadm -D /dev/md0
/dev/md0:
                            ...
                            ...
    Number   Major   Minor   RaidDevice State
       2       8       24        0      active sync   /dev/sdb8
       1       8       23        1      active sync   /dev/sdb7

       3       8       25        -      spare   /dev/sdb9

12. 停止raid
[root@localhost /]# umount /dev/md0
[root@localhost /]# mdadm -S /dev/md0
mdadm: stopped /dev/md0

13. 重新挂载停止的raid
[root@localhost /]# mdadm -A /dev/md0 /dev/sdb&#123;7,8,9&#125;
mdadm: /dev/md0 has been started with 2 drives and 1 spare.
[root@localhost /]# mdadm -D /dev/md0
/dev/md0:
                        ...
                    	...
    Number   Major   Minor   RaidDevice State
       2       8       24        0      active sync   /dev/sdb8
       1       8       23        1      active sync   /dev/sdb7

       3       8       25        -      spare   /dev/sdb9

 14. 查看文件
 [root@localhost mnt]# cat inittab 
 # inittab is no longer used when using systemd.
 #
 # ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.
                         ...
 15. 增长模式（将raid的热备磁盘增加到阵列工作磁盘中）
 mdadm -G /dev/md0 -n 4
</code></pre>
<p>watch: 周期性地执行指定命令，并以全屏方式显示结果  </p>
<pre><code>-n #：指定周期长度，单位为秒，默认为2
格式： watch -n # &#39;COMMAND&#39;
</code></pre>
<h2 id="LVM"><a href="#LVM" class="headerlink" title="LVM"></a>LVM</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>LVM是逻辑卷管理，它是Linux下磁盘分区的一种管理机制。该功能可以实现用户在无需停机的情况下可以调整各个分区的大小。</p>
<ul>
<li>PV(物理卷): 对应于我们的实体分区或硬盘</li>
<li>VG(卷  组): PV的组合</li>
<li>LV(逻辑卷): VG会被切成LV.这个LV就是最后格式化后给用户使用的。</li>
<li>PE(物理盘区): LVM管理的基础存储单元。LVM会把PV分成一个个PE进行存储。</li>
</ul>
<p>VG(卷组)的边界大小取决于PV(物理卷)组合的大小。</p>
<p>虽然PV组合成了VG，但是要真正使用就要划分LV(逻辑卷).在VG上可以划分多个LV，但这多个LV的大小加起来的和不能超过VG。如果发现VG不够用了，可以增加PV（物理卷），如果LV中空间不足可以扩大LV。</p>
<p>对卷创建快照，实际上就是对逻辑卷创建快照，而快照卷必须和逻辑卷处于同一个卷组中。也就意味这，如果你要打算对某个LV逻辑卷创建快照，就必须在同一个卷组中预留出空间给其中的某个逻辑卷创建快照卷。</p>
<blockquote>
<p>为什么能够实现VG的扩展以及LV的扩展？其实将PV放入VG时就要把PV这个物理卷的所有空间划分成一个物理块，及一个个存储单元。 这个块不是文件系统块，而是PE(PhysicalExtend物理盘区)，只要物理卷加入VG后，新加卷中划分的PE一定是和VG原因的PE大小相同。所以在创建VG时要制定VG所使用多大的PE。</p>
</blockquote>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>【MD】:Multi Device 多设备</p>
<p>Mdadm是一个用户空间工具，是RAID的管理工具，与真正的RAID工作没有太大关系。真正的RAID集成在linux内核中</p>
<p>【DM】Device Mapper设备映射也是linux中一种常用的管理机制</p>
<p>DM 与MD近似，也能够提供一种逻辑设备。DM比MD的功能要强大。因为DM不仅仅能提供MD的RAID的功能，它还是逻辑卷（LVM2）基础。同时，在逻辑卷的基础上我们也能实现RAID0,RAID1这样的功能。DM与MD中有某些功能是重叠的，但并不完全重叠。所以，我们通常使用MD做RAID用DM做LVM2。DM像MD一样也是有一个核心模块，和许多子模块组成的。例如MD的核心有RAID0,RAID1,RAID5,RAID1+0等，由多个子模块完成不同的级别。DM也是有多个子模块完成不同的组织方式。</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB89700cb2e26795cf3122f1060d00709e?method=download&shareKey=69125b23b714204d3f30cced62ae321b" alt="image"></p>
<p>例如：</p>
<ul>
<li>linear:有点类似Jbod。能够将多个磁盘的存储空间拼接在一块，当做一个磁盘来使用。</li>
<li>mirror:类似于镜像。</li>
<li>Snapshot：快照，向虚拟机一样，能够保留数据在做快照那一刻时的状态。快照，也可以说是访问同一条数据的另外一条路径。（主要用途是数据备份）</li>
<li>Multipath：多路径。多路径需要借助于DM模块来配置，能够实现数据存储设备的寻路能够通过多跟不同线来完成。</li>
</ul>
<h3 id="LVM使用流程"><a href="#LVM使用流程" class="headerlink" title="LVM使用流程"></a>LVM使用流程</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd1ecce605925715ca45bf008c7828c25?method=download&shareKey=40e1bb6104763d539a75435d5898d461" alt="image"></p>
<h3 id="LVM相关操作"><a href="#LVM相关操作" class="headerlink" title="LVM相关操作"></a>LVM相关操作</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/klb561/p/9074168.html">https://www.cnblogs.com/klb561/p/9074168.html</a></p>
<p>练习：<br>1、创建一个2G的分区，文件系统为ext2，卷标为DATA，块大小为1024，预留管理空间为磁盘分区的8%；挂载至&#x2F;backup目录，要求使用卷标进行挂载，且在挂载时启动此文件系统上的acl功能；</p>
<pre><code># mke2fs -L DATA -b 1024 -m 8  /dev/sda7

# mount -o acl LABEL=DATA /backup

# tune2fs -o acl /dev/sda7
# mount LABEL=DATA /backup
</code></pre>
<p>2、将此文件系统的超级块中的信息中包含了block和inode的行保存至&#x2F;tmp&#x2F;partition.txt中；</p>
<pre><code># tune2fs -l | egrep -i  &quot;block|inode&quot; &gt;&gt; /tmp/partition.txt  
# dumpe2fs -h |
</code></pre>
<p>3、复制&#x2F;etc目录中的所有文件至此文件系统；而后调整此文件系统类型为ext3，要求不能损坏已经复制而来的文件；</p>
<pre><code># cp -r /etc/*  /backup
# tune2	-j /dev/sda7
</code></pre>
<p>4、调整其预留百分比为3%；</p>
<pre><code># tune2fs -m 3 -L DATA /dev/sda7
</code></pre>
<p>5、以重新挂载的方式挂载此文件系统为不更新访问时间戳(表示在读文件时不去更改文件的access time属性），并验正其效果；</p>
<pre><code># stat /backup/inittab
# cat /backup/inittab
# stat
 
# mount -o remount,noatime /backup
# cat 
# stat
</code></pre>
<p>6、对此文件系统强行做一次检测；</p>
<pre><code>e2fsck -f /dev/sda7
</code></pre>
<p>7、删除复制而来的所有文件，并将此文件系统重新挂载为同步(sync)；而后再次复制&#x2F;etc目录中的所有文件至此挂载点，体验其性能变化；</p>
<pre><code># rm -rf /backup/*
# mount -o remount,sync /backup
# cp -r /etc/* /backup
</code></pre>
<p>8、创建一个5G的分区，文件系统为ext3，卷标为MYDATA，块大小为1024，预留管理空间为磁盘分区的3%，要求开机后可以自动挂载至&#x2F;data目录，并且自动挂载的设备要使用卷标进行引用；</p>
<p>9、创建一个本地回环文件&#x2F;var&#x2F;swaptemp&#x2F;swapfile来用于swap，要求大小为512MB，卷标为SWAP-FILE，且开机自动启用此交换设备；</p>
<pre><code># mkdir /var/swaptemp
# dd if=/dev/zero of=/var/swaptemp/swapfile bs=1M count=512
# mkswap LABLE=SWAP-FILE /var/swaptemp/swapfile

/etc/fstab
/var/swaptemp/swapfile  	swap		swap		defaults		0 0
</code></pre>
<p>10、上述第一问，如何让其自动挂载的同时启用ACL功能；</p>
<pre><code>/etc/fstab
LABEL=&#39;MYDATA&#39;		/data		ext3		defaults,acl	0 0
</code></pre>
<p>11、 创建一个空间大小为10G的RAID5设备；其chuck大小为32k；要求此设备开机时可以自动挂载至&#x2F;backup目录；</p>
<p>12、练习：创建一个由两个物理卷组成的大小为20G的卷组myvg，要求其PE大小为16M；而后在此卷组中创建一个大小为5G的逻辑卷lv1，此逻辑卷要能在开机后自动挂载至&#x2F;users目录，且支持ACL功能；</p>
<p>13、缩减前面创建的逻辑卷lv1的大小至2G；</p>
<p>写一个脚本(前提：请为虚拟机新增一块硬盘，假设它为&#x2F;dev&#x2F;sdb)，为指定的硬盘创建分区： </p>
<p>1、列出当前系统上所有的磁盘，让用户选择，如果选择quit则退出脚本；如  果用户选择错误，就让用户重新选择；</p>
<p>2、当用户选择后，提醒用户确认接下来的操作可能会损坏数据，并请用户确认；如果用户选择y就继续，n就退出；否则，让用户重新选择；  </p>
<p>3、抹除那块硬盘上的所有分区(提示，抹除所有分区后执行sync命令，并让脚本睡眠3秒钟后再分区)；并为其创建三个主分区，第一个为20M，第二个为512M, 第三个为128M，且第三个为swap分区类型；(提示：将分区命令通过echo传送给fdisk即可实现)  </p>
<pre><code>fdisk -l |grep &quot;

dd if=/dev/zero of=/dev/sdb bs=512 count=1
sync （程序在运行过程中会先修改内存，到达一定限制后才会从内存写入磁盘。此命令就是将内存中的改变写入磁盘）
sleep 3（dd修改硬盘速度很快，防止磁盘接受指令过快导致不识别）
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="note orange icon-padding flat">
<p> 本文介绍了磁盘的组成、磁盘分区、文件系统、swap分区、xfs文件系统的备份和还原、raid、lvm相关内容。<p>
</div>


<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><div class="note blue icon-padding flat">
<p>1. 简单描述一下本文讲了些什么？</p>
<p>2. 请描述一下MBR和GPT是什么？</p>
<p>3. CentOS7 为啥将默认文件系统改为xfs</p>
<p>4. raid？raid0？ raid1？ raid5？raid01？ raid10？</p>
<p>5. LVM的作用？LVM的组成？</p>
</div>

<div class="note green icon-padding flat">
<p>**参考内容**：</p> 
<p>1. 马哥Linux运维课程</p> 
<p>2. 鸟哥Linux私房菜-基础版</p> 
</div>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">QiYan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/27/Linux-file/">http://example.com/2022/11/27/Linux-file/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">知与行</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LVM/">LVM</a><a class="post-meta__tags" href="/tags/RAID/">RAID</a><a class="post-meta__tags" href="/tags/XFS/">XFS</a><a class="post-meta__tags" href="/tags/MBR/">MBR</a><a class="post-meta__tags" href="/tags/GPT/">GPT</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/27/Linux-Sed/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">sed（流编辑器）</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/25/Linux-basic/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">QiYan</div><div class="author-info__description">学而不思则惘 思而不学则殆</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-number">2.</span> <span class="toc-text">磁盘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%84%E6%88%90"><span class="toc-number">2.1.</span> <span class="toc-text">物理组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">分区组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MBR"><span class="toc-number">2.2.1.</span> <span class="toc-text">MBR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GPT"><span class="toc-number">2.2.2.</span> <span class="toc-text">GPT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ext-%E7%B3%BB%E5%88%97"><span class="toc-number">2.3.1.</span> <span class="toc-text">ext 系列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">xfs文件系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">分区命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fdisk"><span class="toc-number">3.1.1.</span> <span class="toc-text">fdisk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gdisk"><span class="toc-number">3.1.2.</span> <span class="toc-text">gdisk</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">创建文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ext%E7%B3%BB%E5%88%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">ext系列文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">xfs文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">3.2.3.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A3%80%E9%AA%8C"><span class="toc-number">3.3.</span> <span class="toc-text">文件系统检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xfs-repair"><span class="toc-number">3.3.1.</span> <span class="toc-text">xfs_repair</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80"><span class="toc-number">3.3.2.</span> <span class="toc-text">其它文件系统自检</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="toc-number">3.4.</span> <span class="toc-text">查询与修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD"><span class="toc-number">3.5.</span> <span class="toc-text">挂载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap%E5%88%86%E5%8C%BA"><span class="toc-number">3.6.</span> <span class="toc-text">swap分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAswap%E5%AE%9E%E4%BD%93%E5%88%86%E5%8C%BA"><span class="toc-number">3.6.1.</span> <span class="toc-text">创建swap实体分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAswap%E6%96%87%E4%BB%B6%E5%88%86%E5%8C%BA"><span class="toc-number">3.6.2.</span> <span class="toc-text">创建swap文件分区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xfs%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F"><span class="toc-number">3.7.</span> <span class="toc-text">xfs文件备份与还原</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xfsdump%E5%A4%87%E4%BB%BD"><span class="toc-number">3.7.1.</span> <span class="toc-text">xfsdump备份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xfsrestore%E8%BF%98%E5%8E%9F"><span class="toc-number">3.7.2.</span> <span class="toc-text">xfsrestore还原</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RAID"><span class="toc-number">4.</span> <span class="toc-text">RAID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-0"><span class="toc-number">4.0.1.</span> <span class="toc-text">raid 0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-1"><span class="toc-number">4.0.2.</span> <span class="toc-text">raid 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-5"><span class="toc-number">4.0.3.</span> <span class="toc-text">raid 5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid10"><span class="toc-number">4.0.4.</span> <span class="toc-text">raid10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-01"><span class="toc-number">4.0.5.</span> <span class="toc-text">raid 01</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raid-50"><span class="toc-number">4.0.6.</span> <span class="toc-text">raid 50</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jbod"><span class="toc-number">4.0.7.</span> <span class="toc-text">jbod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6raid%E7%BB%83%E4%B9%A0"><span class="toc-number">4.0.8.</span> <span class="toc-text">软件raid练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LVM"><span class="toc-number">5.</span> <span class="toc-text">LVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">5.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">5.2.</span> <span class="toc-text">工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVM%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">LVM使用流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LVM%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">5.4.</span> <span class="toc-text">LVM相关操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/15/Docker3/" title="docker数据卷和网络">docker数据卷和网络</a><time datetime="2022-12-15T12:16:17.374Z" title="发表于 2022-12-15 20:16:17">2022-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/15/Docker1/" title="docker镜像和容器管理">docker镜像和容器管理</a><time datetime="2022-12-15T11:58:22.832Z" title="发表于 2022-12-15 19:58:22">2022-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/15/Docker2/" title="docker镜像制作">docker镜像制作</a><time datetime="2022-12-15T11:56:40.452Z" title="发表于 2022-12-15 19:56:40">2022-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/12/Docker/" title="docker基础">docker基础</a><time datetime="2022-12-12T14:37:54.050Z" title="发表于 2022-12-12 22:37:54">2022-12-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/04/Linux%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Linux集群基础概念">Linux集群基础概念</a><time datetime="2022-12-04T11:14:41.278Z" title="发表于 2022-12-04 19:14:41">2022-12-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By QiYan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>